---
title: "Habitats"
author: "Christopher L. Crawford"
date: "11/16/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

This is part of the **Biodiversity Impacts of Abandonment** project, developed by Christopher L. Crawford, starting fall of 2021. 
See <https://github.com/chriscra/biodiversity_abandonment>.

```{r initialize}
source("/Users/christophercrawford/work/projects/biodiversity_abn/scripts/0_start.R")
```

```{r load-files}
source("/Users/christophercrawford/work/projects/biodiversity_abn/scripts/_util/_util_files.R")
```

```{r clean-up}
os <- get_sizes(ls())

os %>% 
  summarise(total_env_size = sum(size)) %>% 
  mutate(gb = total_env_size / 1024^3)

os %>% print(n = 30)

rm(list = os$object[c(1:6)])
# rm(list = os$object[c(3:18)])
get(os$object[c(30)])

# terra and raster temp files
terra::tmpFiles(current=TRUE, orphan=TRUE, old=TRUE, remove=FALSE)
terra::tmpFiles(current=TRUE, orphan=TRUE, old=TRUE, remove=TRUE)

raster::rasterTmpFile()
raster::showTmpFiles()
raster::removeTmpFiles()

warnings()
```

# Development

```{r conditional-summarise}

mpg %>% 
  group_by(manufacturer) %>%
  summarise(mean_cyl = mean(cyl),
            if (TRUE) {mean_hyw = mean(hwy)}
          )

mpg %>% 
  group_by(manufacturer) %>%
  summarise(mean_cyl = mean(cyl),
            mean_hyw = if (FALSE) mean(hwy)
          )

```

# PNV

```{r pnv}
# load PNV
pnv_1km <- raster(paste0(p_dat, "/Habitats/PNV/Hengl2019/1km/pnv_biome.type_biome00k_c_1km_s0..0cm_2000..2017_v0.1.tif"))

# Resolution
res(l) * 110 # = 0.9167 km grid (~ 1 km)


# ------------------------------------------------ #
# 250 m version, the one I'll use:
pnv <- rast(paste0(p_dat, "/Habitats/PNV/Hengl2019/250m/pnv_biome.type_biome00k_c_250m_s0..0cm_2000..2017_v0.2.tif"))
plot(pnv)


# Resolution
res(pnv_1km) * 110 # = 0.9167 km grid (~ 1 km)
res(pnv) * 110 # = 0.229 km grid (~ 250 m)


# ------------------------------------------------ #
# Load pnv table

# color palette information
pnv_table <- read_csv(
  paste0(p_dat, "Habitats/PNV/Hengl2019/250m/pnv_biome.type_biome00k_c_250m_s0..0cm_2000..2017_v0.2.tif.csv")) %>% 
  rename(Name = New.global.consolidated.biome.scheme) %>%
  mutate(labels = paste0(Number, ": ", Name),
         cols = rgb(red = R, green = G, blue = B, maxColorValue = 255)
         ) 

pnv_table %>% print(n = 22)

# Separate forest PNV classes from non-forest
pnv_table %>%
  # filter(Number %in% c(site_pnv_freq$value %>% unique())) %>%
  select(Number, Name, Mega_biome_classification) %>%
  filter(Number >= 17) %>% .$Name
  
site_pnv_freq %>% 
  arrange(value) %>%
  filter(value >= 16) %>%
  .$site %>% unique



pnv_table <- pnv_table %>% 
  mutate(forest = ifelse(grepl("forest", Name), "yes", "no"),
         rep_at_sites = ifelse(Number %in% c(site_pnv_freq$value %>% unique()),
                            "yes", "no"))

pnv_table

pnv_table %>% 
  filter(Number %in% c(site_pnv_freq$value %>% unique() %>% sort()))


pnv_table %>%
  filter(forest == "no") %>%
  select(Number, Name, Mega_biome_classification)

pnv_table %>%
  select(Number, rep_at_sites, Name, Mega_biome_classification,
         forest) %>% 
  print(n = 22)

non_forest_c_rates <- tibble()

grep("forest", pnv_table$Name)
# Non forest classes:
# "temperate evergreen needleleaf open woodland" 
# "tropical savanna"
# "steppe"
# "desert"   



```


```{r crop-pnv-to-sites}

# crop, and save to file
site_pnv <- lapply(1:11, function(i) {
  terra::crop(pnv, ext(lc[[i]]),
              filename = paste0(p_derived, "site_pnv/", 
                                names(lc[i]), "_pnv.tif"),
              overwrite = TRUE
              )
  }
  )
names(site_pnv) <- site_df$site

# load back in:
site_pnv <- lapply(
  list.files(paste0(p_derived, "site_pnv"), full.names = TRUE) %>% 
    grep("_pnv.tif", ., value = TRUE), 
  function(i) rast(i)
  )
names(site_pnv) <- site_df$site


# ---------------------------------------------- #
# crop with a buffer, to deal with NA issues: use this going forward
# ---------------------------------------------- #
plot(site_pnv$chongqing, colNA = "blue", ext = ext(site_pnv$chongqing) + rep(0.1, 4))

site_pnv <- lapply(1:11, function(i) {
  terra::crop(pnv, ext(lc[[i]]) + rep(0.1, 4), # with a bit of buffer
              filename = paste0(p_derived, "site_pnv/", 
                                names(lc[i]), "_pnv_buff.tif"),
              overwrite = TRUE
              )
  }
  )
names(site_pnv) <- site_df$site

# load back in
site_pnv <- lapply(
  list.files(paste0(p_derived, "site_pnv"), full.names = TRUE) %>%
    grep("buff", ., value = TRUE), 
  function(i) rast(i)
  )
names(site_pnv) <- site_df$site


```

```{r resample-pnv}
site_pnv_30 <- lapply(1:11, function(i) {
  terra::resample(
    x = site_pnv[[i]], y = lc[[i]]$y2017, method = "near",
    filename = paste0(p_derived, "site_pnv/", names(lc[i]), "_pnv_30.tif"),
    names = paste0(names(lc[i]), "_pnv_30"),
    overwrite = TRUE)
  }
  )

# load back in
site_pnv_30 <- lapply(
  list.files(paste0(p_derived, "site_pnv"), full.names = TRUE) %>% grep("_30.tif", ., value = TRUE), 
  function(i) rast(i)
  )
names(site_pnv_30) <- site_df$site

res(site_pnv$chongqing) * 110 # 250 m resolution
```

```{r pnv-plot}
# simple plots, with specified colors:

plot(pnv, 
     type = "classes", 
     col = pnv_table$cols, 
     levels = pnv_table$labels)


show_col(cbf_col)
show_col(pnv_table$cols)

show_col(gg_color_hue(12))


# plot a single site:
i <- 3

terra::plot(site_pnv[[i]], type = "classes",
       col = filter(pnv_table, 
                    Number %in% filter(site_pnv_freq, 
                                       site == site_df$site[i])$value)$cols, 
       levels = filter(pnv_table, 
                    Number %in% filter(site_pnv_freq, 
                                       site == site_df$site[i])$value)$labels
       )

plot(pnv, 
     type = "classes", 
     col = pnv_table$cols, 
     levels = pnv_table$labels)


# resampled:
plot(site_pnv$chongqing, main = "Original resolution, 250 m, with 0.1 deg buffer")
plot(site_pnv_30$chongqing, main = "Resampled to 30 m")

```

```{r freq-PNV}

# freq in each class
site_pnv_freq <- lapply(1:11, function(i) {
  freq(site_pnv_30[[i]]) %>% as_tibble() %>% mutate(site = site_df$site[i])
  }) %>% bind_rows()

site_pnv_freq %>% arrange

site_pnv_freq$value %>% unique() %>% sort() %>% length
pnv_table$Number %>% unique() %>% sort()

site_pnv_freq$value %>% unique() %>% sort()

site_pnv$belarus



```


```{r save-PNV-plot}
pdf(file = paste0(p_output, "plots/pnv_sites.pdf"), width = 10, height = 7.5)
mval <- 1.5
par(mfrow = c(3, 4), 
      # mar=c(0,0,0,0), 
      oma=c(1,1,0,0),
      adj = 0,
      cex.main = 1#,
      # tcl = -0.2
      )
    
# i<-11
# show_col(pnv_table %>% 
#          filter(Number %in% 
#                   filter(site_pnv_freq, 
#                          site == site_df$site[i])$value) %>% 
#          .$cols)
# freq(site_pnv_30[[i]])

for(i in 1:11) {
  plot(site_pnv_30[[i]], maxcell = 5000000,
       main = names(site_pnv_30[i]),
       mar = c(mval+0.5, mval, mval + 1.2, mval + 2), # bltr     
       type = "classes", #legend = FALSE,
       col = pnv_table %>%
         filter(Number %in%
                  filter(site_pnv_freq,
                         site == site_df$site[i])$value) %>%
         .$cols
)
  }

plot.new()
plot(site_pnv[[i]], type = "classes",
     legend = "left",
     plg = list(cex = 0.85, title = "Potential Natural Vegetation", title.adj = 0#, 
                # y.intersp	= 1.1
                # xjust = 0.5
                ),
     legend.only = TRUE,
     # col = pnv_table$cols, 
     # levels = pnv_table$labels
     col = filter(pnv_table, 
                  Number %in% c(site_pnv_freq$value %>% 
                                  unique() %>% sort())
                  )$cols,
     levels =
       filter(pnv_table, Number %in% c(site_pnv_freq$value %>% unique() %>% sort()))$labels #%>%
       # str_wrap(., width = 50)
     )
dev.off()

```

## PNV land cover classes 2020

```{r copernicus}
copernicus_table <- read_csv(paste0(p_proj, "resources/copernicus_lc_classes.csv")) %>%
   mutate(cols = rgb(red = R, green = G, blue = B, maxColorValue = 255),
          name_w_code = paste0(map_code, ": ", Name))

```

```{r pnv-lc}
pnv_2020_files <- read_csv(paste0(p_proj, "resources/pnv_2020_files.csv"))
pnv_2020_files$file_name

# the PNV 2020 Land Cover 
pnv_2020_files <- pnv_2020_files %>% 
  mutate(type = ifelse(grepl("_sd_", file_name), "sd",
                       ifelse(grepl("_p_", file_name), "p", "unsure")),
         name = gsub("pnv_potential.landcover_probav.lc100.", "", file_name),
         name = gsub("250m_s0..0cm_2017_v0.1.tif", "", name),
         name = gsub("_p_|_sd_", "", name))

pnv_2020_files %>% filter(type == "p") %>% .$name

pnv_lc <- rast(paste0(p_dat, "/Habitats/PNV/Hengl2020/pnv_potential.landcover_probav.lc100_c_250m_s0..0cm_2017_v0.1.tif"))

pnv20
pnv_lc

plot(pnv_lc)

# the resolution is ~250 m
res(pnv_lc)[1] * 110000 # 110,000 m / deg at the equator
res(pnv)[1] * 110000 # 110,000 m / deg at the equator
```


```{r pnv-lc-crop-resample}
# ------------------------------------------------------- #
# crop pnv_lc
# ------------------------------------------------------- #
site_pnv_lc <- lapply(1:11, function(i) {
  terra::crop(pnv_lc, ext(lc[[i]]) + rep(0.1, 4), # with a bit of buffer
              # filename = paste0(p_derived, "site_jung/", 
                                # names(lc[i]), "_jung_l1_buff.tif"),
              filename = paste0(p_derived, "site_pnv_lc/", 
                                names(lc[i]), "_pnv_lc_buff.tif"),
              overwrite = TRUE
              )
  }
  )
names(site_pnv_lc) <- site_df$site


# load back in:
site_pnv_lc <- lapply(
  list.files(paste0(p_derived, "site_pnv_lc"), full.names = TRUE) %>% 
    # grep("_pnv_lc.tif", ., value = TRUE), # without buffer
    grep("_pnv_lc_buff.tif", ., value = TRUE), # with buffer
  function(i) rast(i)
  )
names(site_pnv_lc) <- site_df$site

plot(site_pnv_lc$shaanxi)


# ------------------------------------------------------- #
# resample pnv_lc to 30 m
# ------------------------------------------------------- #

site_pnv_lc_30 <- lapply(1:11, function(i) {
  terra::resample(
    x = site_pnv_lc[[i]], y = lc[[i]]$y2017, method = "near",
    filename = paste0(p_derived, "site_pnv_lc/", names(lc[i]), "_pnv_lc_30.tif"),
    names = paste0(names(lc[i]), "_pnv_lc_30"),
    overwrite = TRUE)
  }
  )
names(site_pnv_lc_30) <- site_df$site


# load back in
site_pnv_lc_30 <- lapply(
  list.files(paste0(p_derived, "site_pnv_lc"), full.names = TRUE) %>% grep("_30.tif", ., value = TRUE), 
  function(i) rast(i)
  )
names(site_pnv_lc_30) <- site_df$site


res(site_pnv_lc$chongqing) * 110000 # ~250 m resolution
res(site_pnv_lc_30$chongqing) * 110000 # ~30 m resolution
```


```{r pnv-lc-freq}
# calculate frequency table:

# pnv land cover classes 2020 (matching copernicus LC)
site_pnv_lc_30_freq <- lapply(1:11, function(i) {
  freq(site_pnv_lc_30[[i]]) %>% as_tibble() %>% mutate(site = site_df$site[i])
  }) %>% bind_rows() %>% 
  select("map_code" = "value", count, site) %>%
  left_join(., select(pnv_lc_table, map_code, 
                      land_cover_class, land_cover_class_agg),
            by = "map_code") %>%
  left_join(., select(copernicus_table, map_code, Name, "land_cover_classC" = "land_cover_class"),
            by = "map_code")

site_pnv_lc_30_freq <- site_pnv_lc_30_freq %>% 
  left_join(., 
            site_pnv_lc_30_freq %>% 
              group_by(site) %>%
              summarise(total_px = sum(count))) %>%
  mutate(pnv_percent = 100*count/total_px) %>% 
  ungroup() %>%
  select(map_code, site, pnv_percent, land_cover_class_agg, Name, land_cover_classC, land_cover_class, count, total_px)

# write to file
site_pnv_lc_30_freq %>%
  write_csv(file = paste0(p_derived, "site_pnv_lc_30_freq.csv"))

site_pnv_lc_30_freq %>% 
  select(map_code, land_cover_class, land_cover_class_agg) %>%
  unique() %>% 
  arrange(map_code) %>% 
  mutate(label = paste0(map_code, " ", land_cover_class)) %>% 
  .$label %>% cat(sep = ", ")
```


```{r pnv-lc-table}
# pnv lc (2020) table

pnv_lc_table$map_code
# mapped to copernicus land cover categories

pnv_lc_table <- read_csv(
  paste0(p_dat, "/Habitats/PNV/Hengl2020/pnv_potential.landcover_probav.lc100_c_250m_s0..0cm_2017_v0.1.tif.csv")) %>%
  arrange(map_code)

# also, see:
copernicus_table

pnv_lc_table$land_cover_class
pnv_lc_table %>% print(n = 25)
copernicus_table %>% arrange(map_code) %>% print(n = 25)


left_join(pnv_lc_table, copernicus_table, by = "map_code") %>%
  print(n = 25)

site_pnv_lc_30_freq
# simple plots


terra::plot(site_pnv_lc_30[[i]], type = "classes",
       levels = filter(arrange(copernicus_table, map_code), 
                    map_code %in% filter(site_pnv_lc_30_freq,
                                         site == site_df$site[i])$map_code
                    )$Name,
       col = filter(arrange(copernicus_table, map_code), 
                    map_code %in% filter(site_pnv_lc_30_freq,
                                         site == site_df$site[i])$map_code
                    )$cols
       )

plot(site_pnv_lc$shaanxi)
plot(site_pnv_lc_30$shaanxi)



```

```{r plot-pnv_lc}
pdf(file = paste0(p_output, "plots/pnv_lc_sites_colors.pdf"), width = 10, height = 7.5)
mval <- 1.5
par(mfrow = c(3, 4), 
      # mar=c(0,0,0,0), 
      oma=c(1,1,0,0),
      adj = 0,
      cex.main = 1#,
      # tcl = -0.2
      )
    
for(i in 1:11) {
  plot(site_pnv_lc[[i]], #maxcell = 5000000,
       main = names(site_pnv_lc[i]),
       mar = c(mval+0.5, mval, mval + 1.2, mval + 2), # bltr     
       type = "classes", #legend = FALSE,
       col = filter(arrange(copernicus_table, map_code),
                    map_code %in% filter(site_pnv_lc_freq,
                                         site == site_df$site[i])$map_code
                    )$cols
)
  }

plot.new()
plot(site_pnv_lc[[i]], type = "classes",
     legend = "left",
     plg = list(cex = 0.95, title = "Potential Natural Vegetation", title.adj = 0#, 
                # y.intersp	= 1.1
                # xjust = 0.5
                ),
     legend.only = TRUE,
     levels = filter(arrange(copernicus_table, map_code), 
                    map_code %in% c(site_pnv_lc_freq$map_code %>% unique() %>% sort()))$name_w_code,
     col = filter(arrange(copernicus_table, map_code), 
                    map_code %in% c(site_pnv_lc_freq$map_code %>% unique() %>% sort()))$cols
     )
dev.off()

copernicus_table$Name 

```


# IUCN Habitat types

```{r load-jung-habitat-types}
# level 1
jung_l1 <- rast(paste0(p_dat, "Habitats/Jung_GlobalHabitatTypes/iucn_habitatclassification_composite_lvl1_ver004.tif"))
# jung_l1 <- rast(paste0(p_dat, "Habitats/Jung_GlobalHabitatTypes/iucn_habitatclassification_composite_lvl1_ver003.tif"))


# level 2
jung_l2 <- rast(paste0(p_dat, "Habitats/Jung_GlobalHabitatTypes/iucn_habitatclassification_composite_lvl2_ver004.tif"))
# jung_l2 <- rast(paste0(p_dat, "Habitats/Jung_GlobalHabitatTypes/iucn_habitatclassification_composite_lvl2_ver003.tif"))

plot(jung_l2, type = "classes")

# freq(jung_l2)
jung_freq <- read_csv(paste0(p_proj, "resources/jung_freq_table.csv"))
```


```{r jung-crop-resample}
# ---------------------------------------------- #
# crop with a buffer, to deal with NA issues: use this going forward
# ---------------------------------------------- #

site_jung_l1 <- lapply(1:11, function(i) {
  terra::crop(jung_l1, ext(lc[[i]]) + rep(0.1, 4), # with a bit of buffer
              filename = paste0(p_derived, "site_jung/", 
                                names(lc[i]), "_jung_l1_buff.tif"),
              overwrite = TRUE
              )
  }
  )
names(site_jung_l1) <- site_df$site

# load back in
site_jung_l1 <- lapply(
  list.files(paste0(p_derived, "site_jung"), full.names = TRUE) %>%
    grep("_l1_buff", ., value = TRUE), 
  function(i) rast(i)
  )
names(site_jung_l1) <- site_df$site


site_jung_l2 <- lapply(1:11, function(i) {
  terra::crop(jung_l2, ext(lc[[i]]) + rep(0.1, 4), # with a bit of buffer
              filename = paste0(p_derived, "site_jung/", 
                                names(lc[i]), "_jung_l2_buff.tif"),
              overwrite = TRUE
              )
  }
  )
names(site_jung_l2) <- site_df$site

# load back in
site_jung_l2 <- lapply(
  list.files(paste0(p_derived, "site_jung"), full.names = TRUE) %>%
    grep("_l2_buff", ., value = TRUE), 
  function(i) rast(i)
  )
names(site_jung_l2) <- site_df$site

plot(site_jung_l2$shaanxi, type = "classes")


# ------------------------------------------------------ #
# resample
# ------------------------------------------------------ #
# level 1
site_jung_l1_30 <- lapply(1:11, function(i) {
  terra::resample(
    x = site_jung_l1[[i]], y = lc[[i]]$y2017, method = "near",
    filename = paste0(p_derived, "site_jung/", names(lc[i]), "_jung_l1_30.tif"),
    names = paste0(names(lc[i]), "_jung_l1_30"),
    overwrite = TRUE)
  }
  )

# load back in
site_jung_l1_30 <- lapply(
  list.files(paste0(p_derived, "site_jung"), full.names = TRUE) %>% grep("l1_30.tif", ., value = TRUE), 
  function(i) rast(i)
  )
names(site_jung_l1_30) <- site_df$site

# level 2
site_jung_l2_30 <- lapply(1:11, function(i) {
  terra::resample(
    x = site_jung_l2[[i]], y = lc[[i]]$y2017, method = "near",
    filename = paste0(p_derived, "site_jung/", names(lc[i]), "_jung_l2_30.tif"),
    names = paste0(names(lc[i]), "_jung_l2_30"),
    overwrite = TRUE)
  }
  )

# load back in
site_jung_l2_30 <- lapply(
  list.files(paste0(p_derived, "site_jung"), full.names = TRUE) %>% grep("l2_30.tif", ., value = TRUE), 
  function(i) rast(i)
  )
names(site_jung_l2_30) <- site_df$site
```


```{r jung-freq}
# ----------------------------- #
# freq in each class
site_jung_l1_30_freq <- lapply(1:11, function(i) {
  freq(site_jung_l1_30[[i]]) %>% as_tibble() %>% mutate(site = site_df$site[i])
  }) %>% bind_rows() %>% 
  select("map_code" = "value", count, site) %>%
  left_join(select(jung_table, map_code, Coarse_Name, IUCNLevel))

site_jung_l2_30_freq <- lapply(1:11, function(i) {
  freq(site_jung_l2_30[[i]]) %>% as_tibble() %>% mutate(site = site_df$site[i])
  }) %>% bind_rows() %>% 
  select("map_code" = "value", count, site) %>%
  left_join(select(jung_table, map_code, Coarse_Name, IUCNLevel))

site_jung_l2_30_freq %>% 
  select(map_code, Coarse_Name, IUCNLevel) %>%
  unique() %>% arrange(map_code) %>% print (n=37)

# percent of each site in each habitat type:
# what proportion of the abandoned land at each site ends up in forest vs. grassland?

site_jung_l1_30_freq <- site_jung_l1_30_freq %>% 
  left_join(., 
            site_jung_l1_30_freq %>% 
              group_by(site) %>%
              summarise(total_px = sum(count))) %>%
  mutate(hab_percent = 100*count/total_px) %>% 
  ungroup() %>%
  select(map_code, site, hab_percent, Coarse_Name, IUCNLevel, count, total_px)
  

site_jung_l2_30_freq <- site_jung_l2_30_freq %>% 
  left_join(., 
            site_jung_l2_30_freq %>% 
              group_by(site) %>%
              summarise(total_px = sum(count))) %>%
  mutate(hab_percent = 100*count/total_px) %>% 
  ungroup() %>%
  select(map_code, site, hab_percent, Coarse_Name, IUCNLevel, count, total_px)


site_jung_l2_30_freq %>% 
  filter(#hab_percent > 1,
         site %in% site_df$site[c(7:10)]
         ) %>% 
  select(site, hab_percent, Coarse_Name, IUCNLevel) %>% 
  arrange(site, desc(hab_percent)) %>%
  print(n = 60)
  

site_jung_l2_30_freq %>% 
  filter(#hab_percent > 1,
         site %in% site_df$site[c(7:10)]
         ) %>% 
  select(site, hab_percent, Coarse_Name, IUCNLevel) %>% 
  group_by(site, Coarse_Name) %>% 
  summarise(total_percent = sum(hab_percent)) %>%
  arrange(site, desc(total_percent)) %>%
  print(n = 60)

site_jung_l2_30_freq %>% 
  filter(hab_percent > 0.5
         ) %>% 
  select(map_code, Coarse_Name, IUCNLevel) %>% unique() %>%
  arrange(Coarse_Name) %>%
  print(n = 60)


site_jung_l2_30_freq %>% 
    # filter(site == site_df$site[i]) %>%
    # filter(hab_percent > 0.5) %>%
    arrange(Coarse_Name, desc(hab_percent)) %>% 
    select(map_code, site, hab_percent, Coarse_Name, IUCNLevel) %>%
    # group_by(Coarse_Name, site) %>%
    # summarise(percent = sum(hab_percent)) %>%
    # arrange(Coarse_Name, desc(percent)) %>% 
    print(n = 170)

site_jung_l1_30_freq %>% 
    # filter(site == site_df$site[i]) %>%
    # filter(hab_percent > 0.5) %>%
    arrange(Coarse_Name, desc(hab_percent)) %>% 
    # select(map_code, site, hab_percent, Coarse_Name, IUCNLevel) %>%
    group_by(Coarse_Name, site) %>%
    summarise(percent = sum(hab_percent)) %>%
    arrange(Coarse_Name, desc(percent)) %>% 
    print(n = 170)



# write to file
site_jung_l1_30_freq %>%
  write_csv(file = paste0(p_derived, "site_jung_l1_30_freq.csv"))


# write to file
site_jung_l2_30_freq %>%
  write_csv(file = paste0(p_derived, "site_jung_l2_30_freq.csv"))


site_jung_l2_30_freq <- read_csv(file = paste0(p_derived, "site_jung_l2_30_freq.csv"))


```

```{r calc-area-per-habitat-type}

# load jung maps
site_jung_l2_30
sapply(site_jung_l2_30, ncell)
sapply(site_area_ha, ncell)

# calculate the area of the spatraster
site_area_ha <- lapply(
    list.files(paste0(p_derived, "site_area_ha"), full.names = TRUE), 
    function(i) rast(i)
    )

# combine the two, convert to data.table (without x and y coordinates), and calculate the area in each habitat type across each site.

jung_hab_type_area_df <- 
  lapply(1:11, function(i) {
    jung_dt <- spatraster_to_dt(
      spt = c(site_area_ha[[i]],
              site_jung_l2_30[[i]]
              ),
      xy_switch = FALSE)
    
    names(jung_dt) <- c("area_ha", "habitat_type")
    
    tmp_df <- 
      jung_dt[, sum(area_ha), 
              by = habitat_type] %>%
      as_tibble() %>%
      rename(area_ha = "V1") %>%
      arrange(habitat_type) %>%
      mutate(site = site_df$site[i])
    
    # return
    tmp_df
    }) %>% 
  bind_rows()


plot(site_jung_l2$belarus)
plot(site_jung_l2$belarus)
plot(abn_lcc$belarus$y2015)
plot(abn_lcc_iucn_habitat$belarus$y2015)
plot(abn_lcc$belarus$y1992)
plot(abn_lcc_iucn_habitat$belarus$y1992)


jung_hab_type_area_df %>% filter(site == "belarus") %>%
  select(habitat_type, area_ha, IUCNLevel, prop_lc)



jung_hab_type_area_df %>% print(n = 161)

# join to jung/IUCN ~ Yin et al. 2021 lc crosswalk
# ---------------------------------------------- #
# Jung table crosswalk
# ---------------------------------------------- #
iucn_crosswalk

jung_hab_type_area_df <- jung_hab_type_area_df %>%
  left_join(iucn_crosswalk, by = c("habitat_type" = "map_code")) %>%
  select(site, habitat_type, lc, area_ha, everything())

# adjusting the area of habitat amount based on habitat preferences
jung_hab_type_area_df <- jung_hab_type_area_df %>%
  arrange(site, lc, habitat_type) %>%
  left_join(
    jung_hab_type_area_df %>%
      group_by(site, lc) %>%
      summarise(total_area_per_lc = sum(area_ha)),
    by = c("site", "lc")) %>%
  mutate(prop_lc = area_ha / total_area_per_lc)


# write to file
jung_hab_type_area_df %>%
  write_csv(file = paste0(p_derived, "jung_hab_type_area_df.csv"))



jung_hab_type_area_df <- read_csv(file = paste0(p_derived, "jung_hab_type_area_df.csv"))
```


```{r save-plot-jung}
# jung_table
jung_table
# plot(site_jung_l2$iraq, type = "classes")

# ------------------ Level 1 ---------------------- # 

pdf(file = paste0(p_output, "plots/jung_l1_sites_colors.pdf"), width = 10, height = 7.5)
mval <- 1.5
par(mfrow = c(3, 4), 
      # mar=c(0,0,0,0), 
      oma=c(1,1,0,0),
      adj = 0,
      cex.main = 1#,
      # tcl = -0.2
      )
    
# i <- 3

for(i in 1:11) {
  
  tmp_table <- #jung_table %>%
    jung_l1_table_clr %>%
    arrange(map_code) %>% 
    filter(map_code %in% filter(site_jung_l1_30_freq,
                                site == site_df$site[i])$map_code
           )
  
  plot(site_jung_l1[[i]], maxcell = 5000000,
       main = names(site_jung_l1[i]),
       mar = c(mval+0.5, mval, mval + 1.2, mval + 2), # bltr     
       type = "classes", #legend = FALSE,
       col = tmp_table$cols,
       levels = tmp_table$map_code,
)
  }

# pdf(file = paste0(p_output, "plots/jung_sites_colors_legend.pdf"), width = 7.5, height = 7.5)
plot.new()
plot(site_jung_l1[[i]], type = "classes",
     legend = "left",
     plg = list(cex = 1,
                title = "IUCN Habitat Types\n(Level 1)",
                                # text.width = 100,
                title.adj = 0#,
                # y.intersp	= 1.1
                # xjust = 0.5
                ),
     legend.only = TRUE,
     levels =
       # str_wrap(
         filter(arrange(jung_l1_table_clr, map_code),
                    map_code %in% c(site_jung_l1_30_freq$map_code %>% unique() %>% sort()))$label,
                # width = 40, exdent = 5),
     col = filter(arrange(jung_l1_table_clr, map_code),
                    map_code %in% c(site_jung_l1_30_freq$map_code %>% unique() %>% sort()))$cols
     )

dev.off()


# ------------------ Level 2 ---------------------- # 

pdf(file = paste0(p_output, "plots/jung_l2_sites_colors.pdf"), width = 10, height = 7.5)
mval <- 1.5
par(mfrow = c(3, 4), 
      # mar=c(0,0,0,0), 
      oma=c(1,1,0,0),
      adj = 0,
      cex.main = 1#,
      # tcl = -0.2
      )
    
# i <- 5

for(i in 1:11) {
  
  tmp_table <- jung_table %>% 
    arrange(map_code) %>% 
    filter(map_code %in% filter(site_jung_l2_freq,
                                site == site_df$site[i])$map_code
           )
  
  plot(site_jung_l2[[i]], maxcell = 5000000,
       main = names(site_jung_l2[i]),
       mar = c(mval+0.5, mval, mval + 1.2, mval + 2), # bltr     
       type = "classes", #legend = FALSE,
       col = tmp_table$cols,
       levels = tmp_table$map_code,
)
  }

# pdf(file = paste0(p_output, "plots/jung_sites_colors_legend.pdf"), width = 7.5, height = 7.5)
plot.new()
plot(site_jung_l2[[i]], type = "classes",
     legend = "left",
     plg = list(cex = 0.47,
                title = "IUCN Habitat Types",
                                # text.width = 100,
                title.adj = 0#,
                # y.intersp	= 1.1
                # xjust = 0.5
                ),
     legend.only = TRUE,
     levels =
       # str_wrap(
         filter(arrange(jung_table, map_code),
                    map_code %in% c(site_jung_l2_freq$map_code %>% unique() %>% sort()))$label,
                # width = 40, exdent = 5),
     col = filter(arrange(jung_table, map_code),
                    map_code %in% c(site_jung_l2_freq$map_code %>% unique() %>% sort()))$cols
     )

dev.off()

```

```{r plot-jung-one-site}
i <- 9
i
mval <- 1.5
plot(site_jung_l2_30[[i]], maxcell = 5000000,
     main = paste0("IUCN Habitat Types, Level 2: ", names(site_jung_l2_30[i])),
     # mar = c(mval+0.5, mval, mval + 1.2, mval + 2), # bltr
     type = "classes", #legend = FALSE,
     col = jung_table %>%
       arrange(map_code) %>%
       filter(map_code %in% filter(site_jung_l2_30_freq,
                                   site == site_df$site[i])$map_code) %>%
       .$cols,
     # levels = jung_table %>%
     #   arrange(map_code) %>%
     #   filter(map_code %in% filter(site_jung_l2_30_freq,
     #                               site == site_df$site[i])$map_code) %>%
     #   .$map_code
     levels =
         filter(arrange(jung_table, map_code),
                map_code %in% filter(site_jung_l2_30_freq,
                                     site == site_df$site[i])$map_code)$label
)


pdf(file = paste0(p_output, "plots/jung_shaanxi_legend.pdf"), width = 7.5, height = 7.5)
plot.new()
plot(site_jung_l2_30[[i]], maxcell = 5000000,
     type = "classes",
     legend = "left",
     plg = list(cex = 1,
                title = "IUCN Habitat Types",
                                # text.width = 100,
                title.adj = 0#,
                # y.intersp	= 1.1
                # xjust = 0.5
                ),
     legend.only = TRUE,
     levels = jung_table %>%
       arrange(map_code) %>%
       filter(map_code %in% filter(site_jung_l2_30_freq,
                                     site == site_df$site[i])$map_code) %>%
       .$label,
     col = jung_table %>%
       arrange(map_code) %>%
       filter(map_code %in% filter(site_jung_l2_30_freq,
                                   site == site_df$site[i])$map_code) %>%
       .$cols
     )

dev.off()

plot(site_jung_l2_30[[i]], type = "classes")
```

```{r misc}
pdf(file = paste0(p_output, "plots/shaanxi_elevation.pdf"), width = 5, height = 4)
plot(elevation_map[[i]], main = "Elevation (m)")
dev.off()

```


```{r habitat-old}
# color palette information #
# level 1
habitat_table <- read_delim(
  file = paste0(p_dat, "Habitats/Jung_GlobalHabitatTypes/iucn_habitatclassification_code_ver003/styles/level1.clr"), delim = " ", col_names = c("Number", "R", "G", "B", "Opacity", "Name"))

# level 2
habitat_table <- read_delim(
  file = paste0(p_dat, "Habitats/Jung_GlobalHabitatTypes/iucn_habitatclassification_code_ver003/styles/level2.clr"), delim = " ", col_names = c("Number", "R", "G", "B", "Opacity", "Name"))
habitat_table <- habitat_table %>%
  mutate(Color = rgb(R, G, B, maxColorValue = 255))

habitat_table[habitat_table$Name == "Forest", "Color"] <- terrain.colors(15)[1]
habitat_table[habitat_table$Name == "Shrubland", "Color"] <- terrain.colors(15)[2]
habitat_table[habitat_table$Name == "Savanna", "Color"] <- terrain.colors(15)[3]
habitat_table[habitat_table$Name == "Grassland", "Color"] <- filter(plot_cols, name == "4. Grassland")$color
habitat_table[habitat_table$Name == "Artificial", "Color"] <- filter(plot_cols, name == "3. Crop")$color

plot_cols
show_col(plot_cols$color)
show_col(habitat_table$Color)
show_col(terrain.colors(15))
terrain.colors(9)
show_col("006633")
show_col("brown")


habitat
res(habitat) * 110 # = 0.0988 km grid (~ 0.10 km, ~ 100 m)

# crop:
s_habitat <- crop(habitat, extent(s$y2017))
b_habitat <- crop(habitat, extent(b$y2017))

sort(unique(values(s_habitat)))
sort(unique(values(b_habitat)))
filter(habitat_table, Number %in% unique(values(s_habitat)))
filter(habitat_table, Number %in% unique(values(b_habitat)))


# fancy plots
par(mfrow = c(2,2))
plot(s_habitat, main = "Shaanxi, Habitat Types",
     breaks = c(-1, 
                filter(habitat_table, Number %in% unique(values(s_habitat)))$Number),
     col = filter(habitat_table, Number %in% unique(values(s_habitat)))$Color)

legend("topleft", 
       legend = filter(habitat_table, Number %in% unique(values(s_habitat)))$Name, 
       fill = filter(habitat_table, Number %in% unique(values(s_habitat)))$Color,
       cex = 0.6, inset = 0)

# compare to raw land use data
plot(s$y2015, main = "Shaanxi 2015", 
     breaks = c(0, plot_cols$breaks), 
     col = plot_cols$color)
legend("bottomleft", cex = 0.6, inset = 0,
       legend = plot_cols$name, 
       fill = plot_cols$color)

# belarus
plot(b_habitat, main = "Belarus, Habitat Types",
     breaks = c(-1, 
                filter(habitat_table, Number %in% unique(values(b_habitat)))$Number),
     col = filter(habitat_table, Number %in% unique(values(b_habitat)))$Color)

legend("bottomleft", 
       legend = filter(habitat_table, Number %in% unique(values(b_habitat)))$Name, 
       fill = filter(habitat_table, Number %in% unique(values(b_habitat)))$Color,
       cex = 0.6, inset = 0)


# compare to raw land use data
plot(b$y2015, main = "Belarus 2015", breaks = c(0, plot_cols$breaks), col = plot_cols$color)
legend("bottomleft", cex = 0.6, inset = 0,
       legend = plot_cols$name, 
       fill = plot_cols$color)



habitat_table 
# 0   Water                     
# 100 Forest                   
# 200 Savanna                 
# 300 Shrubland               
# 400 Grassland              
# 500 Wetlands (inland)       
# 600 Rocky Areas            
# 800 Desert                 
# 1400 Artificial - Terrestrial
# 1700 Unknown
unique(values(b_habitat))
table(getValues(b_habitat))/ncell(b_habitat)
plot(b_habitat, main = "Belarus Habitat classes", breaks = c(0, 100, 300, 500, 1400), col = plot_cols$color[c(2, 4, 4, 3)])


# summary stats
b_habitat_area <- habitat_table %>%
  filter(Number %in% unique(values(b_habitat))) %>%
  select(Number, 
         Name = New.global.consolidated.biome.scheme) %>%
  mutate(
    area_percent = (table(getValues(b_pnv))/ncell(b_pnv))*100, # percentage in each
    area_km2 = 
      length(raster::area(b_pnv)) * 
      median(raster::area(b_pnv), na.rm = TRUE) * 
      area_percent/100
  )

```

## Crosswalks


```{r jung-table-crosswalk}
# ---------------------------------------------- #
# Jung table with classes
# ---------------------------------------------- #
jung_l1_table_clr <- read_delim(
  file = paste0(p_dat, "Habitats/Jung_GlobalHabitatTypes/Habitatmapping-004/styles/level1.clr"), 
  delim = " ", 
  col_names = c("map_code", "R", "G", "B", "Opacity", "Name")) %>%
  mutate(cols = rgb(R, G, B, maxColorValue = 255),
         label = paste0(map_code, ": ", Name)
  )


jung_l2_table_clr <- read_delim(
  file = paste0(p_dat, "Habitats/Jung_GlobalHabitatTypes/Habitatmapping-004/styles/level2.clr"), 
  delim = " ", 
  col_names = c("map_code", "R", "G", "B", "Opacity", "Name")) %>%
  mutate(cols = rgb(R, G, B, maxColorValue = 255))

jung_table <- read_csv(paste0(p_dat, "Habitats/Jung_GlobalHabitatTypes/Habitatmapping-004/IUCN_mapping_legend.csv")) %>%
  rename("map_code" = "NewCode") %>%
  mutate(IUCNLevel = gsub(" – | –", " - ", IUCNLevel)) %>%
  left_join(select(jung_l2_table_clr, map_code, cols, Coarse_Name = Name), by = "map_code") %>%
  mutate(label = paste0(map_code, ": ", IUCNLevel))

jung_table %>% select(map_code, IUCNLevel) %>% print(n = 126)

jung_table %>% 
  filter(map_code == 1404) %>%
  .$IUCNDefintion
  # .$Notes

# level 1
jung_table %>%
  filter((map_code %% 100) == 0) %>%
  select(map_code, Coarse_Name, IUCNLevel)



# ---------------------------------------------- #
# Jung table crosswalk
# ---------------------------------------------- #
iucn_crosswalk # see _util_files.R

iucn_crosswalk %>% arrange(lc, map_code) %>% print(n = 45)
iucn_crosswalk %>% arrange(map_code) %>% print(n = 45)

```

```{r pnv-to-IUCN-crosswalk}
# 20 shrubs, 30 herbaceous vegetation, 60 bare/sparse vegetation, 90 herbaceous wetland, 111 closed forest, evergreen needleleaf, 112 closed forest, evergreen broadleaf, 114 closed forest, deciduous broadleaf, 115 closed forest, mixed, 121 open forest, evergreen needleleaf, and 122 open forest, evergreen broadleaf
site_pnv_lc_30_freq %>% 
  select(map_code, Name, land_cover_class_agg) %>% 
  arrange(map_code) %>% 
  unique()

site_jung_l2_30_freq %>% 
  # filter(hab_percent > 1) %>%
  select(map_code, Coarse_Name, IUCNLevel) %>% 
  unique() %>% 
  arrange(map_code) %>% 
  print(n = 35)



IUCN_pnv_crosswalk

test <- site_jung_l2_30_freq %>% 
  arrange(map_code) %>% 
  select(map_code, Coarse_Name, IUCNLevel) %>% 
  unique() %>% 
  mutate(pnv_code = NA)

# test %>% mutate(pnv_code = if(grepl("1.4", test$IUCNLevel), "")))

site_jung_l2_30_freq %>% 
  filter(Coarse_Name == unique(site_jung_l2_30_freq$Coarse_Name)[1]) %>%
  arrange(map_code, desc(hab_percent))

site_jung_l2_30_freq %>% filter(site == site_df$site[i])
site_pnv_lc_30_freq %>% filter(site == site_df$site[i])


# ecoregions_simple %>% select(ECO_NAME) %>% 
  grep("Amaz", ecoregions_simple$ECO_NAME, value = TRUE)

ecoregions_simple %>%
  filter(ECO_NAME %in% grep("Amaz", ecoregions_simple$ECO_NAME, value = TRUE)) %>%
  st_geometry() %>% plot()

plot(jung_l2, add = T)


site_pnv_lc_freq %>% 
  select(land_cover_class, land_cover_class_agg) %>% 
  unique() %>%
  arrange(land_cover_class)


site_jung_l2_freq %>% 
  select(IUCNLevel, Coarse_Name) %>% 
  unique() %>%
  arrange(IUCNLevel)

# aggregated
site_pnv_lc_freq %>% 
  select(land_cover_class_agg) %>% 
  unique() %>%
  arrange(land_cover_class_agg)


site_jung_l2_freq %>% 
  select(Coarse_Name) %>% 
  unique() %>% .$Coarse_Name %>% cat()


site_jung_l2_freq$IUCNLevel %>% unique() %>% sort()

```


```{r calculate-overlap-IUCN-to-Yin}

i <- 3
lc[[i]]$y2015

site_jung_l1_30[[i]]
site_jung_l1_30_freq$map_code %>% sort %>% unique()
jung_l1_table_clr
jung_l2_table_clr

jung_table %>% 
  select(map_code, Coarse_Name) 

select(iucn_crosswalk, "is" = map_code, "becomes" = lc)

lc_plot_cols$name

# reclassify level 2 habitat types

iucn_crosswalk <- iucn_crosswalk %>% 
  mutate(
    #lc is where savanna is grassland (4) and shrubland is forest (2)
    
    # recode shrubland (IUCN) to 4, grassland (lc). 
    # This version has both savanna and shrubland as grassland (2)
    lc2 = ifelse(map_code >= 300 & map_code < 400, 4, lc), 
    
    # recode savanna (IUCN) to forest (lc). 
    # This version has both savanna and shrubland as forest (3)
    lc3 = ifelse(map_code >= 200 & map_code < 300, 2, lc), 
    
    # swap both: This version has savanna as forest (2), and shrubland as grassland (4)
    lc4 = ifelse(map_code >= 200 & map_code < 300, 2, lc2) 
  )

iucn_crosswalk %>% select(map_code:lc, lc2:lc4, IUCNLevel) %>% print(n = 50)


tic()
site_jung_l2_30_rcl <- 
  lapply(1:11, function(site) {
    rast(lapply(c("lc", "lc2", "lc3", "lc4"), function(lc_type) {
      classify(
        site_jung_l2_30[[site]],
        
        # cycles through lc, lc2, lc3, and lc4 as the "lc_type", to convert the map_code to.
        rcl = iucn_crosswalk %>% select("is" = map_code, "becomes" = lc_type),
        filename = paste0(p_derived, "site_jung/", site_df$site[site], "_jung_l2_rcl_", lc_type,".tif"),
        overwrite=TRUE)
      }
      )
    )
    }
    )
toc()


# load back in site_jung_l2_30_rcl
for (lc_type in c("lc", "lc2", "lc3", "lc4")) {}
tt <- rast(paste0(p_derived, "site_jung/", site_df$site[9], "_jung_l2_rcl_", 
                  c("lc", "lc2", "lc3", "lc4"), ".tif"))


site_jung_l2_30_rcl <- 
  lapply(1:11, function(i) {
    rast(paste0(p_derived, "site_jung/", site_df$site[i], "_jung_l2_rcl_", 
                  c("lc", "lc2", "lc3", "lc4"), ".tif"))
    }
    )

names(site_jung_l2_30_rcl) <- site_df$site
for(i in 1:11) {names(site_jung_l2_30_rcl[[i]]) <- c("lc", "lc2", "lc3", "lc4")}


plot(site_jung_l2_30_rcl[[3]]$lc, col = lc_plot_cols$color)
plot(lcc[[3]]$y2015, col = lc_plot_cols$color)

# Comparing how well the crosswalks match:
# Confusion Matrix
conf <- tmp_dt[, 1:2][, .N, by = c("y2015", "lc")][order(y2015, lc)]
conf %>% pivot_wider(names_from = lc, values_from = N)
                       

# --------------------------------------------------------------------- #
# calculate the jaccard similarities between Yin's land cover maps (2015) and the IUCN habitat map (Jung 2020), following four different recoding schemes.
# --------------------------------------------------------------------- #

site <- 3
crosswalk_jac0

identical(crosswalk_jac, crosswalk_jac0)

crosswalk_jac <- lapply(1:11, 
                        function(site) {
  tmp_t <- terra::rast(
    list(
      lcc[[site]]$y2015, # land cover in 2015
      site_jung_l2_30_rcl[[site]] # IUCN habitat types, reclassified
    )
    )

  # convert to data.table
  tmp_dt <- spatraster_to_dt(tmp_t, xy_switch = FALSE)
  
  # calculate Jaccard similarity
  jac_df <- lapply(c("lc", "lc2", "lc3", "lc4"), function(rcl_version){
    tibble(site = site_df$site[site],
           lc = 1:4,
           ver = rcl_version) %>%
      mutate(jaccard = sapply(lc, #1:4, 
                              function(lc_code) {
        int <- tmp_dt[y2015 == lc_code & get(rcl_version) == lc_code, .N] # intersection
        a <- tmp_dt[y2015 == lc_code, .N] 
        b <- tmp_dt[get(rcl_version) == lc_code, .N]
        int / (a + b - int) # int / union
        }))
    
    }
    ) %>% bind_rows()

  jac_df
  }) %>% 
  bind_rows()

write_csv(crosswalk_jac, paste0(p_derived, "jung_crosswalk_jaccard.csv"))

names(site_jung_l2_30_rcl) <- c("shrubs to forest, savanna to grass", 
                                "shrubs to grass, savanna to grass",
                                "shrubs to forest, savanna to forest", 
                                "shrubs to grass, savanna to forest")

# for (i in 1:24) {
gg_crosswalk_jac <-
  crosswalk_jac %>%
  filter(lc %in% c(2, 4)) %>%
  ggplot(mapping = aes(x = as_factor(lc), y = jaccard, fill = as_factor(ver))) +
    geom_col(size = 1, position = position_dodge2()) + 
    theme_classic() +
  labs(fill = "Crosswalk", x = "Land Cover Class", y = "Jaccard Similarity") +
  scale_x_discrete(labels = c("1" = "Non-veg",
                              "2" = "Forest",
                              "3" = "Cropland",
                              "4" = "Grassland")) +
  scale_fill_manual(values = met.brewer("Kandinsky", n = 4), #brewer.pal(n = 4, name = "Set1"), # gg_color_hue(4), #viridis(n = 4),
                    labels = c("lc" = "Shrubs <-> forest,\n savanna <-> grass", 
                                "lc2" = "Shrubs <-> grass,\n savanna <-> grass",
                                "lc3" = "Shrubs <-> forest,\n savanna <-> forest", 
                                "lc4" = "Shrubs <-> grass,\n savanna <-> forest")) +
  facet_wrap(vars(site), #scales = "free", 
             labeller = as_labeller(fancy_labels)) + 
  theme(
    # axis.text.x = element_text(angle = 30, vjust = 1, hjust = 1),
    legend.background = element_blank(),
    legend.position = c(0.875, 0.13))


ggsave(plot = gg_crosswalk_jac,
       filename = paste0(p_plots, "crosswalk_jaccard.pdf"),
       width = 6.25, height = 5, units = "in")
# }

i <- 1 # belarus
i <- 2 # bh
i <- 11 # wisc


plot(site_jung_l1_30[[i]])
plot(site_jung_l1_30[[i]],
     breaks = c(299, 301),
     main = paste0(names(site_jung_l1_30[[i]]), ": shrubland"))

plot(site_jung_l2_30[[i]],
     breaks = c(299, 399),
     main = paste0(names(site_jung_l2_30[[i]]), ": shrubland"),
     col = "red", add = T)

plot(lc[[i]]$y2015,
     col = lc_plot_cols$color)

# comparing grassland and shrubland, jung first
plot(site_jung_l2_30[[i]],
     breaks = c(299, 399),
     main = paste0(names(site_jung_l2_30[[i]]), ": shrubland"),
     col = "red")

plot(lc[[i]]$y2015,
     col = lc_plot_cols$color,
     breaks = c(3.9, 4.1),
     add = T)

# lc first
plot(lc[[i]]$y2015,
     col = lc_plot_cols$color,
     breaks = c(3.9, 4.1))

plot(site_jung_l2_30[[i]],
     breaks = c(299, 399),
     main = paste0(names(site_jung_l2_30[[i]]), ": shrubland"),
     col = "red", add = T)

jung_l2_table_clr %>% print(n = 82)

```

```{r comparing-PNV-and-ecoregions}

# plot PNV and ecoregions side by side:

site_pnv_lc_30$belarus

cat(paste0(site_df$site, " (", 1:11, ")\n"))

# ---------- forest biomes: ---------- #
# belarus (1)
# bosnia_herzegovina (2)
# wisconsin (11)
# chongqing (3) - tropical


site_ecoregions2017 %>% st_drop_geometry() %>% select(site, BIOME_NAME) %>% unique()

# ---------- Savanna biomes: ---------- #
# goias (4)
# mato_grosso (6)

# ---------- shrublands / desert biomes: ---------- #
# iraq (5)

# ---------- grasssland biomes: ---------- #
# nebraska (7)
# orenburg (8)
# shaanxi (9)
# volgograd (10)


plot(site_forest_c_30$chongqing, main = "Resampled to ~30 m")

for(i in 1:2) {
  plot(site_forest_c_30[[i]], main = site_df$site[i])
  site_ecoregions2017 %>% 
  filter(site == site_df$site[i],
         BIOME_NAME %in% grep("Savanna",
                         site_ecoregions2017$BIOME_NAME,
                         value = TRUE)) %>%
  st_geometry() %>% plot(col = "red", add = TRUE)
  
  Sys.sleep(4)
  
}

plot(pnv_lc)

plot(pnv_lc, ext = ext(lc[[i]]$y2017 + 1), maxcell = 1e8)

```


## Directly assign land cover to IUCN habitat types

In a previous version of the AOH function, we calculated the area in each land cover class (i.e., of the four land cover classes in the original Yin et al. 2020 land cover maps).
We created a crosswalk to translate our coarse land cover classes into the finer habitat types used by the IUCN, and mapped by Jung et al. 2020 for the year 2015. 
This crosswalk is captured in `r iucn_crosswalk`.
Because this crosswalk involves "one to many" relationships (i.e., one land cover class, such as 2 [woody vegetation], could be multiple IUCN habitat types).
For example, `r iucn_crosswalk %>% filter(lc == 2)`.
But, we don't know what any given pixel in lc class 2 (woody vegetation) is, of the various IUCN habitat types.

We had previously used a proportional approach to downscale these coarse land cover classes (e.g., “woody vegetation [2]”) to the finer IUCN habitat classes (e.g., “Forest – Boreal ”), allocating pixels according to the proportion of the broad category each of the IUCN habitat types occupy at each of our sites.
This proportional approach is similar to what other researchers have used (e.g., [Folberth et al. 2020](https://www.nature.com/articles/s41893-020-0505-x)).
So, if a site has 20% temperate forest and 10% subtropical/tropical moist montane forest, for a total of 30% in some type of forest, we would allocate 2/3 of pixels in forest to temperate forest and 1/3 to moist montane forest. 
This was conducted for each year individually - so the area of each land cover class was calculated for each year, and these were then adjusted by the proportion of that land cover class occupied by each IUCN habitat type ("map_code") at each site.
This proportion was calculated for each species iteratively, because the number of habitat types that were suitable for a given species changed over time.

Our new method is designed to directly assign habitat types to each pixel based on the land cover type.
Essentially, we assign each pixel in a land cover (e.g., "woody vegetation [2]") to the nearest analogous habitat type in the 2015 @Jung2020a habitat map.

We essentially follow four steps:  

1. Reclassify the habitat map to extract only those habitat types that fall within the above land cover class (e.g., 2, woody vegetation).

2. Fill all NA values in this reclassified habitat map with the modal value of the surrounding 9 cell values, using `terra::focal(fun = "modal")`.

3. Resample these focal habitat reclassifications to finer resolution 

4. Mask each resampled focal habitat map to locations of that given land cover class, in each year.

5. Construct a composite habitat map for each year by knitting together these four resampled habitat maps
(Either by converting NAs to zeros and adding, or some other method.)

6. Mask this composite to the area abandoned in each year, for each site.

7. Use this as the final habitat map for calculating area of habitat.


```{r lcc-iucn-habitat-composite}
site_index <- 3
lc_class <- 2

lc_classes <- 1:4
# lc_classes <- c(2, 4)


plot(abn_lcc[[site_index]][["y2015"]])
plot(lcc[[site_index]][["y2015"]])


# loop through all 11 sites:

lapply(1:11, function(site_index) {
cat(fill = TRUE, 
    "Direct reclassification of land cover classes into IUCN habitat map codes:", 
    site_df$site[site_index])

# -------------------------------------------- # 
# 1. Reclassify the habitat map to extract only those habitat types that fall within the above land cover class (e.g., 2, woody vegetation).

# for multiple land cover classes at once:
cat(fill = TRUE, "Subset the Jung habitat map into maps corresponding to four land cover classes.")

iucn_sub <- lapply(seq_along(lc_classes), function(i) {
  lc_class <- lc_classes[i]
  
  classify(
    site_jung_l2[[site_index]],
    rcl = iucn_crosswalk %>% 
      filter(lc != lc_class) %>% select(is = map_code) %>% mutate(becomes = NA),
    names = paste0("lc", lc_class)
    )
  }) %>% rast()

# plot(iucn_sub)

# -------------------------------------------- # 
# 2. Fill all NA values in this reclassified habitat map with the modal value of the surrounding 9 cell values, using `terra::focal(fun = "modal")`.

# loop through each land cover layer until there are no more NA values.
cat(fill = TRUE, "Use focal() to fill all NA cells with modal value for each lc subset.")

tic()
iucn_focal <- lapply(seq_along(lc_classes), function(i) {
  x <- terra::focal(iucn_sub[[i]], w = 3, 
                    fun = "modal", na.rm = TRUE, na.policy = "only", expand = TRUE
                    )
  
  while(is.na(global(x, fun = "min"))) {
    x <- terra::focal(x, w = 3, fun = "modal", 
                      na.rm = TRUE, na.policy = "only", expand = TRUE)
  }
  
  x
  }) %>% rast()
toc()

names(iucn_focal) <- paste0(names(iucn_sub), "_iucn_focal")

# plot(iucn_focal)
# iucn_crosswalk %>% print(n = 50)


# save this composite layer:
writeRaster(iucn_focal,
            filename = paste0(p_derived, "lcc_iucn_habitat/", 
                              site_df$site[site_index], "_iucn_focal.tif"),
            names = names(iucn_focal),
            overwrite = TRUE)


# iucn_focal <- rast(paste0(p_derived, "lcc_iucn_habitat/", 
#                               site_df$site[site_index], "_iucn_focal.tif"))

# -------------------------------------------- # 
# 3. Resample each resampled habitat map to finer resolution.

cat(fill = TRUE, "Resample iucn_focal to site extent and resolution.")

iucn_focal_resampled <- 
  lapply(seq_along(lc_classes), function(i) {
  terra::resample(
    x = iucn_focal[[i]], y = lcc[[site_index]][[31]], 
    method = "near"
    )
  }) %>% rast()

# plot(iucn_focal_resampled)


# -------------------------------------------- # 
# 4. Mask directly, based on cell values, rather than with a intermediate step mask.
# this results in a list with a 31-layer spatraster for each land cover class, showing just the habitat map codes for the pixels in that land cover in that year:
cat(fill = TRUE, "Mask and save iucn_focal_msk.")

tic()
iucn_focal_msk <- lapply(seq_along(lc_classes), function(i) {
  terra::mask(
    iucn_focal_resampled[[i]], lcc[[site_index]],
    maskvalues = lc_classes[i], inverse = TRUE,
    names = names(lcc[[site_index]]),
    filename = paste0(p_derived, "lcc_iucn_habitat/", site_df$site[site_index],
                     "_iucn_focal_msk_lc", lc_classes[i], ".tif"),
    overwrite = TRUE
  )}
)
names(iucn_focal_msk) <- paste0("lc", lc_classes)
toc()

# plot(iucn_focal_msk[[1]][[28:31]])
# plot(iucn_focal_msk[[2]][[28:31]])
# plot(iucn_focal_msk[[3]][[28:31]])
# plot(iucn_focal_msk[[4]][[28:31]])
# plot(lcc[[site_index]][[28:31]], col = lc_plot_cols$color)


# -------------------------------------------- # 
# 5. Construct a composite habitat map for each year by knitting together these four resampled habitat maps
# (Either by converting NAs to zeros and adding, or some other method.)

cat(fill = TRUE, "Use cover() to knit together four masked SpatRasters.")
tic()
lcc_iucn_habitat <- cover(iucn_focal_msk[[1]], iucn_focal_msk[[2]])
if (length(iucn_focal_msk) > 2) {
  lcc_iucn_habitat <- cover(lcc_iucn_habitat, iucn_focal_msk[[3]])
}

if (length(iucn_focal_msk) > 3) {
  lcc_iucn_habitat <- cover(lcc_iucn_habitat, iucn_focal_msk[[4]])
}
toc()

# plot(lcc_iucn_habitat[[28:31]])
# plot(site_jung_l2[[site_index]])


# save this composite layer:
writeRaster(lcc_iucn_habitat,
            filename = paste0(p_derived, "lcc_iucn_habitat/", 
                              site_df$site[site_index], "_lcc_iucn_habitat.tif"),
            names = names(lcc_iucn_habitat),
            overwrite = TRUE)

terra::tmpFiles(current=TRUE, orphan=TRUE, old=TRUE, remove=TRUE)

##### End of lapply() call #####
})
```


```{r mask-lcc-iucn-habitat-to-abn}
# -------------------------------------------- # 
# 7. Mask this composite to the area abandoned in each year, for each site.

# Note: the pixels in "abn_lcc_iucn_habitat" are NA until they are abandoned... therefore, they exclusively have non-cropland habitat.
# The "max_abn_lcc_iucn_habitat" includes values for all pixels that are abandoned at any point during the time series, and includes a habitat type for each year of the time series. So, it includes the habitat before and after abandonment. 
# This is the final layer that should be used to create results. 

# reload
lcc_iucn_habitat <- lapply(1:11, function(i) {
  rast(paste0(p_derived, "lcc_iucn_habitat/",
              site_df$site[i], "_lcc_iucn_habitat.tif"))
  })
names(lcc_iucn_habitat) <- site_df$site

plot(lcc_iucn_habitat[[1]][[28:31]])

terra::tmpFiles(current=TRUE, orphan=TRUE, old=TRUE, remove=TRUE)



# ---------------------------------------------------------------- #
# [pre] calculate the new iucn habitat codes in pixels *after* they are abandoned
# ---------------------------------------------------------------- #
i <- 9

tic()
lapply(1:11, function(i) {
  # make sure to restrict lc to only 1987:2017 (Nebraska, Wisconsin)
  # i <- 9
  cat("Masking:", site_df$site[i], "...", fill = TRUE)
  tmp <- abn_mask[[i]] + lcc_iucn_habitat[[i]][[paste0("y", 1987:2017)]]
  
  cat("Writing SpatRaster to file:", site_df$site[i], "...", fill = TRUE)
  writeRaster(tmp, 
              filename = paste0(p_derived, "lcc_iucn_habitat/",
                        site_df$site[i], "_abn_lcc_iucn_habitat", run_label, ".tif"), 
              overwrite = TRUE,
              names = names(tmp))
  cat(site_df$site[i], "done!", fill = TRUE)

})
toc()

# plot(abn_lcc_iucn_habitat[[1]][[31]])

# reload
abn_lcc_iucn_habitat <- lapply(1:11, function(i) {
  rast(paste0(p_derived, "lcc_iucn_habitat/",
              site_df$site[i], "_abn_lcc_iucn_habitat", run_label, ".tif"))
  })
names(abn_lcc_iucn_habitat) <- site_df$site



# ---------------------------------------------------------------- #
# ***** Calculate iucn habitats for all pixels that were ever abandoned
# including habitats before *and* after abandonment, to show the net change
# as a result of abandonment.
# ---------------------------------------------------------------- #

# compare to 
max_abn_lcc
max_age_mask

tic()
max_abn_lcc_iucn_habitat <- lapply(1:11, function(i) {
  # make sure to restrict lc to only 1987:2017 (Nebraska, Wisconsin)
  # i <- 9
  cat("Masking:", site_df$site[i], "...", fill = TRUE)
  tmp <- max_age_mask[[i]] + lcc_iucn_habitat[[i]][[paste0("y", 1987:2017)]]
  
  cat("Writing SpatRaster to file:", site_df$site[i], "...", fill = TRUE)
  writeRaster(tmp, 
              filename = paste0(p_derived, "lcc_iucn_habitat/",
                        site_df$site[i], "_max_abn_lcc_iucn_habitat", run_label, ".tif"), 
              overwrite = TRUE,
              names = paste0("y", 1987:2017))
  cat(site_df$site[i], "done!", fill = TRUE)

})
toc()


# reload

max_abn_lcc_iucn_habitat <- 
  lapply(1:11, function(i) {
  rast(paste0(p_derived, "lcc_iucn_habitat/",
              site_df$site[i], "_max_abn_lcc_iucn_habitat", run_label, ".tif"))
  })
names(max_abn_lcc_iucn_habitat) <- site_df$site


plot(max_abn_lcc_iucn_habitat$shaanxi[[28:31]])

# -------------------------------------------- # 
# 8. Save - Use this as the final habitat map for calculating area of habitat.
max_abn_lcc_iucn_habitat


```


### IUCN habitats in potential abandonment without recultivation

Calculating the area of habitat if no recultivation took place.
How do I go about determining the land cover (and subsequently, the IUCN habitat types) for the potential abandonment layer?
The issue is that this layer does not have land cover classes associated with it. 

Perhaps I could use the cover() function to add the land cover classes from the abandonment mask to each other, iteratively, to get the latest land cover type before the abandoned cropland was recultivated. I could then use this to determine the habitat type, frozen (if you will) at the point right before it was recultivated, but allowed to continue on. 
I guess I could also do this with the `lcc_iucn_habitat` rasters, since this has already been constrained to just the lc codes of abandoned pixels.

The max_age raster has the exact same extent as the potential abandonment in the final year of the time series.

```{r test-cover-abn-lcc}
abn_mask

site_index <- 9

potential_age_t[[site_index]]$y2017 %>% plot()
age_t[[site_index]]$y2017 %>% plot()

small_ext <- draw()

age_t[[site_index]]$y2017 %>% plot(ext = small_ext)
potential_age_t[[site_index]]$y2017 %>% plot(ext = small_ext)

at <- crop(abn_lcc[[site_index]], small_ext)
lt <- crop(lcc[[site_index]], small_ext)
lit <- crop(lcc_iucn_habitat[[site_index]], small_ext)
ait <- crop(abn_lcc_iucn_habitat[[site_index]], small_ext)

magt <- crop(max_age_t[[site_index]], small_ext)
mt <- crop(max_age_mask[[site_index]], small_ext)

plot(at)
plot(lt)
plot(ait[[31]])
freq(abn_lcc_iucn_habitat[[site_index]][[28:31]])
iucn_crosswalk %>% print(n= 50)
plot(mt2)
plot(mtt>4)

mtt <- classify(
      mtt,
      rcl = tibble(from = 0,
                   to = 4,
                   becomes = NA_real_),
      othersNA = FALSE,
      include.lowest = TRUE, right = TRUE)
plot(mtt)
plot(is.na(mtt))
plot(is.na(mt2))
plot(ptt[[31]]>4)
plot(is.na(ptt[[31]]>4))

cit <- cover(ait[[31]], ait[[30]])
for (i in (nlyr(ait)-2):6) {
  cit <- cover(cit, ait[[i]])
}

plot(cit)
plot(ct)
plot(is.na(cit))
plot(is.na(ct))

plot(tt[[31]])
plot(tt[[30]])
plot(ct)

ct <- cover(tt[[31]], tt[[30]], values = NA)
for (i in (nlyr(tt)-2):6) {
  ct <- cover(ct, tt[[i]])
}
plot(ct)


plot(ct - tt[[31]])
plot(is.na(ct))
plot(is.na(tt[[31]]))
plot(is.na(ptt[[31]]))
plot(is.na(mtt))
plot(is.na(ct) - is.na(tt[[31]]))


plot(tt[[31]])
plot(ptt[[31]])
plot(mtt)

plot(is.na(ptt[[31]]))
plot(is.na(mtt))


plot(is.na(ptt[[31]]) - is.na(mtt))

#
tt
plot(tt[[22:31]])


# -------------------------------------------------- #
# full test, with chongqing

tic()
full_test <- cover(abn_lcc_iucn_habitat[[site_index]][[31]], abn_lcc_iucn_habitat[[site_index]][[30]])
for (i in (nlyr(abn_lcc_iucn_habitat[[site_index]])-2):6) {
  full_test <- cover(full_test, abn_lcc_iucn_habitat[[site_index]][[i]])
}
toc()


max_abn_lcc_iucn_habitat
```

*** The need for a new potential abn map:

I produced the first version of "potential_abn_lcc_iucn_habitat" was created by using cover(), which sequentially layered years on top of each other, looking for NA pixels in each year, and updating those with corresponding values from the previous year. 
Therefore, anything that was recultivated (i.e., NA in that year) was filled with the value from the year before.
This means that recultivation is filled in with the land use from the previous year.
Unfortunately though, if a pixel is abandoned, recultivated (NA), then abandoned again (non-NA), this second wave of abandonment won't be replaced with the first abandonment, because the pixel isn't NA. 
So, the land cover might revert from forest back to grassland, a younger stage of regeneration.

The second issue is that, regardless, I need to produce a version of the potential_abn_lcc_iucn layer that includes the habitat before and after, to match the max_abn_lcc_iucn layer.

There are a few different approaches I could take:
1. Use cover() to fill NA pixels in potential_abn_lcc_iucn with corresponding values from lcc_iucn (the full landscape), for each year:
So, cover(x = potential\$y1995, y = max_abn_lcc\$y1995) would take the layer potential in year 1995 and update all NA values (i.e., pixels that haven't yet been abandoned) and replace them with the corresponding land cover (should be just agriculture).

2. Perhaps I could update all grassland codes in one year with the values from the previous year. 
This means that any pixel that went from forest to grassland would be replaced with the forest from the previous year. If it stayed as grassland, it would be replaced with grassland. 
I'd need to do this with just the abandonment, so that it doesn't get replaced with cropland.

3. Alt
Hmm. How can I implement this with the new, max_abn_lcc_iucn_habitat raster?
These are the habitats in each pixel that was abandoned at some point during the time series.
So, I want to keep the cropland that occurred before abandonment, but not allow any recultivation.

4. Alternatively, I could directly do this with the abandonment lc data.table. 

```{r dev-potential-dt}
site_index <- 9

small_ext <- draw()
small_ext

age_t[[site_index]]$y2017 %>% plot(ext = small_ext)
potential_age_t[[site_index]]$y2017 %>% plot(ext = small_ext)

at <- crop(abn_lcc[[site_index]], small_ext)
lt <- crop(lcc[[site_index]], small_ext)
agt <- crop(age_t[[site_index]], small_ext)
pgt <- crop(potential_age_t[[site_index]], small_ext)

plot(at[[31]])
plot(lt[[31]])
plot(agt[[31]])
plot(pgt[[31]])

adt <- spatraster_to_dt(at)
ldt <- spatraster_to_dt(lt)
agdt <- spatraster_to_dt(agt)
pgdt <- spatraster_to_dt(pgt)

agdt

dt2 <- agdt[c(15:19, 28:40), -c("x", "y", paste0("y", 1987:1995))]

dt1 <- adt[c(15:19, 28:40), -c("x", "y", paste0("y", 1987:1995))]
at
att <- subst(at, from = 4, to = 2)
dt <- spatraster_to_dt(att)[c(15:19, 28:40), -c("x", "y", paste0("y", 1987:1995))]
dt

xy <-  spatraster_to_dt(att)[c(15:19, 28:40), .(x,y)]
xy
xy$x %>% paste0(.,collapse = ", ")
xy$y %>% paste0(.,collapse = ", ")

dt[14, 12:13] <- NA
dt[14, 14:15] <- 4
dt$x

minmax(att)
dt
# Approach: subset to NA cells, and set them equal to the value from the year before.
# 1. If the pixel represents the recultivation of abandonment, then it will set it equal to the land cover from the year right before recultivation.
# 2. If it's not recultivation, it won't have a value in the prior year, and so will remain NA.
dt[is.na(y2008), y2008:= y2007 + 100]
dt
dt[
  # find all values that are NA in a given year, and...
  is.na(y2010),
  
  # set them equal to the value from the previous year.
  y2010 := y2009 + 100
   ]

dt[is.na(y2010),] # find all values that are NA in a given year, and...
dt
dt[14, 12:13] <- 2


dt# for each column, subset to those pixels that are 0
 # ----- 3. Pass the recultivation calculation function. ----- #
  for (i in start:ncol(dt)) {
    
    # subset rows that are equal to 0 (for crop), and
    dt[get(names(dt)[i]) == 0, 
       
       # set them equal to the previous column's value in that row, minus 1.
       names(dt)[i] := get(names(dt)[i-1]) - 1] 
  }

```


I might be able to do this by modifying the data.table potential age calculation function to only allow transitions from 2 to 4, not from 4 to 3. 
Then, I could mask the four focal habitat maps with the new versions of the four land cover types, to get the direct composite of the habitat types. 
Then mask this to the max_abn outline.


But, can I do this with cover?
If I work backwards:


Maybe I can have it replace values that are in arable cropland again in the next layer ().
But, the problem is that these will not allow the land cover types to change from grassland to forest. So, they'll be frozen in early stages of succession.

I could simply 

Maybe make cropland NA?

```{r *create-potential-abn-iucn}
# site_index <- 3

tic()
lapply(1:11, function(site_index) {
  cat("Build potential habitat layer sequentially using terra::cover(), for",
      site_df$site[site_index], fill = TRUE)
  potential_tmp <- lapply(1:31, function(i) {abn_lcc_iucn_habitat[[site_index]][[i]]})
  
  # start in year 6 ("y1992"), which is the first year abandonment is possible.
  for (i in 6:31) {
    tic(paste0("cover() on i = ", i))
    potential_tmp[[i]] <- cover(potential_tmp[[i]], potential_tmp[[i-1]])
    toc()
  }
  
  tic("Combine list layers with rast()")
  potential_tmp <- rast(potential_tmp)
  toc()

  cat("Writing potential_tmp SpatRaster to file:", site_df$site[site_index], "...", fill = TRUE)
  writeRaster(potential_tmp, 
              filename = paste0(p_derived, "lcc_iucn_habitat/",
                        site_df$site[site_index], "_potential_abn_lcc_iucn_habitat",
                        run_label, ".tif"), 
              overwrite = TRUE,
              names = names(potential_tmp))
  
  cat(site_df$site[site_index], "done!", fill = TRUE)
})
toc()

# load back in:
potential_abn_lcc_iucn_habitat <- lapply(1:11, function(i){
  rast(paste0(p_derived, "lcc_iucn_habitat/",
                    site_df$site[i], "_potential_abn_lcc_iucn_habitat",
                    run_label, ".tif"))
})
names(potential_abn_lcc_iucn_habitat) <- site_df$site
```

```{r **potential_max}
# Use cover() to combine the potential_abn_iucn layer with the land cover classes in max_abn_iucn layer
potential_abn_lcc_iucn_habitat
max_abn_lcc_iucn_habitat

potential_abn_lcc_iucn_habitat_freq %>% 
  filter(site == site_df$site[site_index]) %>%
  left_join(iucn_crosswalk %>% select(map_code, IUCNLevel, lc)) %>%
  group_by(year) %>%
  summarise(n_px = sum(count)) %>%
  print(n = 35)

max_abn_lcc_iucn_habitat_freq %>% 
  filter(site == site_df$site[site_index]) %>%
  left_join(iucn_crosswalk %>% select(map_code, IUCNLevel, lc)) %>%
  group_by(year) %>%
  summarise(n_px = sum(count)) %>%
  print(n = 35)

max_potential_abn_lcc_iucn_habitat_freq %>% 
  filter(site == site_df$site[site_index]) %>%
  left_join(iucn_crosswalk %>% select(map_code, IUCNLevel, lc)) %>%
  group_by(year) %>%
  summarise(n_px = sum(count)) %>%
  print(n = 35)


jung_hab_type_area_df

temp_labels <- jung_hab_type_area_df %>% 
  arrange(IUCNLevel) %>%
  filter(site == site_df$site[3]) %>% 
  .$IUCNLevel

names(temp_labels) <- jung_hab_type_area_df %>% 
  arrange(lc, IUCNLevel) %>%
  filter(site == site_df$site[3]) %>% 
  .$habitat_type

temp_labels <- iucn_crosswalk$IUCNLevel
names(temp_labels) <- iucn_crosswalk$map_code
max_potential_abn_lcc_iucn_habitat_freq %>% 
  filter(site == site_df$site[3]) %>%
  ggplot(mapping = aes(x = year, y = count, 
                       color = fct_reorder(as_factor(map_code), count, .desc = TRUE), 
                       group = map_code)) +
  labs(color = NULL) +
  geom_line(size = 1.5) + 
  scale_color_manual(values = gg_color_hue(12),
                     labels = as_labeller(temp_labels)
                     )

max_potential_abn_lcc_iucn_habitat_freq %>% 
  filter(site == site_df$site[site_index], map_code == 1401) %>% print(n=40)

max_potential_abn_lcc_iucn_habitat_freq %>% 
  filter(site == site_df$site[3], year == 2017) %>%
  left_join(select(iucn_crosswalk, map_code, IUCNLevel))
iucn_crosswalk %>% print(n = 40)
# cover()

potential_abn_iucn

# make small versions for testing:
small_ext <- draw()
potential_abn_lcc_iucn_habitat[[site_index]][[9]] %>% plot()
max_abn_lcc_iucn_habitat[[site_index]][[9]] %>% plot()

potential_abn_lcc_iucn_habitat[[site_index]]$y2017 %>% plot(ext = small_ext)
max_abn_lcc_iucn_habitat[[site_index]]$y2017 %>% plot(ext = small_ext)

s1 <- crop(potential_abn_lcc_iucn_habitat[[site_index]], small_ext)
s2 <- crop(max_abn_lcc_iucn_habitat[[site_index]], small_ext)

iucn_crosswalk %>% print(n = 3000)

s1
s2

# -----------------------------------------------------------------
# Use cover() to combine potential_abn_lcc_iucn_habitat maps (created above)
# with the max extent abn_lcc_iucn maps, to allow for a before and after
# comparison of AOH in abandoned croplands, in a scenario without reculivation.
# -----------------------------------------------------------------

tic()
lapply(1:11, function(site_index) {
  cat("Build potential habitat layer for max extent using terra::cover(), for",
      site_df$site[site_index], fill = TRUE)
  max_potential_abn_lcc_iucn_habitat <- 
    cover(x = potential_abn_lcc_iucn_habitat[[site_index]], 
          y = max_abn_lcc_iucn_habitat[[site_index]],
          filename = paste0(p_derived, "lcc_iucn_habitat/",
                            site_df$site[site_index], "_max_potential_abn_lcc_iucn_habitat",
                            run_label, ".tif"), 
          overwrite = TRUE,
          names = names(potential_abn_lcc_iucn_habitat[[site_index]]))
  cat(site_df$site[site_index], "done!", fill = TRUE)
})
toc()

# load back in:
max_potential_abn_lcc_iucn_habitat <- lapply(1:11, function(i){
  rast(paste0(p_derived, "lcc_iucn_habitat/",
                    site_df$site[i], "_max_potential_abn_lcc_iucn_habitat",
                    run_label, ".tif"))
})
names(max_potential_abn_lcc_iucn_habitat) <- site_df$site

max_abn_lcc_iucn_habitat
max_potential_abn_lcc_iucn_habitat

max_potential_abn_lcc_iucn_habitat[[site_index]]$y1997 %>% !is.na(.) %>% plot()
max_age_mask[[site_index]] %>% !is.na(.) %>% plot()

plot(is.na(max_age_mask[[site_index]]))
plot(is.na(max_potential_abn_lcc_iucn_habitat[[site_index]]$y1997))

plot(is.na(max_age_mask[[site_index]]) - 
       is.na(max_potential_abn_lcc_iucn_habitat[[site_index]]$y1997))

```



```{r check-lapply-results}
potential_abn_lcc_iucn_habitat
potential_abn_lcc_iucn_habitat0
# Check - everything looks ok.
# --------------------------------------------- #
# test to make sure this worked:

# --------
# test 1 - compare to the full manual test of layer 31:
plot(potential_abn_lcc_iucn_habitat$chongqing$y2017, ext = small_ext)
plot(full_test, ext = small_ext)

# --------
# two ways to compare rasters:
# 1. Do the same cells have values in each?
# 2. Are the values of the cells in each equal to each other?

# --------
# 1.
tic()
global(potential_abn_lcc_iucn_habitat$chongqing$y2017, fun = "isNA")
toc()

tic()
global(full_test, fun = "isNA") # or global(is.na(full_test), fun = "sum")
toc()

# --------
# 2. Fill NAs with 0s, match

# check chongqing
t1 <- potential_abn_lcc_iucn_habitat$chongqing$y2017
t2 <- full_test

tic()
t1 <- classify(t1, rcl = tibble("is" = NA_real_, "becomes" = 0))
toc()

tic()
t2 <- classify(t2, rcl = tibble("is" = NA_real_, "becomes" = 0))
toc()

plot(t1)
plot(t2)
global(t1, fun = "isNA")
global(t2, fun = "isNA")

plot(t1 - t2)
global(t1 - t2, "sum")


# --------
# test 2 - compare to the extent of potential_abn, for 5 and older.

# compare chongqing
site_index <- 3
plot(potential_abn_lcc_iucn_habitat[[site_index]]$y2017, ext = small_ext)

plot(potential_abn_lcc_iucn_habitat$chongqing$y2017>0)
plot(potential_abn_mask$chongqing$y2017)

t3 <- potential_abn_lcc_iucn_habitat$chongqing$y2017
t4 <- potential_abn_mask$chongqing$y2017
as.numeric(global(t3, fun = "isNA")) == 
  as.numeric(global(t4, fun = "isNA"))

# compare belarus
plot(potential_abn_lcc_iucn_habitat$belarus$y2017>0)
plot(potential_abn_mask$belarus$y2017)

t3 <- potential_abn_lcc_iucn_habitat$belarus$y2017
t4 <- potential_abn_mask$belarus$y2017
global(t3, fun = "isNA")
global(t4, fun = "isNA")


# compare, sequentially:
site_index <- 3
for (site_index in 1:11) {
# plot(potential_abn_lcc_iucn_habitat[[site_index]]$y2017>0, main = "Main result")
# plot(potential_abn_mask[[site_index]]$y2017, main = "Potential abn mask")

t3 <- potential_abn_lcc_iucn_habitat[[site_index]]$y2017
t4 <- potential_abn_mask[[site_index]]$y2017
print("Do the number of NAs match?")
print(
  as.numeric(global(t3, fun = "isNA")) == 
    as.numeric(global(t4, fun = "isNA"))
)
}

# everything looks good. 

```

```{r freq-abn_lcc}

# -------------------------- #
abn_lcc_iucn_habitat_freq <- lapply(1:11, function(i) {
  freq(abn_lcc_iucn_habitat[[i]][[6:31]]) %>% as_tibble() %>% 
    mutate(site = site_df$site[i],
           year = layer + 1991) %>%
  rename(map_code = value)
  }) %>% bind_rows()
write_csv(abn_lcc_iucn_habitat_freq, file = paste0(p_derived, "freq/abn_lcc_iucn_habitat_freq.csv"))
abn_lcc_iucn_habitat_freq <- read_csv(paste0(p_derived, "freq/abn_lcc_iucn_habitat_freq.csv"))

# -------------------------- #
potential_abn_lcc_iucn_habitat_freq <- lapply(1:11, function(i) {
  freq(potential_abn_lcc_iucn_habitat[[i]][[6:31]]) %>% as_tibble() %>% 
    mutate(site = site_df$site[i],
           year = layer + 1991) %>%
  rename(map_code = value)
  }) %>% bind_rows()
write_csv(potential_abn_lcc_iucn_habitat_freq, file = paste0(p_derived, "freq/potential_abn_lcc_iucn_habitat_freq.csv"))
potential_abn_lcc_iucn_habitat_freq <- read_csv(paste0(p_derived, "freq/potential_abn_lcc_iucn_habitat_freq.csv"))


# -------------------------- #
lcc_iucn_habitat_freq <- lapply(1:11, function(i) {
  freq(lcc_iucn_habitat[[i]][[1:31]]) %>% as_tibble() %>% 
    mutate(site = site_df$site[i],
           year = layer + 1986) %>%
  rename(map_code = value)
  }) %>% bind_rows()
write_csv(lcc_iucn_habitat_freq, file = paste0(p_derived, "freq/lcc_iucn_habitat_freq.csv"))


# -------------------------- #
abn_lcc_freq <- lapply(1:11, function(i) {
  freq(abn_lcc[[i]][[6:31]]) %>% as_tibble() %>% 
    mutate(site = site_df$site[i],
           year = layer + 1991) %>%
  rename(lc = value)
  }) %>% bind_rows()
write_csv(abn_lcc_freq, file = paste0(p_derived, "freq/abn_lcc_freq.csv"))

# -------------------------- #
max_abn_lcc_freq <- lapply(1:11, function(i) {
  freq(max_abn_lcc[[i]][[1:31]]) %>% as_tibble() %>% 
    mutate(site = site_df$site[i],
           year = layer + 1986) %>%
  rename(lc = value)
  }) %>% bind_rows()
write_csv(max_abn_lcc_freq, file = paste0(p_derived, "freq/max_abn_lcc_freq.csv"))
max_abn_lcc_freq <- read_csv(file = paste0(p_derived, "freq/max_abn_lcc_freq.csv"))

# -------------------------- #
max_abn_lcc_iucn_habitat_freq <- lapply(1:11, function(i) {
  
  freq(max_abn_lcc_iucn_habitat[[i]][[1:31]]) %>% as_tibble() %>% 
    mutate(site = site_df$site[i],
           year = layer + 1986) %>%
  rename(map_code = value)
  }) %>% bind_rows()

write_csv(max_abn_lcc_iucn_habitat_freq, 
          file = paste0(p_derived, "freq/max_abn_lcc_iucn_habitat_freq.csv"))
max_abn_lcc_iucn_habitat_freq <- read_csv(file = paste0(p_derived, "freq/max_abn_lcc_iucn_habitat_freq.csv"))


# -------------------------- #
max_potential_abn_lcc_iucn_habitat_freq <- lapply(1:11, function(i) {
  freq(max_potential_abn_lcc_iucn_habitat[[i]][[1:31]]) %>% as_tibble() %>% 
    mutate(site = site_df$site[i],
           year = layer + 1986) %>%
  rename(map_code = value)
  }) %>% bind_rows()

write_csv(max_potential_abn_lcc_iucn_habitat_freq, 
          file = paste0(p_derived, "freq/max_potential_abn_lcc_iucn_habitat_freq.csv"))
max_potential_abn_lcc_iucn_habitat_freq <- read_csv(file = paste0(p_derived, "freq/max_potential_abn_lcc_iucn_habitat_freq.csv"))


# -------------------------- #
max_potential_abn_lcc_iucn_habitat


# sort out
abn_lcc_iucn_habitat_freq %>% group_by(site) %>% summarise(my_codes = unique(map_code)) %>%
  .$my_codes %>% unique() %>% sort()
iucn_crosswalk %>% 
  filter(map_code %in% (abn_lcc_iucn_habitat_freq %>% 
                          group_by(site) %>% 
                          summarise(my_codes = unique(map_code)) %>%
                          .$my_codes %>% unique() %>% sort())) %>%
  print()

potential_abn_lcc_iucn_habitat_freq %>% 
  group_by(year, site) %>% 
  summarise(sum = sum(count)) %>%
  arrange(site) %>% View()

max_abn_lcc_freq %>% 
  group_by(year, site) %>% 
  summarise(sum = sum(count)) %>%
  ungroup() %>% select(site, sum) %>% unique() %>%
  arrange(site) #%>% View()

max_abn_lcc_iucn_habitat_freq %>% 
  group_by(year, site) %>% 
  summarise(sum = sum(count)) %>%
  ungroup() %>% select(site, sum) %>% unique() %>%
  arrange(site)

freq_cols <- plot_cols[1:4]
names(freq_cols) <- 1:4

ggplot(data = max_abn_lcc_freq #%>% filter(site == "belarus")
         ) +
  theme_classic() +
  # theme(axis.text.x = element_text(angle = 320, vjust = 1, hjust = 0)) +
  labs(y = "Count", 
       x = "Year", 
       color = NULL) + 
  geom_line(mapping = aes(x = year, y = count / (10^6), # convert to millions of ha
                          group = as_factor(lc), color = as_factor(lc)),
            size = 1.5) + 
  theme(legend.position = c(0.9, 0.12),
        legend.title = element_text(size = 10)) +
  
  scale_color_manual(
    values = freq_cols
    # values = as.vector(plot_cols[2:4]),    #c("#276419" , "#E8C32E" , "#7FBC41"),
    # labels = names(plot_cols[2:4])   #, breaks = 2:4
                     ) +
  guides(color = guide_legend(ncol = 1)) +
  facet_wrap(vars(site),
             labeller = as_labeller(fancy_labels),
             scales = "free")




plot(tmp)
tmp_freq <- freq(tmp) %>% as_tibble() %>% 
    mutate(site = site_df$site[i],
           year = layer + 1986) %>%
  rename(map_code = value)


tmp_freq %>% 
  group_by(year, site) %>% 
  summarise(sum = sum(count)) %>%
  arrange(site)

iucn_crosswalk %>% print(n = 40)
```


```{r generic-compare-two-rasters}
# --------------------------------------------------------- #
#  BE CAREFUL with comparing two rasters
# --------
# two ways to compare rasters:
# 1. Do the same cells have values in each?
# 2. Are the values of the cells in each equal to each other?

t1 <- potential_abn_lcc_iucn_habitat$chongqing$y2017
t2 <- full_test

t1 <- tc[[28]]
t2 <- t28

plot(tc[[28]])
plot(t28)

# --------
# 1.
tic()
global(t1, fun = "isNA")
toc()

tic()
global(t2, fun = "isNA") # global(is.na(t2), fun = "sum")
toc()

# --------
# 2. Fill NAs with 0s, match
tic()
t1 <- classify(t1, rcl = tibble("is" = NA_real_, "becomes" = 0))
toc()

tic()
t2 <- classify(t2, rcl = tibble("is" = NA_real_, "becomes" = 0))
toc()

plot(t1)
plot(t2)
plot(t1 - t2)
global(t1 - t2, "sum")


```

## Extract abandonment signal starting from cultivation

Idea 1:
1. Extract just cropland. 
2. Calculate the minimum, in order to figure out the year of first cultivation
(This might require converting the values of each layer to the layer number, which might or might not be straightforward.)

Or, use data.table to identify the first year of cropland.
Might be able to do this with dt_diff, or by going through each column, selecting cells that are equal to non-crop, and then set these equal to 0.
Or, by using dt_binary.

```{r abn-signal-beginning-w-crop}
dt <- cc_create_bin()
dt[V1 == 0, NA]

#

site <- site_df$site[indx]
lapply(site_df$site, function(site){
  # Step 1. Load dt_binary
  dt <- fread(paste0(p_input_rasters, site, "_binary", run_label, ".csv"))
  
  # Step 2. cc_calc_age()
  # ------- The codes I'll want to remove are the ones that correspond to 
  # ------- the column index.
  cc_calc_age(dt)
  dt
  
  # Step 3. 
  
dt
cc_extract_noncrop_precrop(dt)
dt

fwrite(dt, file = paste0(p_input_rasters, site, "_noncrop_precrop_mask", run_label,".csv"))


# Step 4. Convert this into a SpatRaster:
noncrop_start_mask_tmp <- dt_to_spatraster(dt)
terra::writeRaster(noncrop_start_mask_tmp,
                   filename = paste0(p_input_rasters, site, "_noncrop_start_mask", run_label,".tif"),
                   overwrite = TRUE,
                   names = names(noncrop_start_mask_tmp))
})

# load a list of all noncrop_start_mask rasters

noncrop_start_mask <- lapply(1:11, function(i) {
  terra::rast(paste0(p_input_rasters, site_df$site[i], "_noncrop_start_mask", run_label,".tif"))
})


# Step 5. Mask the max_abn_iucn_habitat and max_potential_abn_iucn_habitat SpatRasters
lapply(1:11, function(i) {
  terra::mask(
    max_abn_iucn_habitat[[i]], noncrop_start_mask[[i]],
    maskvalues = NA, inverse = TRUE,
    names = names(max_abn_iucn_habitat[[i]]),
    filename = paste0(p_derived, "lcc_iucn_habitat/", site_df$site[i],
                     "_crop_to_abn_iucn.tif"),
    overwrite = TRUE
  )
})



```


## [Old, Development] Assigning via nearest neighbor

```{r direct-assignment}
site_index <- 9

site_jung_l2_30_freq %>%
  filter(site == site_df$site[site_index])

jung_hab_type_area_df

iucn_crosswalk %>% arrange(map_code) %>% print(n = 50)

jung_hab_type_area_df %>%
  filter(site == site_df$site[site_index])

site_jung_l2_30[[site_index]]
lcc[[site_index]]


# reclassify, via direct

dir_back <- 
      classify(
        site_jung_l2_30[[site_index]],
        rcl = iucn_crosswalk %>% select("is" = map_code, "becomes" = lc)#,
        # filename = paste0(p_derived, "site_jung/", site_df$site[site], "_jung_l2_rcl_", lc_type,".tif"),
        # overwrite=TRUE
        )


names(site_jung_l2_30_rcl) <- site_df$site


# plot
pdf(file = paste0(p_output, "plots/reclassifying/jung_to_lc_shaanxi.pdf"), width = 10, height = 4.5)
par(mfrow = c(1, 2))
plot(dir_back, main = "IUCN habitats reclassified to coarse LC",
     col = lc_plot_cols$color, levels = lc_plot_cols$name)
plot(lc[[site_index]][["y2015"]], main = "Land cover, Shaanxi, 2015",
     col = lc_plot_cols$color, levels = lc_plot_cols$name)
dev.off()


```

```{r direct-resample}
# ------------------------------ 1. Reclassify ----------------------------------- #
# first, reclassify the land cover maps to just single categories
# then, do the same for the IUCN map, leaving the map codes intact.
site_index <- 9
lc_class <- 2

tic()
rcl_lc <- classify(
        lcc[[site_index]][["y2015"]],
        rcl = tibble(is = lc_class, becomes = lc_class), # simple rcl, e.g., where 2 stays 2, everything else is converted to NA
        othersNA = TRUE,
        filename = paste0(p_tmp, site_df$site[site_index], "_lcc_rcl_", lc_class,".tif"),
        overwrite=TRUE
        )
toc()
plot(rcl_lc)

tic()
rcl_lc_alt <- classify(
        lcc[[site_index]][["y2015"]],
        rcl = tibble(is = 0:4, becomes = NA) %>% filter(is != 2),
        # rcl = tibble(is = lc_class, becomes = lc_class),
        # othersNA = TRUE,
        filename = paste0(p_tmp, site_df$site[site_index], "_lcc_rcl_", lc_class,"_alt.tif"),
        overwrite=TRUE
        )
toc()
plot(rcl_lc_alt)


tic()
rcl_lc_alt2 <- subst(lcc[[site_index]][["y2015"]], c(0, 1, 3, 4), NA,
                     filename = paste0(p_tmp, site_df$site[site_index], "_lcc_rcl_",
                                       lc_class,"_alt2.tif"),
                     overwrite=TRUE)
toc()
plot(rcl_lc_alt2)

plot(rcl_lc_alt2)
rcl_iucn

#  IUCN

tic()
rcl_iucn <- classify(
        site_jung_l2_30[[site_index]],
        rcl = iucn_crosswalk %>% filter(lc != 2) %>% select(is = map_code) %>% mutate(becomes = NA),
        # othersNA = TRUE,
        filename = paste0(p_tmp, site_df$site[site_index], "_iucn_rcl_", lc_class,".tif"),
        overwrite=TRUE
        )
toc()
plot(rcl_iucn)

freq(rcl_iucn)


tic()
rcl_iucn_alt <- classify(
        site_jung_l2_30[[site_index]],
        rcl = iucn_crosswalk %>% filter(lc == 2) %>% select(is = map_code, becomes = map_code),
        othersNA = TRUE,
        filename = paste0(p_tmp, site_df$site[site_index], "_iucn_rcl_", lc_class,"_alt.tif"),
        overwrite=TRUE
        )
toc()
plot(rcl_iucn_alt)
```

```{r dir-reclassify-100m}
site_jung_l2

# reclassify lc and iucn
tic()
rcl_iucn_100 <- classify(
        site_jung_l2[[site_index]],
        rcl = iucn_crosswalk %>% filter(lc != 2) %>% select(is = map_code) %>% mutate(becomes = NA),
        # othersNA = TRUE,
        filename = paste0(p_tmp, site_df$site[site_index], "_iucn_100_rcl_", lc_class, ".tif"),
        overwrite=TRUE
        )
toc()
plot(rcl_iucn_100)

plot(site_jung_l2[[site_index]])
plot(rcl_lc)

# ------------------------------------------------------------------- #
# try the resampling now:
compareGeom(rcl_iucn_100, rcl_lc)
ext(rcl_lc)
ext(rcl_iucn_100)

res(rcl_lc) * 110000
res(rcl_iucn_100) * 110000

plot(rcl_iucn_100)

# this still doesn't work.
resam100 <- terra::resample(rcl_iucn_100, rcl_lc, method = "near")

plot(rcl_iucn_100)
plot(resam100)
plot(rcl_lc)

ncell(rcl_iucn_100)

```


```{r focal-resample}
# ------------------------------ 2. Resample ----------------------------------- #
# what I'm trying to do: 
# convert all forest pixels (lc == 2) in lc map (rcl_lc) and match them to the type of forest habitat type that is closest to it in the IUCN habitat map (rcl_iucn) 

plot(rcl_lc)
plot(rcl_iucn)
freq(rcl_iucn)

plot(rcl_iucn_100)

# resample doesn't work, unfortunately. I think this requires different spatial resolutions, extents, etc.
# these don't fill NA values. 

resam1 <- terra::resample(rcl_iucn_100, rcl_lc, method = "near") # this takes the habitat map (rcl_iucn_100), and essentially crops it to the extent and cell size of rcl_lc.
resam2 <- terra::resample(rcl_lc, rcl_iucn_100, method = "near") # this simply puts the values from rcl_lc (2s) into the same extent and cell size as rcl_iucn_100 (the habitat map)

plot(rcl_lc)
plot(rcl_iucn_100)
plot(resam1)
plot(resam2)

dist1 <- terra::distance(rcl_iucn, rcl_lc)

# filling NAs
r <- rast(ncol=30, nrow=30, 
          # xmn=0, xmx=10, ymn=0,ymx=10,
          xmin=0, xmax=30, 
          ymin=0, ymax=30,
          crs='+proj=longlat +datum=WGS84') 
r[] <- 1:30
r[sample(1:ncell(r), size = 800)] <- NA
plot(r)
text(r)
ncell(r)

w <- matrix(1, 5, 5)  #c(0,1,0,1,0,1,0,1,0), nrow=3)
# x <- raster::focal(r, w, modal, na.rm=TRUE, NAonly=TRUE, pad=TRUE)
x_1 <- terra::focal(r, w = 3, # fun = function(i) {terra::modal(i, ties = "first", na.rm = TRUE)},
                  fun = "modal", ties = "first",
                  na.rm = TRUE, na.policy = "only", expand = TRUE)

x_rand <- terra::focal(r, w = 3, # fun = function(i) {terra::modal(i, ties = "first", na.rm = TRUE)},
                  fun = "modal", ties = "random",
                  na.rm = TRUE, na.policy = "only", expand = TRUE)

plot(x_1)
plot(x_rand)


x <- terra::focal(r, w = 3, # fun = function(i) {terra::modal(i, ties = "first", na.rm = TRUE)},
                  fun = "modal", 
                  na.rm = TRUE, na.policy = "only", expand = TRUE)
plot(x)

x <- terra::focal(x, w = 3, # fun = function(i) {terra::modal(i, ties = "first", na.rm = TRUE)},
                  fun = "modal", 
                  na.rm = TRUE, na.policy = "only", expand = TRUE)

plot(r)
plot(x)
plot(x2)
plot(x1)


# two versions of a for loop:
while(is.na(global(x, fun = "min"))) {
    x <- terra::focal(x, w = 3, fun = "modal", 
                  na.rm = TRUE, na.policy = "only", expand = TRUE)
}


while(
  is.na(as.vector(unlist(global(x, fun = "mean"))))
  # minmax(is.na(x))[2,] == 1
      ) {
    x <- terra::focal(x, w = 3, fun = "modal", 
                  na.rm = TRUE, na.only = TRUE, expand = TRUE)
}

modal()

plot(x)

x <- terra::focal(r, w = 3, fun = "modal", 
                  na.rm=TRUE, na.only=TRUE, expand=TRUE)
for (i in 1:20) {
  x <- terra::focal(x, w = 3, fun = "modal", 
                  na.rm=TRUE, na.only=TRUE, expand=TRUE)
}

plot(r)
plot(x)

plot(is.na(r))
minmax(is.na(rcl_iucn))[2,] == 1
freq(rcl_iucn)
length(is.na(r))
summary(r)
tic()
is.na(as.vector(unlist(global(rcl_iucn, fun = "mean"))))
toc()

NAflag(rcl_iucn)

tic()
minmax(is.na(rcl_iucn))[2,] == 1
toc()


plot(x)


# xx <- raster::focal(x, w, modal, na.rm=TRUE, NAonly=TRUE, pad=TRUE)

plot(xx)
text(r, cex=.8)
text(raster::mask(xx, r, inverse=TRUE), col="red", cex=.8)
w <- matrix(c(0,1,0,1,0,1,0,1,0), nrow=3)

plot(rcl_iucn)
tic()
rcl_iucn_focal <- terra::focal(rcl_iucn, w = 3, fun = "modal", 
                       na.rm=TRUE, na.only=TRUE, expand=TRUE,
                       filename = paste0(p_tmp, site_df$site[site_index], "_iucn_rcl_",
                                         lc_class,"_focal.tif"),
                       overwrite=TRUE)
toc()

tic()
for (i in 1:100) {
rcl_iucn_focal <- terra::focal(
  rcl_iucn_focal, w = 3, fun = "modal", 
  na.rm=TRUE, na.only=TRUE, expand=TRUE,
  filename = paste0(p_tmp, site_df$site[site_index], "_iucn_rcl_",
                    lc_class,"_focal.tif"),
  overwrite=TRUE
)
}
toc()

plot(rcl_iucn)
plot(rcl_iucn_focal)

freq(rcl_iucn)
freq(resam3)
plot(rcl_lc)


# try with a user-defined function:
plot(rcl_iucn)
tic()
x <- terra::focal(rcl_iucn, w = 3, fun = function(i) {modal(i, ties = "first", na.rm = TRUE)},
                  na.only = TRUE, expand = TRUE)
toc()
plot(x)

tic()
x <- terra::focal(x, w = 3, fun = function(i) {modal(i, ties = "first", na.rm = TRUE)},
                  na.only = TRUE, expand = TRUE)
toc()




# mask the resampled raster, to get the updated values:
rcl_lc_mask <- subst(rcl_lc, 2, 0)

iucn_lc_focal <- resam3 + rcl_lc_mask

plot(rcl_iucn)
plot(iucn_lc_focal)
plot(rcl_lc_mask)

freq(is.na(resam3))
freq(is.na(rcl_lc_mask))
freq(is.na(iucn_lc_focal))
plot(is.na(iucn_lc_focal))
plot(is.na(rcl_lc_mask))


x <- terra::focal(r, w = 3, fun = "modal", 
                  na.rm=TRUE, na.only=TRUE, expand=TRUE)
for (i in 1:20) {
  x <- terra::focal(x, w = 3, fun = "modal", 
                  na.rm=TRUE, na.only=TRUE, expand=TRUE)
}

```

```{r focal-resample-test-s}
site_index <-1
lc_class


plot(abn_lcc[[site_index]][["y2015"]])
plot(lcc[[site_index]][["y2015"]])

#. 1.
# first, reclassify land cover map to extract just one land cover class:
tic()
lcc_sub_2 <- classify(
        lcc[[site_index]][["y2015"]],
        rcl = tibble(is = lc_class, becomes = lc_class), # simple rcl, e.g., where 2 stays 2, everything else is converted to NA
        othersNA = TRUE,
        filename = paste0(p_tmp, site_df$site[site_index], "_lcc_sub_", lc_class,".tif"),
        overwrite=TRUE
        )
toc()
plot(lcc_sub_2)

# this will be used to mask the resampled IUCN habitat map.


# 2. 
# then, reclassify the habitat map to extract only those habitat types that fall within the above land cover class:
# reclassify lc and iucn
tic()
iucn_sub_2 <- classify(
        site_jung_l2[[site_index]] %>% 
          crop(., lcc[[site_index]]), # crop first, since focal takes care of NA border cells
        rcl = iucn_crosswalk %>% filter(lc != 2) %>% select(is = map_code) %>% mutate(becomes = NA),
        # othersNA = TRUE,
        filename = paste0(p_tmp, site_df$site[site_index], "_iucn_sub_", lc_class, ".tif"),
        overwrite=TRUE
        )
toc()
plot(iucn_sub_2)


# 3.
# then, start the resampling process:
tic()
x <- terra::focal(iucn_sub_2, w = 3, 
                  fun = "modal", na.rm = TRUE, na.policy = "only", expand = TRUE
                  )
toc()
plot(x)

# it's faster without saving to file each time. 
tic()
for (i in 1:100) {
x <- terra::focal(x, w = 3,
                  fun = "modal", na.rm = TRUE, na.policy = "only", expand = TRUE
)
}
toc()
plot(x)
plot(is.na(x))

# two versions of a for loop:
tic()
while(is.na(global(x, fun = "min"))) {
    x <- terra::focal(x, w = 3, fun = "modal", 
                  na.rm = TRUE, na.policy = "only", expand = TRUE)
}
toc()



# save to file


# mask to my land cover

plot(rcl_iucn)
tic()
rcl_iucn_focal <- terra::focal(rcl_iucn, w = 3, fun = "modal", 
                       na.rm=TRUE, na.only=TRUE, expand=TRUE,
                       filename = paste0(p_tmp, site_df$site[site_index], "_iucn_rcl_",
                                         lc_class,"_focal.tif"),
                       overwrite=TRUE)
toc()

tic()
for (i in 1:100) {
rcl_iucn_focal <- terra::focal(
  rcl_iucn_focal, w = 3, fun = "modal", 
  na.rm=TRUE, na.only=TRUE, expand=TRUE,
  filename = paste0(p_tmp, site_df$site[site_index], "_iucn_rcl_",
                    lc_class,"_focal.tif"),
  overwrite=TRUE
)
}
toc()
```

```{r compare-ratios}


```


```{r dist-direction-resample}
# https://stackoverflow.com/questions/27562076/if-raster-value-na-search-and-extract-the-nearest-non-na-pixel/
  
set.seed(2)
# set projected CRS
r <- rast(ncol=10, nrow=10, 
          # xmn=0, xmx=10, ymn=0,ymx=10,
          xmin=0, xmax=10, ymin=0,ymax=10,
          crs='+proj=longlat +datum=WGS84') 
r[] <- 1:10
r[sample(1:ncell(r), size = 50)] <- NA
plot(r)
text(r)

# create sample points
xy <- data.frame(x=runif(10,1,10), y=runif(10,1,10))

# use normal extract function to show that NAs are extracted for some points
# extracted <- raster::extract(x = r, y = xy)
extracted <- terra::extract(x = r, y = xy)

plot(extracted)

# Calculate the distance and direction from all NA pixels to the nearest non-NA pixel:

# dist <- raster::distance(r)
dist <- terra::distance(r) # distance in meters

plot(dist)
text(dist)
names(dist) <- "dist"

# you can also set a maximum distance: dist[dist > maxdist] <- NA
direct <- terra::direction(r, from=FALSE, degrees = TRUE)
# this is the number of degrees, moving right, from true north. 
# so, 90 is right, 180 is below, 270 (-90) is left, and 0 is above. 

# radians are measured from the rightmost point. So 
minmax(direct)

plot(direct, type = "classes")
text(direct)
plot(r)
text(r)

names(direct) <- "direct"


# Retrieve coordinates of NA pixels

# NA raster
rna <- is.na(r) # returns NA raster
plot(rna)
names(rna) <- "is.na"

plot(c(r, dist, direct, rna), type = "classes")



tdr <- as.data.table.raster(
  brick(r, dist, direct, rna)
  )

tdt <- spatraster_to_dt(
  c(r, dist, direct, rna)
  )

head(tdt)



# store coordinates in new raster: https://stackoverflow.com/a/35592230/3752258 
plot(rna)
na.x <- init(rna, 'x')
na.y <- init(rna, 'y')

plot(na.x)
plot(na.y)
values(na.x)

# calculate coordinates of the nearest Non-NA pixel
# assume that we have a orthogonal, projected CRS, so we can use (Pythagorean) calculations
co.x <- na.x + dist * sin(direct)
co.y <- na.y + dist * cos(direct)

plot(sin(direct))
plot(dist)

plot(co.x)
plot(co.y)
values(co.x)

tdt[, ':='(co.x = x + dist * sin(direct),
           co.y = y + dist * cos(direct))]

tdt[, ]

# matrix with point coordinates of nearest non-NA pixel
co <- cbind(co.x[], co.y[])
co

# Extract values of nearest non-NA cell with coordinates 'co'

# extract values of nearest non-NA cell with coordinates co
NAVals <- terra::extract(r, co, method='simple') 
NAVals <- raster::extract(r, co, method='simple') 
plot(r)
plot(NAVals)

r.NAVals <- rna # initiate new raster
r.NAVals[] <- NAVals # store values in raster
plot(r.NAVals)
plot(r)

# Fill the original raster with the new values
# cover nearest non-NA value at NA locations of original raster
plot(r)
r.filled <- cover(x=r, y= r.NAVals)
plot(r.filled)

sampled <- raster::extract(x = r.filled, y = xy)

# compare old and new values
print(data.frame(xy, extracted, sampled))

```

```{r try-for-s}
# this really crashed - too computationally intensive for raster.
# Unfortunately, there is no "direction()" function for {terra}

# Calculate the distance and direction from all NA pixels to the nearest non-NA pixel:
r
rcl_iucn
plot(rcl_iucn)
tic()
dist <- raster::distance(rcl_iucn)
toc()
# dist_t <- terra::distance(r)

plot(dist)
names(dist) <- "dist"

# you can also set a maximum distance: dist[dist > maxdist] <- NA
direct <- direction(r, from=FALSE, degrees = FALSE)
plot(direct)
names(direct) <- "direct"


# Retrieve coordinates of NA pixels

# NA raster
rna <- is.na(r) # returns NA raster
plot(rna)
names(rna) <- "is.na"




# store coordinates in new raster: https://stackoverflow.com/a/35592230/3752258 
na.x <- init(rna, 'x')
na.y <- init(rna, 'y')

plot(na.x)
plot(na.y)
values(na.x)

# calculate coordinates of the nearest Non-NA pixel
# assume that we have a orthogonal, projected CRS, so we can use (Pythagorean) calculations
co.x <- na.x + dist * sin(direct)
co.y <- na.y + dist * cos(direct)

plot(co.x)
plot(co.y)

# matrix with point coordinates of nearest non-NA pixel
co <- cbind(co.x[], co.y[])
co

# extract values of nearest non-NA cell with coordinates co
NAVals <- raster::extract(r, co, method='simple') 
plot(NAVals)

r.NAVals <- rna # initiate new raster
r.NAVals[] <- NAVals # store values in raster
plot(r.NAVals)
plot(r)

# Fill the original raster with the new values
# cover nearest non-NA value at NA locations of original raster
plot(r)
r.filled <- cover(x=r, y= r.NAVals)
plot(r.filled)







# ---------------------------------- trying for a cropped corner of the iucn map ------ #

crop_ext <- draw()

rcl_iucn_100_crop <- crop(rcl_iucn_100, crop_ext)
plot(rcl_iucn_100_crop)

# distance:
tic()
dist1 <- terra::distance(rcl_iucn_100_crop)
toc() # about 6 minutes. For just 2 million cells. The biggest rasters have more than 50 times as many cells. So it might take something like 5 hours per raster. Yikes!
names(dist1) <- "dist"

rcl_iucn_100_crop_r <- raster(rcl_iucn_100_crop)
plot(rcl_iucn_100_crop_r)

tic()
direct1 <- direction(rcl_iucn_100_crop_r, from=FALSE, degrees = FALSE)
toc() # 2626 seconds. 44 minutes about. 
names(direct1) <- "direct"

plot(dist1)
plot(direct1)

direct1_t <- rast(direct1)
plot(direct1_t)


# Retrieve coordinates of NA pixels
# NA raster
rna <- is.na(rcl_iucn_100_crop) # returns NA raster
plot(rna)
names(rna) <- "is.na"

# store coordinates in new raster: https://stackoverflow.com/a/35592230/3752258 
na.x <- init(rna, 'x')
na.y <- init(rna, 'y')

plot(na.x)
plot(na.y)

# calculate coordinates of the nearest Non-NA pixel
# assume that we have a orthogonal, projected CRS, so we can use (Pythagorean) calculations
co.x <- na.x + dist1 * sin(direct1_t)
co.y <- na.y + dist1 * cos(direct1_t)

plot(co.x)
plot(co.y)
co

# matrix with point coordinates of nearest non-NA pixel
co <- cbind(co.x[], co.y[])
co
head(co)
names(co) <- c("x", "y")

# extract values of nearest non-NA cell with coordinates co
NAVals <- raster::extract(rcl_iucn_100_crop_r, co, method='simple') 
plot(NAVals)
head(NAVals)
NAVals %>% 
  filter(!is.na(iucn_habitatclassification_composite_lvl2_ver004))

!is.na(NAVals) %>% sum()

r.NAVals <- rna # initiate new raster
plot(rna)
plot(r.NAVals)
values(r.NAVals) <- NAVals[,1] # store values in raster
plot(r.NAVals)
plot(r)

# Fill the original raster with the new values
# cover nearest non-NA value at NA locations of original raster
plot(r)
r.filled <- cover(x=r, y= r.NAVals)
plot(r.filled)

```



```{r calculate-overlap}
crosswalk_jac <- lapply(1:11, 
                        function(site) {
  tmp_t <- terra::rast(
    list(
      lc[[site]]$y2015, # land cover in 2015
      site_jung_l2_30_rcl[[site]] # IUCN habitat types, reclassified
    )
    )

  # convert to data.table
  tmp_dt <- spatraster_to_dt(tmp_t, xy_switch = FALSE)
  
  # calculate Jaccard similarity
  jac_df <- lapply(c("lc", "lc2", "lc3", "lc4"), function(rcl_version){
    tibble(site = site_df$site[site],
           lc = 1:4,
           ver = rcl_version) %>%
      mutate(jaccard = sapply(lc, #1:4, 
                              function(lc_code) {
        int <- tmp_dt[y2015 == lc_code & get(rcl_version) == lc_code, .N] # intersection
        a <- tmp_dt[y2015 == lc_code, .N] 
        b <- tmp_dt[get(rcl_version) == lc_code, .N]
        int / (a + b - int) # int / union
        }))
    
    }
    ) %>% bind_rows()

  jac_df
  }) %>% 
  bind_rows()
```

```{r calculate-overlap-1km}
# 
1000^2
1000/30 # 33.33

plot(lcc$shaanxi$y2017)
agg_t <- terra::aggregate(lcc$shaanxi$y2017, fact = 37.7, fun = "median")

res(agg_t)[1] * 110 * 1000 # 110 km per degree, and 1000 m per km 
plot(agg_t)

978 ^ 2
1000 ^ 2

og_size <- terra::cellSize(lcc$shaanxi$y2017, unit = "m")
agg_size <- terra::cellSize(agg_t, unit = "m")

agg_size
plot(agg_size)
plot(og_size)

sqrt(768320/705)
sqrt(1000000/700)


```

# Basic plots
## Plot Yin et al. 2020 land cover:
```{r plot-lc}
inset_map_titles <- paste0("(", gsub("_", "", site_df$label), ") ", site_df$description)
# cat(inset_map_titles, sep = "; ")
new_titles <- inset_map_titles
new_titles[1] <- "(b) Vitebsk, Belarus /\nSmolensk, Russia"
new_titles[8] <- "(o) Orenburg, Russia /\nUralsk, Kazakhstan"

fancy_labels

year_index <- 1

lapply(c(1, 6, 11, 16, 21, 26, 31),
       function(year_index) {
  
  pdf(file = paste0(p_plots, "land_cover_", 1986 + year_index, ".pdf"), width = 7, height = 6)
  mval <- 1.5
  par(mfrow = c(3, 4), 
        # mar=c(0,0,0,0), 
        oma=c(1,1,0,0),
        adj = 0,
        cex.main = 1#,
        # tcl = -0.2
        )
  
  # if you use maxcell, the 0s start showing up, which messes up the color scale... beware!
  for(i in 1:11) {
    terra::plot(lcc[[i]][[year_index]],
                # site_jung_l2[[i]], # for testing
                col = lc_plot_cols$color, levels = lc_plot_cols$name, 
                colNA = "gray95",
                mar = c(mval - 1, mval - 0.9, mval + 1.25, mval - 0.9), # bltr     
                legend = FALSE, #maxcell = 5000000,
                cex = 1, # controls title sizes
                type = "classes", main = new_titles[i]#"Land cover, 2015",
       )
  }
  
  
  # pdf(file = paste0(p_output, "plots/jung_sites_colors_legend.pdf"), width = 7.5, height = 7.5)
  plot.new()
  plot(lcc[[i]]$y2017, type = "classes",
       col = lc_plot_cols$color, levels = lc_plot_cols$name,
       legend = "left",
       plg = list(cex = 1.5,
                  title = paste0("Land cover, ", 1986 + year_index),
                                  # text.width = 100,
                  title.adj = 0#,
                  # y.intersp	= 1.1
                  # xjust = 0.5
                  ),
       legend.only = TRUE)
  
  dev.off()
})


# turn into a gif:
gif_files <-
  list.files(paste0(p_plots), full.names = TRUE) %>% 
    grep("land_cover_[0-9]{4}.pdf", ., value = TRUE)
  
gif <- image_animate(image_read(gif_files), fps = 2)
image_write(gif, paste0(p_plots, "lc_gif.pdf"))
```

```{r lc-legend}
pdf(file = paste0(p_output, "plots/lc_legend2.pdf"), width = 6, height = 3.5)
plot.new()
plot(lcc[[i]]$y2017, type = "classes",
     col = lc_plot_cols$color, 
     # levels = lc_plot_cols$name,
     levels = c("1 Non veg.", "2 Woody veg. (Forest)", "3 Cropland", "4 Herbaceous veg. (Grassland)"),
     legend = "left",
     plg = list(cex = 1.8,
                title = "Land cover classes",
                                # text.width = 100,
                title.adj = 0#,
                # y.intersp	= 1.1
                # xjust = 0.5
                ),
     legend.only = TRUE)

dev.off()
```

```{r lc-abn}

plot(abn_lcc[[9]][[31]])
plot(max_abn_lcc[[9]][[1]])

year_index <- 31
i <- 9


coltab(max_abn_lcc[[9]])
# must give colors for values 0, 1, 2, 3, 4, etc.
coltab(max_abn_lcc[[9]], layer = 31) <- lc_plot_cols$color[c(1, 1, 2, 3, 4)]
plot(max_abn_lcc[[9]][[31]])

# what colors do I need for the levels?
max_abn_lcc_freq %>% 
  # filter(year == 1987) %>% 
  group_by(site, year) %>% 
  summarise(n = n(), lc = str_c(unique(lc), collapse = ", ")) %>% 
  # filter(n != 3) %>%
  ungroup() %>% 
  select(lc) %>% unique()

# plot --------------------------------------------------- #
lapply(
  c(1),
  # c(1, 6, 11, 16, 21, 26, 31),
       function(year_index) {
  
  pdf(file = paste0(p_plots, "abn_land_cover_", 1986 + year_index, ".pdf"), width = 7, height = 6)
  mval <- 1.5
  par(mfrow = c(3, 4), 
        # mar=c(0,0,0,0), 
        oma=c(1,1,0,0),
        adj = 0,
        cex.main = 1#,
        # tcl = -0.2
        )
  
  # if you use maxcell, the 0s start showing up, which messes up the color scale... beware!
  for(i in 1:11) {
    terra::plot(max_abn_lcc[[i]][[year_index]],
                # site_jung_l2[[i]], # for testing
                col = c("dark green", lc_plot_cols$color[3:4]),
                levels = lc_plot_cols$name[2:4],
                # breaks = c(0, 1, 2, 3, 4),
                colNA = "gray95",
                # mar = c(mval - 1, mval - 0.9, mval + 1.25, mval - 0.9), # bltr, for ppt
                mar = c(1.5, 1, 2.2, 1), # bltr, for ms     

                legend = FALSE,
                #maxcell = 5000000,
                cex = 1, # controls title sizes
                type = "classes", main = new_titles[i]#"Land cover, 2015",
       )
  }
  
  
  # pdf(file = paste0(p_output, "plots/jung_sites_colors_legend.pdf"), width = 7.5, height = 7.5)
  plot.new()
  plot(max_abn_lcc[[i]]$y2017, type = "classes",
       col = c("dark green", lc_plot_cols$color[3:4]),
       levels = c("Forest", "Cropland", "Grassland"), #lc_plot_cols$name[2:4],
       legend = "left",
       plg = list(cex = 1.5,
                  title = paste0("Land cover, ", 1986 + year_index),
                                  # text.width = 100,
                  title.adj = 0#,
                  # y.intersp	= 1.1
                  # xjust = 0.5
                  ),
       legend.only = TRUE)
  
  dev.off()
})
```


## Plot sites with abandonment, lc, PNV, and habitat types

```{r plot-4x4}
site_pnv_lc

# four by four matrix with"
# 1. LC in 2015
# 2. Abandonment age in 2017
# 3. PNV land cover
# 4. IUCN Habitat types
i <- 9
for (i in 9) {
pdf(file = paste0(p_output, "plots/site_4x4_", site_df$site[i],"_l2_el.pdf"), width = 7.5, height = 7.5)
  
mval <- 1.5
par(mfrow = c(2, 2), 
      # mar=c(0,0,0,0), 
      oma=c(1,1,0,0),
      adj = 0,
      cex.main = 1#,
      # tcl = -0.2
      )


plot(lc[[i]]$y2017, col = lc_plot_cols$color, levels = lc_plot_cols$name, 
     mar = c(mval+0.5, mval, mval + 1.2, mval + 4), # bltr     
     type = "classes", main = "Land cover, 2017")

plot(age_t_bins[[i]]$y2017, colNA = "gray95", main = "Abandonment age (years), 2017",
     mar = c(mval+0.5, mval, mval + 1.2, mval + 3), # bltr     
     type = "classes", 
     levels = c("5-10", "11-15", "16-20", "21-25", "26-30"))


# # PNV
# plot(site_pnv_lc[[i]], maxcell = 5000000,
#        main = paste0("PNV Land Cover, ", names(site_pnv_lc[i])),
#        mar = c(mval+0.5, mval, mval + 1.2, mval + 4), # bltr     
#        type = "classes", #legend = FALSE,
#        # col = filter(arrange(copernicus_table, map_code),
#        #              map_code %in% filter(site_pnv_lc_freq,
#        #                                   site == site_df$site[i])$map_code
#        #              )$cols
#      levels = filter(arrange(copernicus_table, map_code), 
#                   map_code %in% filter(site_pnv_lc_freq, 
#                                        site == site_df$site[i])$map_code)$Name %>%
#        str_wrap(., width = 14),
#      col = filter(arrange(copernicus_table, map_code), 
#                   map_code %in% filter(site_pnv_lc_freq, 
#                                        site == site_df$site[i])$map_code)$cols,
#      plg = list(y.intersp = 1.5)
# )

# Elevation

# plot(elevation_map[[i]], main = "Elevation (m)")

# Level 2:
# i <- 3
plot(site_jung_l2_30[[i]], maxcell = 5000000,
       main = paste0("IUCN Habitat Types, Level 2: ", names(site_jung_l2_30[i])),
       mar = c(mval+0.5, mval, mval + 1.2, mval + 2), # bltr
       type = "classes", #legend = FALSE,
       col = jung_table %>%
       arrange(map_code) %>%
       filter(map_code %in% filter(site_jung_l2_30_freq,
                                site == site_df$site[i])$map_code
           ) %>% .$cols,
       levels = jung_table %>%
    arrange(map_code) %>%
    filter(map_code %in% filter(site_jung_l2_30_freq,
                                site == site_df$site[i])$map_code
           ) %>% .$map_code
    )


# Level 1:
# site_jung_l1_30
# jung_l1_table_clr
# plot(site_jung_l1_30[[i]], maxcell = 5000000,
#        main = paste0("IUCN Habitat Types, Level 1: ", names(site_jung_l1_30[i])),
#        mar = c(mval+0.5, mval, mval + 1.2, mval + 4), # bltr     
#        type = "classes", #legend = FALSE,
#        col = jung_l1_table_clr %>% 
#        arrange(map_code) %>% 
#        filter(map_code %in% filter(site_jung_l1_30_freq,
#                                 site == site_df$site[i])$map_code
#            ) %>% .$cols,
#        levels = jung_l1_table_clr %>%
#     arrange(map_code) %>%
#     filter(map_code %in% filter(site_jung_l1_30_freq,
#                                 site == site_df$site[i])$map_code
#            ) %>% .$Name
#     )

dev.off()
}
```

```{r explore-savanna}
i <- 3

plot(lc[[i]]$y2017, col = lc_plot_cols$color, levels = lc_plot_cols$name, 
     mar = c(mval+0.5, mval, mval + 1.2, mval + 4), # bltr     
     type = "classes", main = "Land cover, 2017")

# chongqing:
plot(lc[[i]]$y2015, 
     breaks = c(3.9, 4.1),
     main = "CQ: Grassland (4)") # just grassland 

site_jung_l2_freq %>% filter(site == site_df$site[i])
plot(site_jung_l2[[i]],
     breaks = c(201, 307), # savanna
     # breaks = c(301, 307) # shrubs
     main = "CQ: IUCN savanna & shrubs"
     )

plot(lc[[i]]$y2015, breaks = c(1.9, 2.1), main = "CQ: forest")

plot(site_jung_l2[[i]], breaks = c(103,110))
plot(site_jung_l2[[i]], breaks = c(1402.9, 1403), add = T)


plot(site_jung_l2[[i]], breaks = c(1401, 1402), main = "Arable")
plot(lc[[i]]$y2015, breaks = c(2.9, 3.1), main = "CQ: Cropland (3)")


plot(age_t_bins[[i]]$y2017, #colNA = "gray95", 
     main = "Abandonment age (years), 2017",
     mar = c(mval+0.5, mval, mval + 1.2, mval + 3), # bltr     
     type = "classes", 
     levels = c("5-10", "11-15", "16-20", "21-25", "26-30"),
     col = "pink", add = T)


# iraq

site_jung_l2_freq %>% filter(site == site_df$site[5])


# -------------------------------------------------- #
# Cerrado
# -------------------------------------------------- #

pnv_lc

ecoregions_simple %>% 
  # st_drop_geometry() %>%
  select(ECO_NAME, biome) %>%
  # .$ECO_NAME %>%
  filter(ECO_NAME == "Cerrado") %>% st_geometry() %>% plot(border = "red", add = T)

plot(site_sf %>% filter(site %in% site_df$site[c(4,6)]) %>% st_geometry,
     add = T)

plot(pnv_lc, ext = ext(filter(ecoregions_simple, ECO_NAME == "Cerrado")),
     type = "classes", maxcell = 100000000)


     
plot(forest_c, col = brewer_pal(palette = "Greens")(9), colNA = "gray80", add = T,
     ext = ext(filter(ecoregions_simple, ECO_NAME == "Cerrado")))
plot(st_geometry(filter(ecoregions_simple, ECO_NAME == "Cerrado")),
     add = T)

plot(site_sf$geometry, border = "black", add = T)


```


## Other Landcover

```{r nlcd}
install.packages("terra")
library(terra)
library(tictoc)

# update filenames to match yours:
nlcd <- rast(paste0(p_dat, "LU/nlcd_2019_land_cover_l48_20210604/nlcd_2019_land_cover_l48_20210604.img"))
plot(nlcd)
# freq(nlcd) # I used this to produce a table of the classes, but warning... it took a long time.
nlcd_classes <- read_csv("/Users/christophercrawford/Downloads/nlcd_freq.csv")

terraOptions()
terraOptions(tempdir = paste0(p_dat, "LU/nlcd_temp"), todisk = TRUE, progress=10)

tic()
nlcd <- 
  classify(nlcd,
           rcl = tibble("is" = nlcd_classes$value, 
                        becomes = if_else(is == 81, 1, NA_real_)), # note, it takes way longer to change values to 0 than to NA_real_
           filename = paste0(p_dat, "LU/nlcd_2019_pasture_mask.tif"),
           overwrite = TRUE)
toc() # 605 seconds


# load sf polygons ------------- #
install.packages("rnaturalearth")
library(rnaturalearth)

usa <- rnaturalearth::ne_states(country = "United States of America", returnclass = "sf")
conus <- usa %>% filter(!name %in% c("Alaska", "Hawaii"))
plot(conus$geometry)
conus_aea <- st_transform(conus, crs(nlcd)) # reproject to aea


# plot the pasture mask
pdf(file = paste0(p_dat, "LU/nlcd_pasture_mask.pdf"), width = 7, height = 4)
plot(nlcd, main = "NLCD Pasture Mask")
plot(conus_aea$geometry, add = T, border = "gray70")
dev.off()

# crop pnv to conus
pnv_250 <- rast(paste0(p_dat, "/Habitats/PNV/Hengl2019/250m/pnv_biome.type_biome00k_c_250m_s0..0cm_2000..2017_v0.2.tif"))
pnv_conus <- crop(pnv_250, conus)

# reproject pnv to aea
pnv_conus_aea <- terra::project(x = pnv_conus, 
                         y = "+proj=aea +lat_0=23 +lon_0=-96 +lat_1=29.5 +lat_2=45.5 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs",
                         filename = paste0(p_dat, "Habitats/PNV/pnv_conus_aea.tif"))

plot(pnv_conus_aea) # it worked!
plot(conus_aea$geometry, add = T)


# extract only forested or reforestable areas:
pnv_classes <- read_csv("/Users/christophercrawford/Downloads/pnv_classes.csv")

filter(pnv_classes, reforestable == "yes")$Number # reforestable classes
filter(pnv_classes, reforestable == "yes")$Number
pnv_classes

# you can then reclassify to get a mask that's just those "reforestable" areas, with something like:
tic()
pnv_reforestable_mask <- 
  classify(pnv_conus_aea,
           # note, it takes way longer to change values to 0 than to NA_real_
           rcl = tibble("is" = 1:32, 
                        becomes = if_else(is %in% filter(pnv_classes, reforestable == "yes")$Number, 1, NA_real_)),
           othersNA = TRUE,
           filename = paste0(p_dat, "LU/pnv_reforestable_mask.tif"),
           overwrite = TRUE)
toc()  # 23 seconds

# plot the pasture mask
# pdf()
pdf(file = paste0(p_dat, "LU/pnv_reforestable_mask.pdf"), width = 7, height = 4)
# plot(pnv_conus_aea)
plot(pnv_reforestable_mask, main = "PNV Reforestable Areas Mask")
plot(conus_aea$geometry, add = T, border = "gray70")
dev.off()


print(gg_time_to_range_all_l3)
dev.off()

# then you can go about getting the resolution to match, etc.

# just doing it with a smaller subset:

nj <- usa %>% filter(name == "New Jersey")
mi <- usa %>% filter(name == "Michigan")

# to crop the nlcd to nj, first reproject the nj sf object to aea
nj_aea <- st_transform(nj, crs(nlcd))
plot(nj_aea$geometry)
plot(nj$geometry)

# make sure 
pnv_nj <- crop(pnv_250, nj)
tic()
nlcd_nj <- crop(nlcd, nj_aea)
toc() # 1 second
plot(nlcd_nj)
plot(pnv_nj)

nlcd_nj_pasture <- 
  classify(nlcd_nj,
           # takes way longer to change values to 0 than to NA_real_
           rcl = tibble("is" = nlcd_values, becomes = if_else(is == 81, 1, NA_real_)), 
           filename = paste0(p_dat, "LU/nlcd_nj_2019_pasture_mask.tif"),
           overwrite = TRUE)
plot(nlcd_nj_pasture)
plot(nj_aea$geometry, add = T)

rasterOptions(todisk = TRUE)


pnv_nj_aea <- project(x = pnv_nj, y = nlcd_nj, filename = paste0(p_dat, "Habitats/PNV/pnv_nj_aea.tif"))

# it worked!
plot(nlcd_nj)
plot(pnv_nj_aea, add = T)
plot(nj_aea$geometry, add = T)
```




# Ecoregions (TNC/WWF)

```{r biomes}
# use this version to match to PREDICTS
tic()
ecoregions <- st_read(paste0(p_dat, "Habitats/terr-ecoregions-TNC/tnc_terr_ecoregions.shp")) %>%
  st_make_valid()
toc() # 20 seconds about. (making the geometries valid is quick!)


# rename the column for WWF_MHTNAM to biome (this matches PREDICTS)
ecoregions <- ecoregions %>% mutate(biome = WWF_MHTNAM)
ecoregions %>% st_drop_geometry() %>% select(biome) %>% unlist(use.names = FALSE) %>% unique()

# union ecoregions within each biome
biome_names <- ecoregions %>% st_drop_geometry() %>% select(biome) %>% unlist(use.names = FALSE) %>% unique()
biome_l <- vector(mode = "list", length = 16L)
names(biome_l) <- biome_names

tic()
for(i in 1:16) {
  biome_l[[i]] <- ecoregions %>% 
    filter(biome == biome_names[i]) %>%
    st_union() %>%
    st_sf() %>%
    mutate(biome = biome_names[i])
}
toc() # took a bit of a while - maybe 60 seconds.

biomes <- bind_rows(biome_l)

# I tried aggregate, st_union, st_combine, merge, etc., and I couldn't find a simple way to dissolve an sf object based on an attribute, other than doing them all individually, then binding them back together. 


# save biomes sf file
st_write(biomes, dsn = paste0(p_dat, "Habitats/biomes.shp"))
save(biomes, file = paste0(p_dat, "Habitats/biomes.rds"))

biomes <- st_read(paste0(p_dat, "Habitats/biomes.shp"))

plot(st_geometry(biomes[4,]))


# Crop ecoregions to the sites:

site_ecoregions <- lapply(1:11, function(i) {
  temp <- st_crop(ecoregions, terra::ext(lc[[i]]))
  temp <- temp %>% mutate(site = site_df$site[i])
  temp
}) %>% bind_rows()

obj_size(site_ecoregions)
st_write(site_ecoregions, dsn = paste0(p_derived, "site_ecoregions.shp"))

site_ecoregions <- st_read(paste0(p_derived, "site_ecoregions.shp"))

```

```{r ecoregions-2017}
tic()
ecoregions2017 <- st_read(paste0(p_dat, "Habitats/Ecoregions2017/Ecoregions2017.shp")) %>%
  st_make_valid()
toc() # 20 seconds about. (making the geometries valid is quick!)


# rename the column for WWF_MHTNAM to biome (this matches PREDICTS)
ecoregions <- ecoregions %>% mutate(biome = WWF_MHTNAM)
ecoregions %>% st_drop_geometry() %>% select(biome) %>% unlist(use.names = FALSE) %>% unique()



# simplify polygons:
ecoregions2017_simple <- st_simplify(ecoregions2017, dTolerance = 10000, preserveTopology = TRUE)
obj_size(ecoregions2017_simple)

# plot with Cook-Patton
plot(cook_patton_abg, col = brewer_pal(palette = "Greens")(9), colNA = "gray80")

# add just savannas in red:
ecoregions2017_simple %>% 
  select(ECO_NAME, BIOME_NAME) %>%
  filter(BIOME_NAME %in% grep("Savanna",
                         ecoregions2017_simple$BIOME_NAME,
                         value = TRUE, invert = FALSE)
         ) %>%
  st_geometry() %>% plot(border = "red", add = TRUE)

site_sf$geometry %>% plot(border = "orange", add= TRUE)


# crop to sites:
site_ecoregions2017 <- lapply(1:11, function(i) {
  temp <- st_crop(ecoregions2017, terra::ext(lc[[i]]))
  temp <- temp %>% mutate(site = site_df$site[i])
  temp
}) %>% bind_rows()

warnings()

plot(site_ecoregions2017$geometry)
obj_size(site_ecoregions2017)
site_ecoregions2017 %>% st_drop_geometry()
names(site_ecoregions2017)

site_ecoregions2017$ECO_NAME %>% unique()
site_ecoregions2017$BIOME_NAME %>% unique()



st_write(site_ecoregions2017, dsn = paste0(p_derived, "site_ecoregions2017.shp"))
site_ecoregions2017 <- st_read(paste0(p_derived, "site_ecoregions2017.shp"))

st_write(ecoregions2017_simple, dsn = paste0(p_derived, "ecoregions2017_simple.shp"))
ecoregions2017_simple <- st_read(paste0(p_derived, "ecoregions2017_simple.shp"))
```


```{r plot-ecoregions}

site_ecoregions %>% st_drop_geometry() %>%
  select(ECO_NAME, biome, site) %>%
  as_tibble() %>% print(n = 30)

site_ecoregions2017 %>% names()

site_ecoregions2017 %>% st_drop_geometry() %>%
  select(ECO_NAME, BIOME_NAME, site) %>%
  as_tibble() %>% print(n = 30)


# plot ecoregions by site:
  
i
gg_ecoregions_all <-
  ggplot(data = site_ecoregions %>%
           filter(site == site_df$site[i]), 
         aes(fill = str_wrap(ECO_NAME, 15))) +
  theme_classic() + 
  geom_sf() + 
  labs(fill = "Ecoregion") +
  theme(legend.position = "right"#,
        # legend.text = element_text(size = 7)
        ) #+ 
  # guides(fill = guide_legend(ncol = 2)) +
  # scale_fill_manual(values = biome_pal, labels = str_wrap(names(biome_pal), 24)
                    # ) + 
  # facet_wrap(vars(site), labeller = as_labeller(cap_update_labels))

gg_ecoregions_all_2017 <-
  ggplot(data = site_ecoregions2017 %>%
           filter(site == site_df$site[i]), 
         aes(fill = str_wrap(ECO_NAME, 15))) +
  theme_classic() + 
  geom_sf() + 
  labs(fill = "Ecoregion") +
  theme(legend.position = "right")
  
ecoregions_by_site <-
  lapply(1:11, function(i){
    ggplot(data = site_ecoregions %>% 
             filter(site == site_df$site[i]), 
           aes(fill = str_wrap(ECO_NAME, 15))) +
      theme_classic() + 
      geom_sf() + 
      labs(fill = NULL) +
      theme(legend.position = "right",
            axis.text.x = element_text(angle = 320, vjust = 1, hjust = 0)) + 
      guides(fill = guide_legend(ncol = 1)) + 
      # scale_fill_manual(labels = str_wrap(names(biome_pal), 24)) +
      # scale_fill_manual(values = biome_pal) + 
      facet_wrap(vars(site), labeller = as_labeller(cap_update_labels))
  })

gg_ecoregions_by_site_2017 <-
  lapply(1:11, function(i){
    ggplot(data = site_ecoregions2017 %>% 
             filter(site == site_df$site[i]), 
           aes(fill = str_wrap(ECO_NAME, 15))) +
      theme_classic() + 
      geom_sf() + 
      labs(fill = NULL) +
      theme(legend.position = "right",
            axis.text.x = element_text(angle = 320, vjust = 1, hjust = 0)) + 
      guides(fill = guide_legend(ncol = 1)) + 
      # scale_fill_manual(labels = str_wrap(names(biome_pal), 24)) +
      # scale_fill_manual(values = biome_pal) + 
      facet_wrap(vars(site), labeller = as_labeller(cap_update_labels))
  })


ggsave(plot = 
         # plot_grid(
           plot_grid(
             plotlist = ecoregions_by_site, 
             ncol = 4, nrow = 3),
           # as_ggplot(biome_legend),
           # nrow = 2, rel_heights = c(2, 0.2)),
       filename = paste0(p_plots, "ecoregions_by_site_wide.pdf"), 
    width = 15, height = 9, units = "in"
)

ggsave(plot = 
         # plot_grid(
           plot_grid(
             plotlist = gg_ecoregions_by_site_2017, 
             ncol = 4, nrow = 3),
           # as_ggplot(biome_legend),
           # nrow = 2, rel_heights = c(2, 0.2)),
       filename = paste0(p_plots, "ecoregions2017_by_site_wide.pdf"), 
    width = 15, height = 9, units = "in"
)


```

```{r savanna-ecoregion}

ecoregions$ECO_NAME %>% grep("Ordos", ., value = TRUE)

site_ecoregions %>% 
  st_drop_geometry() %>%
  select(site, ECO_NAME)

ecoregions %>% 
  filter(ECO_NAME == "Ordos Plateau Steppe") %>%
  st_geometry() %>%
  plot()


plot(ext(lc$shaanxi$y2017) + 2)
plot(ext(lc$shaanxi$y2017), add = T, border = "green")
ecoregions %>% 
  # filter(ECO_NAME == "Ordos Plateau Steppe") %>%
  st_geometry() %>%
  plot(add = T, col = "gray")

crop1 <- st_crop(ecoregions, terra::ext(lc[[9]]) + 3)
crop1 %>% st_drop_geometry()
plot(crop1["biome"], leg = "bottom")
plot(crop1$geometry)

plot(ext(lc$shaanxi$y2017), add = T, border = "green")

# ------------------------------------------------ #
# simplify ecoregions sf file so that plotting at a global scale is manageable
# ------------------------------------------------ #

ecoregions_simple <- st_simplify(ecoregions, dTolerance = 10000, preserveTopology = TRUE)
obj_size(ecoregions_simple)
biomes_simple <- st_simplify(biomes, dTolerance = 10000, preserveTopology = TRUE)
obj_size(biomes_simple)

ecoregions_simple %>% 
  st_drop_geometry() %>% select(biome) %>% unique() %>% nrow()

# ------------------------------------------------ #
# filter and plot
# ------------------------------------------------ #
plot(forest_c, col = brewer_pal(palette = "Greens")(9), colNA = "gray80")

ecoregions_simple %>% 
  select(ECO_NAME, biome) %>%
  filter(ECO_NAME %in% 
           grep("Forest|Desert|Woodlands|Mountain|Range|Tundra|Mangroves|Lake|Ice", 
                ecoregions_simple$ECO_NAME, 
                value = TRUE, invert = TRUE)) %>%
  st_geometry() %>% plot(add = T)





# subset region:
my_ext <- terra::draw()

plot(forest_c, col = brewer_pal(palette = "Greens")(9), colNA = "gray80",
     ext = my_ext + 1.5)

ecoregions_simple %>% select(ECO_NAME) %>% plot(add = TRUE)
plot(usa$geometry, add = TRUE)



# ------------------------------------------------ #
# simplest filtering: just "savanna" biome
# ------------------------------------------------ #

# add just savannas in red:
ecoregions_simple %>% 
  select(ECO_NAME, biome) %>%
  filter(biome %in% grep("Savanna",
                         ecoregions_simple$biome,
                         value = TRUE, invert = FALSE)
         ) %>%
  st_geometry() %>% plot(border = "red", add = TRUE)

# Complex filtering
ecoregions_simple %>% 
  # st_drop_geometry() %>% 
  select(ECO_NAME, biome) %>%
  # .$ECO_NAME %>%
  filter(ECO_NAME %in%
           grep("Forest|Desert|Mountain|Range|Tundra|Mangroves|Lake|Ice", 
                ecoregions_simple$ECO_NAME, 
                value = TRUE, invert = TRUE),
         biome %in%
           grep("Forest|Tundra|Desert",
                ecoregions_simple$biome,
                value = TRUE, invert = TRUE)) %>%
  st_geometry() %>% plot(border = "red", add = TRUE)
  plot(extent = my_ext)

plot(usa$geometry, graticule = TRUE, axes = TRUE, add = T, border = "red")



ecoregions_simple %>% 
  filter(ECO_NAME == "Ordos Plateau Steppe") %>%
  st_geometry() %>% plot()
  # plot(add = T, col = "gray")

biomes_simple["biome"] %>% 
  # st_drop_geometry() %>%
  # filter(biome %in% grep("Savanna", biomes_simple$biome, value = TRUE)) %>%
  # st_geometry() %>%
  plot()

grep("Savanna", biomes_simple$biome, value = TRUE)

biomes_simple %>%
  filter()
  st_geometry() %>%
  plot()

site_ecoregions %>% 
  filter(site == site_df$site[i])

# ecoregions_by_site

```


```{r plot-biomes}
# load biomes - see "biomes" chunk above
biomes <- st_read(paste0(p_dat, "Habitats/biomes.shp"))


ggplot() + theme_classic() + 
  geom_sf(data = biomes, aes(fill = biome))

# "Biomes ... are defined by The Nature Conservancy's terrestrial ecoregions of the world dataset"

# make a list of cropped biomes cropped to each site:
site_biomes <- lapply(1:11, function(i) {
  temp <- st_crop(biomes, ext(lc[[i]]))
  temp <- temp %>% mutate(site = site_df$site[i])
  temp
}) %>% bind_rows()

st_write(site_biomes, dsn = paste0(p_derived, "site_biomes.shp"))


site_biome_names <- site_biomes %>% 
  st_drop_geometry() %>% select(biome) %>% 
  arrange(biome) %>% unique() %>% .$biome

# all site - but facet_wrap doesn't work with geom_sf with free scales
ggplot() + theme_classic() + 
  geom_sf(data = site_biomes, aes(fill = biome)) + 
  # theme(axis.text.x = element_text(angle = 320, vjust = 1, hjust = 0)) +
  facet_wrap(vars(site))


biome_pal <- gg_color_hue(9)
names(biome_pal) <- site_biome_names

site_df
site_biomes %>% st_drop_geometry() %>% select(biome, site) %>%
  


str_wrap(names(biome_pal), 20)

site_biomes %>% 
  st_drop_geometry() %>% select(biome, site)
  
gg_biomes_all <-
  ggplot(data = site_biomes, aes(fill = biome)) +
  theme_classic() + 
  geom_sf() + 
  labs(fill = NULL) +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 7)) + 
  guides(fill = guide_legend(ncol = 2)) +
  scale_fill_manual(values = biome_pal, labels = str_wrap(names(biome_pal), 24)
                    ) + 
  facet_wrap(vars(site), labeller = as_labeller(cap_update_labels))

  
biomes_by_site <-
  lapply(1:11, function(i){
    ggplot(data = site_biomes %>% filter(site == site_df$site[i]), aes(fill = biome)) +
      theme_classic() + 
      geom_sf() + 
      labs(fill = NULL) +
      theme(legend.position = "none",
            axis.text.x = element_text(angle = 320, vjust = 1, hjust = 0)) + 
      guides(fill = guide_legend(ncol = 1)) + 
      scale_fill_manual(values = biome_pal) + 
      facet_wrap(vars(site), labeller = as_labeller(cap_update_labels))
  })

biome_legend <- ggpubr::get_legend(gg_biomes_all + 
                                     guides(fill = guide_legend(nrow = 2)) +
                                     theme(legend.position = "bottom"))

ggsave(plot = 
         plot_grid(
           plot_grid(plotlist = biomes_by_site, ncol = 4, nrow = 3),
           as_ggplot(biome_legend),
           nrow = 2, rel_heights = c(2, 0.2)),
       filename = paste0(p_plots, "biomes_by_site.pdf"), 
    width = 7.5, height = 6.75, units = "in"
)


# ------------------------------------------------------------ #
# Ecoregions 2017 - biomes
# ------------------------------------------------------------ #

biome2017_pal <- gg_color_hue(9)
names(biome2017_pal) <- site_ecoregions2017 %>% 
  st_drop_geometry() %>% select(BIOME_NAME) %>% 
  arrange(BIOME_NAME) %>% unique() %>% .$BIOME_NAME


gg_biomes2017_by_site <-
  lapply(1:11, function(i){
    ggplot(data = site_ecoregions2017 %>% 
             filter(site == site_df$site[i]), 
           aes(fill = BIOME_NAME)) +
      theme_classic() + 
      geom_sf() + 
      labs(fill = NULL) +
      theme(legend.position = "none",
            axis.text.x = element_text(angle = 320, vjust = 1, hjust = 0)) + 
      guides(fill = guide_legend(ncol = 1)) + 
      scale_fill_manual(values = biome2017_pal) + 
      facet_wrap(vars(site), labeller = as_labeller(cap_update_labels))
  })

gg_biomes2017_all <-
  ggplot(data = site_ecoregions2017, aes(fill = BIOME_NAME)) +
  theme_classic() + 
  geom_sf() + 
  labs(fill = NULL) +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 7)) + 
  guides(fill = guide_legend(ncol = 2)) +
  scale_fill_manual(values = biome2017_pal, 
                    labels = str_wrap(names(biome2017_pal), 24)
                    ) + 
  facet_wrap(vars(site), labeller = as_labeller(cap_update_labels))

biome2017_legend <- ggpubr::get_legend(gg_biomes2017_all + 
                                     guides(fill = guide_legend(nrow = 2)) +
                                     theme(legend.position = "bottom"))

ggsave(plot = 
         plot_grid(
           plot_grid(plotlist = gg_biomes2017_by_site, ncol = 4, nrow = 3),
           as_ggplot(biome2017_legend),
           nrow = 2, rel_heights = c(2, 0.2)),
       filename = paste0(p_plots, "biomes2017_by_site.pdf"), 
    width = 7.5, height = 6.75, units = "in"
)


```

```{r mn-biome}
usa <- ne_states(returnclass = "sf", country = "United States of America")
mn <- usa %>%
  filter(name == "Minnesota")

wi <- usa %>% filter(name == "Wisconsin")
plot(mn$geometry)
plot(wi$geometry)
mn_biome <- st_crop(biomes, extent(mn))
wi_biome <- st_crop(biomes, extent(wi))

ggplot() +
  theme_classic() + 
  geom_sf(data = mn_biome, aes(fill = biome))

ggplot() +
  theme_classic() + 
  geom_sf(data = wi_biome, aes(fill = biome))

ggplot() + theme_classic() + 
  geom_sf(data = mn_biome, aes(fill = biome)) +
  geom_sf(data = wi_biome, aes(fill = biome))


```


```{r biome-with-raster}
ggplot() +
  theme_classic() + 
  geom_sf(data = biomes_crop %>% filter(site == "shaanxi"), aes(fill = biome)) + 
  labs(fill = NULL) +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 7)) + 
  guides(fill = guide_legend(ncol = 2)) +
  scale_fill_manual(values = biome_pal, labels = str_wrap(names(biome_pal), 24)
                    ) + 
  facet_wrap(vars(site), labeller = as_labeller(cap_update_labels)) + 
  geom_raster(age_r$shaanxi$y2017, mapping = aes(fill = y2017))


plot(biomes_crop %>% filter(site == "shaanxi") %>% select(biome))

p <- gplot(age_r$shaanxi$y2017) + 
  geom_raster(aes(fill = value)) +
  # facet_wrap(~ variable) +
  scale_fill_gradientn(colours = terrain.colors(100)) +
  coord_quickmap()

```
