---
title: "Habitats"
author: "Christopher L. Crawford"
date: "11/16/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

This script is part of the **Effects of cropland abandonment on biodiversity** project, developed by Christopher L. Crawford (chris.L.crawford@gmail.com) at Princeton University beginning in Fall 2021.
See https://github.com/chriscra/biodiversity_abandonment.

5 primary sections:

1. Prepping the Jung et al. 2020 map of IUCN Level 2 Habitats (for the year 2015)
2. Interpolating Yin et al. 2020 Land Covers to IUCN Level 2 Habitat Types (Jung et al. 2020)
3. Analyzing Landscape Configuration and Fragmentation via {landscapemetrics} (see "cluster/lsm_2024.R" and "cluster/lsm_two_2024.R")
4. Plotting Ecoregions & Biomes for each site. 

```{r initialize}
source("/Users/christophercrawford/work/projects/biodiversity_abn/scripts/0_start.R")
```

```{r load-files}
source("/Users/christophercrawford/work/projects/biodiversity_abn/scripts/_util/_util_files.R")
```

```{r clean-up}
os <- get_sizes(ls())

os %>% 
  summarise(total_env_size = sum(size)) %>% 
  mutate(gb = total_env_size / 1024^3)

os %>% print(n = 30)

rm(list = os$object[c(1:6)])
# rm(list = os$object[c(3:18)])
get(os$object[c(30)])

# terra and raster temp files
terra::tmpFiles(current=TRUE, orphan=TRUE, old=TRUE, remove=FALSE)
terra::tmpFiles(current=TRUE, orphan=TRUE, old=TRUE, remove=TRUE)

raster::rasterTmpFile()
raster::showTmpFiles()
raster::removeTmpFiles()

warnings()
```


# IUCN Habitat types

Interpolate our annual land cover time series from Yin et al. 2020 (which just has four land cover types) into IUCN Level 2 Habitat Types based on the 2015 IUCN Level 2 Habitat Types map from Jung et al. 2020.

## Load, crop, and prep Jung et al. 2020

```{r load-jung-habitat-types}
# level 1
jung_l1 <- rast(paste0(p_dat, "Habitats/Jung_GlobalHabitatTypes/iucn_habitatclassification_composite_lvl1_ver004.tif"))
# jung_l1 <- rast(paste0(p_dat, "Habitats/Jung_GlobalHabitatTypes/iucn_habitatclassification_composite_lvl1_ver003.tif"))


# level 2
jung_l2 <- rast(paste0(p_dat, "Habitats/Jung_GlobalHabitatTypes/iucn_habitatclassification_composite_lvl2_ver004.tif"))
# jung_l2 <- rast(paste0(p_dat, "Habitats/Jung_GlobalHabitatTypes/iucn_habitatclassification_composite_lvl2_ver003.tif"))

plot(jung_l2, type = "classes")


# produce global class frequencies:
# freq(jung_l2) %>% write_csv(paste0(p_proj, "resources/jung_freq_table.csv")) # careful, this takes a while
jung_freq <- read_csv(paste0(p_proj, "resources/jung_freq_table.csv"))
```

```{r crop-jung}
# ---------------------------------------------- #
# crop with a buffer, to deal with NA issues: use this going forward
# ---------------------------------------------- #

# --------- no buffer --------- #
site_jung_l1_no_buff <- lapply(1:11, function(i) {
  terra::crop(jung_l1, ext(lcc[[i]]),
              filename = paste0(p_derived, "site_jung/", 
                                names(lcc[i]), "_jung_l1.tif"),
              overwrite = TRUE
              )})

site_jung_l2_no_buff <- lapply(1:11, function(i) {
  terra::crop(jung_l2, ext(lcc[[i]]),
              filename = paste0(p_derived, "site_jung/", 
                                names(lcc[i]), "_jung_l2.tif"),
              overwrite = TRUE
              )})



# now, with a buffer, to facilitate resampling
site_jung_l1 <- lapply(1:11, function(i) {
  terra::crop(jung_l1, ext(lc[[i]]) + rep(0.1, 4), # with a bit of buffer
              filename = paste0(p_derived, "site_jung/", 
                                names(lc[i]), "_jung_l1_buff.tif"),
              overwrite = TRUE
              )
  }
  )
names(site_jung_l1) <- site_df$site

# load back in
site_jung_l1 <- lapply(
  list.files(paste0(p_derived, "site_jung"), full.names = TRUE) %>%
    grep("_l1_buff", ., value = TRUE), 
  function(i) rast(i)
  )
names(site_jung_l1) <- site_df$site


site_jung_l2 <- lapply(1:11, function(i) {
  terra::crop(jung_l2, ext(lc[[i]]) + rep(0.1, 4), # with a bit of buffer
              filename = paste0(p_derived, "site_jung/", 
                                names(lc[i]), "_jung_l2_buff.tif"),
              overwrite = TRUE
              )
  }
  )
names(site_jung_l2) <- site_df$site

# load back in
site_jung_l2 <- lapply(
  list.files(paste0(p_derived, "site_jung"), full.names = TRUE) %>%
    grep("_l2_buff", ., value = TRUE), 
  function(i) rast(i)
  )
names(site_jung_l2) <- site_df$site

plot(site_jung_l2$shaanxi, type = "classes")
```


```{r resample-jung}
# ------------------------------------------------------ #
# resample from ~ 100m resolution to 30m resolution to match Yin et al. 2020 maps
# ------------------------------------------------------ #
# level 1
site_jung_l1_30 <- lapply(1:11, function(i) {
  terra::resample(
    x = site_jung_l1[[i]], y = lc[[i]]$y2017, method = "near",
    filename = paste0(p_derived, "site_jung/", names(lc[i]), "_jung_l1_30.tif"),
    names = paste0(names(lc[i]), "_jung_l1_30"),
    overwrite = TRUE)
  }
  )

# load back in
site_jung_l1_30 <- lapply(
  list.files(paste0(p_derived, "site_jung"), full.names = TRUE) %>% grep("l1_30.tif", ., value = TRUE), 
  function(i) rast(i)
  )
names(site_jung_l1_30) <- site_df$site

# level 2
site_jung_l2_30 <- lapply(1:11, function(i) {
  terra::resample(
    x = site_jung_l2[[i]], y = lc[[i]]$y2017, method = "near",
    filename = paste0(p_derived, "site_jung/", names(lc[i]), "_jung_l2_30.tif"),
    names = paste0(names(lc[i]), "_jung_l2_30"),
    overwrite = TRUE)
  }
  )

# load back in
site_jung_l2_30 <- lapply(
  list.files(paste0(p_derived, "site_jung"), full.names = TRUE) %>% grep("l2_30.tif", ., value = TRUE), 
  function(i) rast(i)
  )
names(site_jung_l2_30) <- site_df$site
```

## Crosswalking IUCN Level 2 Habitats (Jung et al. 2020) to Yin et al. 2020 Land Covers

```{r jung-table}
# ---------------------------------------------- #
# Jung table with classes
# ---------------------------------------------- #
jung_l1_table_clr <- read_delim(
  file = paste0(p_dat, "Habitats/Jung_GlobalHabitatTypes/Habitatmapping-004/styles/level1.clr"), 
  delim = " ", 
  col_names = c("map_code", "R", "G", "B", "Opacity", "Name")) %>%
  mutate(cols = rgb(R, G, B, maxColorValue = 255),
         label = paste0(map_code, ": ", Name)
  )


jung_l2_table_clr <- read_delim(
  file = paste0(p_dat, "Habitats/Jung_GlobalHabitatTypes/Habitatmapping-004/styles/level2.clr"), 
  delim = " ", 
  col_names = c("map_code", "R", "G", "B", "Opacity", "Name")) %>%
  mutate(cols = rgb(R, G, B, maxColorValue = 255))

jung_table <- read_csv(paste0(p_dat, "Habitats/Jung_GlobalHabitatTypes/Habitatmapping-004/IUCN_mapping_legend.csv")) %>%
  rename("map_code" = "NewCode") %>%
  mutate(IUCNLevel = gsub(" – | –", " - ", IUCNLevel)) %>%
  left_join(select(jung_l2_table_clr, map_code, cols, Coarse_Name = Name), by = "map_code") %>%
  mutate(label = paste0(map_code, ": ", IUCNLevel))

jung_table %>% select(map_code, IUCNLevel) %>% print(n = 126)

jung_table %>% 
  filter(map_code == 1404) %>%
  .$IUCNDefintion
  # .$Notes

# level 1
jung_table %>%
  filter((map_code %% 100) == 0) %>%
  select(map_code, Coarse_Name, IUCNLevel)
```


```{r iucn-crosswalk}
# ---------------------------------------------- #
# IUCN crosswalk, produced manually in Excel
# ---------------------------------------------- #
iucn_crosswalk # see _util_files.R

iucn_crosswalk %>% arrange(lc, map_code) %>% print(n = 45)
iucn_crosswalk %>% arrange(map_code) %>% print(n = 45)

```

```{r calculate-overlap-Jung-to-Yin}
# Comparing different approaches to crosswalking the IUCN Level 2 habitat types to the broader Yin land covers 

i <- 3
lc[[i]]$y2015

site_jung_l1_30[[i]]
site_jung_l1_30_freq$map_code %>% sort %>% unique()
jung_l1_table_clr
jung_l2_table_clr

jung_table %>% 
  select(map_code, Coarse_Name) 

select(iucn_crosswalk, "is" = map_code, "becomes" = lc)

lc_plot_cols$name

# reclassify level 2 habitat types

iucn_crosswalk <- iucn_crosswalk %>% 
  mutate(
    #lc is where savanna is grassland (4) and shrubland is forest (2)
    
    # recode shrubland (IUCN) to 4, grassland (lc). 
    # This version has both savanna and shrubland as grassland (2)
    lc2 = ifelse(map_code >= 300 & map_code < 400, 4, lc), 
    
    # recode savanna (IUCN) to forest (lc). 
    # This version has both savanna and shrubland as forest (3)
    lc3 = ifelse(map_code >= 200 & map_code < 300, 2, lc), 
    
    # swap both: This version has savanna as forest (2), and shrubland as grassland (4)
    lc4 = ifelse(map_code >= 200 & map_code < 300, 2, lc2) 
  )

iucn_crosswalk %>% select(map_code:lc, lc2:lc4, IUCNLevel) %>% print(n = 50)


tic()
site_jung_l2_30_rcl <- 
  lapply(1:11, function(site) {
    rast(lapply(c("lc", "lc2", "lc3", "lc4"), function(lc_type) {
      classify(
        site_jung_l2_30[[site]],
        
        # cycles through lc, lc2, lc3, and lc4 as the "lc_type", to convert the map_code to.
        rcl = iucn_crosswalk %>% select("is" = map_code, "becomes" = lc_type),
        filename = paste0(p_derived, "site_jung/", site_df$site[site], "_jung_l2_rcl_", lc_type,".tif"),
        overwrite=TRUE)
      }
      )
    )
    }
    )
toc()


# load back in site_jung_l2_30_rcl
for (lc_type in c("lc", "lc2", "lc3", "lc4")) {}
tt <- rast(paste0(p_derived, "site_jung/", site_df$site[9], "_jung_l2_rcl_", 
                  c("lc", "lc2", "lc3", "lc4"), ".tif"))


site_jung_l2_30_rcl <- 
  lapply(1:11, function(i) {
    rast(paste0(p_derived, "site_jung/", site_df$site[i], "_jung_l2_rcl_", 
                  c("lc", "lc2", "lc3", "lc4"), ".tif"))
    }
    )

names(site_jung_l2_30_rcl) <- site_df$site
for(i in 1:11) {names(site_jung_l2_30_rcl[[i]]) <- c("lc", "lc2", "lc3", "lc4")}


plot(site_jung_l2_30_rcl[[3]]$lc, col = lc_plot_cols$color)
plot(lcc[[3]]$y2015, col = lc_plot_cols$color)

# Comparing how well the crosswalks match:
# Confusion Matrix
conf <- tmp_dt[, 1:2][, .N, by = c("y2015", "lc")][order(y2015, lc)]
conf %>% pivot_wider(names_from = lc, values_from = N)
                       

# --------------------------------------------------------------------- #
# calculate the jaccard similarities between Yin's land cover maps (2015) and the IUCN habitat map (Jung 2020), following four different recoding schemes.
# --------------------------------------------------------------------- #

site <- 3
crosswalk_jac0

identical(crosswalk_jac, crosswalk_jac0)

crosswalk_jac <- lapply(1:11, 
                        function(site) {
  tmp_t <- terra::rast(
    list(
      lcc[[site]]$y2015, # land cover in 2015
      site_jung_l2_30_rcl[[site]] # IUCN habitat types, reclassified
    )
    )

  # convert to data.table
  tmp_dt <- spatraster_to_dt(tmp_t, xy_switch = FALSE)
  
  # calculate Jaccard similarity
  jac_df <- lapply(c("lc", "lc2", "lc3", "lc4"), function(rcl_version){
    tibble(site = site_df$site[site],
           lc = 1:4,
           ver = rcl_version) %>%
      mutate(jaccard = sapply(lc, #1:4, 
                              function(lc_code) {
        int <- tmp_dt[y2015 == lc_code & get(rcl_version) == lc_code, .N] # intersection
        a <- tmp_dt[y2015 == lc_code, .N] 
        b <- tmp_dt[get(rcl_version) == lc_code, .N]
        int / (a + b - int) # int / union
        }))
    
    }
    ) %>% bind_rows()

  jac_df
  }) %>% 
  bind_rows()

write_csv(crosswalk_jac, paste0(p_derived, "jung_crosswalk_jaccard.csv"))

names(site_jung_l2_30_rcl) <- c("shrubs to forest, savanna to grass", 
                                "shrubs to grass, savanna to grass",
                                "shrubs to forest, savanna to forest", 
                                "shrubs to grass, savanna to forest")

# for (i in 1:24) {
gg_crosswalk_jac <-
  crosswalk_jac %>%
  filter(lc %in% c(2, 4)) %>%
  ggplot(mapping = aes(x = as_factor(lc), y = jaccard, fill = as_factor(ver))) +
    geom_col(size = 1, position = position_dodge2()) + 
    theme_classic() +
  labs(fill = "Crosswalk", x = "Land Cover Class", y = "Jaccard Similarity") +
  scale_x_discrete(labels = c("1" = "Non-veg",
                              "2" = "Forest",
                              "3" = "Cropland",
                              "4" = "Grassland")) +
  scale_fill_manual(values = met.brewer("Kandinsky", n = 4), #brewer.pal(n = 4, name = "Set1"), # gg_color_hue(4), #viridis(n = 4),
                    labels = c("lc" = "Shrubs <-> forest,\n savanna <-> grass", 
                                "lc2" = "Shrubs <-> grass,\n savanna <-> grass",
                                "lc3" = "Shrubs <-> forest,\n savanna <-> forest", 
                                "lc4" = "Shrubs <-> grass,\n savanna <-> forest")) +
  facet_wrap(vars(site), #scales = "free", 
             labeller = as_labeller(fancy_labels)) + 
  theme(
    # axis.text.x = element_text(angle = 30, vjust = 1, hjust = 1),
    legend.background = element_blank(),
    legend.position = c(0.875, 0.13))


ggsave(plot = gg_crosswalk_jac,
       filename = paste0(p_plots, "crosswalk_jaccard.pdf"),
       width = 6.25, height = 5, units = "in")
# }

i <- 1 # belarus
i <- 2 # bh
i <- 11 # wisc


plot(site_jung_l1_30[[i]])
plot(site_jung_l1_30[[i]],
     breaks = c(299, 301),
     main = paste0(names(site_jung_l1_30[[i]]), ": shrubland"))

plot(site_jung_l2_30[[i]],
     breaks = c(299, 399),
     main = paste0(names(site_jung_l2_30[[i]]), ": shrubland"),
     col = "red", add = T)

plot(lc[[i]]$y2015,
     col = lc_plot_cols$color)

# comparing grassland and shrubland, jung first
plot(site_jung_l2_30[[i]],
     breaks = c(299, 399),
     main = paste0(names(site_jung_l2_30[[i]]), ": shrubland"),
     col = "red")

plot(lc[[i]]$y2015,
     col = lc_plot_cols$color,
     breaks = c(3.9, 4.1),
     add = T)

# lc first
plot(lc[[i]]$y2015,
     col = lc_plot_cols$color,
     breaks = c(3.9, 4.1))

plot(site_jung_l2_30[[i]],
     breaks = c(299, 399),
     main = paste0(names(site_jung_l2_30[[i]]), ": shrubland"),
     col = "red", add = T)

jung_l2_table_clr %>% print(n = 82)

```



## Exploratory data analysis and visualization

```{r jung-freq}
# ----------------------------- #
# freq in each class
site_jung_l1_freq_no_buff <- lapply(1:11, function(i) {
  freq(site_jung_l1_no_buff[[i]]) %>% as_tibble() %>% mutate(site = site_df$site[i])
  }) %>% bind_rows() %>% 
  select("map_code" = "value", count, site) %>%
  left_join(select(jung_table, map_code, Coarse_Name, IUCNLevel))

site_jung_l1_freq_no_buff <- site_jung_l1_freq_no_buff %>% 
  left_join(., 
            site_jung_l1_freq_no_buff %>% 
              group_by(site) %>%
              summarise(total_px = sum(count))) %>%
  mutate(hab_percent = 100*count/total_px) %>% 
  ungroup() %>%
  select(map_code, site, hab_percent, Coarse_Name, IUCNLevel, count, total_px)

write_csv(site_jung_l1_freq_no_buff, file = paste0(p_derived, "site_jung_l1_freq_no_buff.csv"))

site_jung_l2_freq_no_buff <- lapply(1:11, function(i) {
  freq(site_jung_l2_no_buff[[i]]) %>% as_tibble() %>% mutate(site = site_df$site[i])
  }) %>% bind_rows() %>% 
  select("map_code" = "value", count, site) %>%
  left_join(select(jung_table, map_code, Coarse_Name, IUCNLevel))

site_jung_l2_freq_no_buff <- site_jung_l2_freq_no_buff %>% 
  left_join(., 
            site_jung_l2_freq_no_buff %>% 
              group_by(site) %>%
              summarise(total_px = sum(count))) %>%
  mutate(hab_percent = 100*count/total_px) %>% 
  ungroup() %>%
  select(map_code, site, hab_percent, Coarse_Name, IUCNLevel, count, total_px)

# write to file
write_csv(site_jung_l2_freq_no_buff, file = paste0(p_derived, "site_jung_l2_freq_no_buff.csv"))




# Frequency, at 30 m resolution:
# ----------------------------- #
# freq in each class
site_jung_l1_30_freq <- lapply(1:11, function(i) {
  freq(site_jung_l1_30[[i]]) %>% as_tibble() %>% mutate(site = site_df$site[i])
  }) %>% bind_rows() %>% 
  select("map_code" = "value", count, site) %>%
  left_join(select(jung_table, map_code, Coarse_Name, IUCNLevel))

site_jung_l1_30_freq <- site_jung_l1_30_freq %>% 
  left_join(., 
            site_jung_l1_30_freq %>% 
              group_by(site) %>%
              summarise(total_px = sum(count))) %>%
  mutate(hab_percent = 100*count/total_px) %>% 
  ungroup() %>%
  select(map_code, site, hab_percent, Coarse_Name, IUCNLevel, count, total_px)

# write to file
write_csv(site_jung_l1_30_freq, file = paste0(p_derived, "site_jung_l1_30_freq.csv"))


site_jung_l2_30_freq <- lapply(1:11, function(i) {
  freq(site_jung_l2_30[[i]]) %>% as_tibble() %>% mutate(site = site_df$site[i])
  }) %>% bind_rows() %>% 
  select("map_code" = "value", count, site) %>%
  left_join(select(jung_table, map_code, Coarse_Name, IUCNLevel))

site_jung_l2_30_freq <- site_jung_l2_30_freq %>% 
  left_join(., 
            site_jung_l2_30_freq %>% 
              group_by(site) %>%
              summarise(total_px = sum(count))) %>%
  mutate(hab_percent = 100*count/total_px) %>% 
  ungroup() %>%
  select(map_code, site, hab_percent, Coarse_Name, IUCNLevel, count, total_px)

# write to file
write_csv(site_jung_l2_30_freq, file = paste0(p_derived, "site_jung_l2_30_freq.csv"))


site_jung_l2_30_freq %>% 
  select(map_code, Coarse_Name, IUCNLevel) %>%
  unique() %>% arrange(map_code) %>% print (n=37)

# percent of each site in each habitat type:
# what proportion of the abandoned land at each site ends up in forest vs. grassland?

site_jung_l2_30_freq %>% 
  filter(#hab_percent > 1,
         site %in% site_df$site[c(7:10)]
         ) %>% 
  select(site, hab_percent, Coarse_Name, IUCNLevel) %>% 
  arrange(site, desc(hab_percent)) %>%
  print(n = 60)
  

site_jung_l2_30_freq %>% 
  filter(#hab_percent > 1,
         site %in% site_df$site[c(7:10)]
         ) %>% 
  select(site, hab_percent, Coarse_Name, IUCNLevel) %>% 
  group_by(site, Coarse_Name) %>% 
  summarise(total_percent = sum(hab_percent)) %>%
  arrange(site, desc(total_percent)) %>%
  print(n = 60)

site_jung_l2_30_freq %>% 
  filter(hab_percent > 0.5
         ) %>% 
  select(map_code, Coarse_Name, IUCNLevel) %>% unique() %>%
  arrange(Coarse_Name) %>%
  print(n = 60)


site_jung_l2_30_freq %>% 
    # filter(site == site_df$site[i]) %>%
    # filter(hab_percent > 0.5) %>%
    arrange(Coarse_Name, desc(hab_percent)) %>% 
    select(map_code, site, hab_percent, Coarse_Name, IUCNLevel) %>%
    # group_by(Coarse_Name, site) %>%
    # summarise(percent = sum(hab_percent)) %>%
    # arrange(Coarse_Name, desc(percent)) %>% 
    print(n = 170)

site_jung_l1_30_freq %>% 
    # filter(site == site_df$site[i]) %>%
    # filter(hab_percent > 0.5) %>%
    arrange(Coarse_Name, desc(hab_percent)) %>% 
    # select(map_code, site, hab_percent, Coarse_Name, IUCNLevel) %>%
    group_by(Coarse_Name, site) %>%
    summarise(percent = sum(hab_percent)) %>%
    arrange(Coarse_Name, desc(percent)) %>% 
    print(n = 170)





site_jung_l1_30_freq <- read_csv(file = paste0(p_derived, "site_jung_l1_30_freq.csv"))
site_jung_l2_30_freq <- read_csv(file = paste0(p_derived, "site_jung_l2_30_freq.csv"))


```

```{r calc-area-per-habitat-type}

# load jung maps
site_jung_l2_30
sapply(site_jung_l2_30, ncell)
sapply(site_area_ha, ncell)

# calculate the area of the spatraster
site_area_ha <- lapply(
    list.files(paste0(p_derived, "site_area_ha"), full.names = TRUE), 
    function(i) rast(i)
    )

# combine the two, convert to data.table (without x and y coordinates), and calculate the area in each habitat type across each site.

jung_hab_type_area_df <- 
  lapply(1:11, function(i) {
    jung_dt <- spatraster_to_dt(
      spt = c(site_area_ha[[i]],
              site_jung_l2_30[[i]]
              ),
      xy_switch = FALSE)
    
    names(jung_dt) <- c("area_ha", "habitat_type")
    
    tmp_df <- 
      jung_dt[, sum(area_ha), 
              by = habitat_type] %>%
      as_tibble() %>%
      rename(area_ha = "V1") %>%
      arrange(habitat_type) %>%
      mutate(site = site_df$site[i])
    
    # return
    tmp_df
    }) %>% 
  bind_rows()


plot(site_jung_l2$belarus)
plot(site_jung_l2$belarus)
plot(abn_lcc$belarus$y2015)
plot(abn_lcc_iucn_habitat$belarus$y2015)
plot(abn_lcc$belarus$y1992)
plot(abn_lcc_iucn_habitat$belarus$y1992)


jung_hab_type_area_df %>% filter(site == "belarus") %>%
  select(habitat_type, area_ha, IUCNLevel, prop_lc)



jung_hab_type_area_df %>% print(n = 161)

# join to jung/IUCN ~ Yin et al. 2021 lc crosswalk
# ---------------------------------------------- #
# Jung table crosswalk
# ---------------------------------------------- #
iucn_crosswalk

jung_hab_type_area_df <- jung_hab_type_area_df %>%
  left_join(iucn_crosswalk, by = c("habitat_type" = "map_code")) %>%
  select(site, habitat_type, lc, area_ha, everything())

# adjusting the area of habitat amount based on habitat preferences
jung_hab_type_area_df <- jung_hab_type_area_df %>%
  arrange(site, lc, habitat_type) %>%
  left_join(
    jung_hab_type_area_df %>%
      group_by(site, lc) %>%
      summarise(total_area_per_lc = sum(area_ha)),
    by = c("site", "lc")) %>%
  mutate(prop_lc = area_ha / total_area_per_lc)


# write to file
jung_hab_type_area_df %>%
  write_csv(file = paste0(p_derived, "jung_hab_type_area_df.csv"))



jung_hab_type_area_df <- read_csv(file = paste0(p_derived, "jung_hab_type_area_df.csv"))
```


```{r save-plot-jung}
# jung_table
jung_table
# plot(site_jung_l2$iraq, type = "classes")

# ------------------ Level 1 ---------------------- # 

# redoing this without a buffer:
{
  pdf(file = paste0(p_output, "plots/habitats/jung_l1_sites_colors_no_buff.pdf"), width = 10, height = 7.5)
mval <- 1.5
par(mfrow = c(3, 4), 
      # mar=c(0,0,0,0), 
      oma=c(1,1,0,0),
      adj = 0,
      cex.main = 1#,
      # tcl = -0.2
      )
    
# i <- 3
# plot(site_jung_l1[[i]], maxcell = 5000000,
#        main = names(site_jung_l1[i]),
#        mar = c(mval+0.5, mval, mval + 1.2, mval + 2), # bltr     
#        type = "classes", #legend = FALSE,
#        # col = tmp_table$cols,
#        # levels = tmp_table$map_code,
# )

for(i in 1:11) {
  
  tmp_table <- #jung_table %>%
    jung_l1_table_clr %>%
    arrange(map_code) %>% 
    filter(map_code %in% filter(site_jung_l1_freq_no_buff,
                                site == site_df$site[i])$map_code
           )
  
  plot(site_jung_l1_no_buff[[i]], maxcell = 5000000,
       # main = names(site_jung_l1[i]),
       colNA = "gray95", main = new_titles[i],
       mar = c(mval+0.5, mval, mval + 1.2, mval + 2), # bltr     
       type = "classes", #legend = FALSE,
       col = tmp_table$cols,
       levels = tmp_table$map_code,
)
  }

# pdf(file = paste0(p_output, "plots/jung_sites_colors_legend.pdf"), width = 7.5, height = 7.5)
plot.new()
plot(site_jung_l1_no_buff[[i]], type = "classes",
     legend = "left",
     plg = list(cex = 1.5,
                title = "IUCN Habitat Types\n(Level 1)",
                                # text.width = 100,
                title.adj = 0#,
                # y.intersp	= 1.1
                # xjust = 0.5
                ),
     legend.only = TRUE,
     levels =
       # str_wrap(
       jung_l1_table_clr %>% 
       mutate(label = case_when(
         map_code == 1400 ~ "1400: Artificial",
         map_code == 500 ~ "500: Wetlands",
         TRUE ~ label)) %>%
       arrange(map_code) %>% 
       filter(map_code %in% c(site_jung_l1_freq_no_buff$map_code %>% unique() %>% sort())) %>% .$label,
                # width = 40, exdent = 5),
     col = filter(arrange(jung_l1_table_clr, map_code),
                    map_code %in% c(site_jung_l1_freq_no_buff$map_code %>% unique() %>% sort()))$cols
     )

dev.off()
}

# ------------------ Level 2 ---------------------- # 

{pdf(file = paste0(p_output, "plots/habitats/jung_l2_sites_colors_no_buff.pdf"), width = 10, height = 7.5)
mval <- 1.5
par(mfrow = c(3, 4), 
      # mar=c(0,0,0,0), 
      oma=c(1,1,0,0),
      adj = 0,
      cex.main = 1#,
      # tcl = -0.2
      )
    
# i <- 2

for(i in 1:11) {
  
  tmp_table <- jung_table %>% 
    arrange(map_code) %>% 
    filter(map_code %in% filter(site_jung_l2_freq_no_buff,
                                site == site_df$site[i])$map_code
           )
  
  plot(site_jung_l2_no_buff[[i]], maxcell = 5000000,
       # main = names(site_jung_l2[i]),
       colNA = "gray95", main = new_titles[i],
       mar = c(mval+0.5, mval, mval + 1.2, mval + 2), # bltr     
       type = "classes", #legend = FALSE,
       col = tmp_table$cols,
       levels = tmp_table$map_code,
)
  }

# pdf(file = paste0(p_output, "plots/jung_sites_colors_legend.pdf"), width = 7.5, height = 7.5)
# plot.new()
# plot(site_jung_l2[[i]], type = "classes",
#      legend = "left",
#      plg = list(cex = 0.47,
#                 title = "IUCN Habitat Types",
#                                 # text.width = 100,
#                 title.adj = 0#,
#                 # y.intersp	= 1.1
#                 # xjust = 0.5
#                 ),
#      legend.only = TRUE,
#      levels =
#        # str_wrap(
#          filter(arrange(jung_table, map_code),
#                     map_code %in% c(site_jung_l2_freq$map_code %>% unique() %>% sort()))$label,
#                 # width = 40, exdent = 5),
#      col = filter(arrange(jung_table, map_code),
#                     map_code %in% c(site_jung_l2_freq$map_code %>% unique() %>% sort()))$cols
#      )

dev.off()
}



# legend via ggplot:
ggpubr::get_legend(
  ggplot(data = data.frame(speed = 1:34, dist = 1:34),
       mapping = aes(x = speed, y = dist, fill = as_factor(speed))) + 
  geom_col(col = "black") + 
  scale_fill_manual(
    name = "IUCN Habitat Types",
    labels =
       # str_wrap(
         filter(arrange(jung_table, map_code),
                    map_code %in% c(site_jung_l2_freq_no_buff$map_code %>% unique() %>% sort()))$label %>% str_wrap(., width = 30),
                # width = 40, exdent = 5),
     values = filter(arrange(jung_table, map_code),
                    map_code %in% c(site_jung_l2_freq_no_buff$map_code %>% unique() %>% sort()))$cols) + 
  theme(legend.position = "bottom",
        legend.spacing = unit(-4, units = "mm")) + 
  guides(fill = guide_legend(ncol = 3, title.position = "top"))
  ) %>%
ggsave(filename = paste0(p_plots, "habitats/jung_l2_legend_gg.pdf"), 
    width = 6.5, height = 5, units = "in")



# just shaanxi's legend via ggplot:
freq_tmp <- site_jung_l2_freq_no_buff %>% filter(site == "shaanxi")

ggpubr::get_legend(
  ggplot(data = data.frame(speed = 1:17, dist = 1:17),
       mapping = aes(x = speed, y = dist, fill = as_factor(speed))) + 
  geom_col(col = "black") + 
  scale_fill_manual(
    name = "IUCN Habitat Types",
    labels =
       # str_wrap(
         filter(arrange(jung_table, map_code),
                    map_code %in% c(freq_tmp$map_code %>% unique() %>% sort()))$label %>% str_wrap(., width = 30),
                # width = 40, exdent = 5),
     values = filter(arrange(jung_table, map_code),
                    map_code %in% c(freq_tmp$map_code %>% unique() %>% sort()))$cols) + 
  theme(legend.position = "bottom",
        legend.spacing = unit(-4, units = "mm")) + 
  guides(fill = guide_legend(ncol = 2, title.position = "top"))
  ) %>%
ggsave(filename = paste0(p_plots, "habitats/jung_l2_legend_gg_shaanxi2.pdf"), 
    width = 4.5, height = 3.5, units = "in")

```

```{r plot-jung-one-site}
i <- 9
i
mval <- 1.5
plot(site_jung_l2_30[[i]], maxcell = 5000000,
     main = paste0("IUCN Habitat Types, Level 2: ", names(site_jung_l2_30[i])),
     # mar = c(mval+0.5, mval, mval + 1.2, mval + 2), # bltr
     type = "classes", #legend = FALSE,
     col = jung_table %>%
       arrange(map_code) %>%
       filter(map_code %in% filter(site_jung_l2_30_freq,
                                   site == site_df$site[i])$map_code) %>%
       .$cols,
     # levels = jung_table %>%
     #   arrange(map_code) %>%
     #   filter(map_code %in% filter(site_jung_l2_30_freq,
     #                               site == site_df$site[i])$map_code) %>%
     #   .$map_code
     levels =
         filter(arrange(jung_table, map_code),
                map_code %in% filter(site_jung_l2_30_freq,
                                     site == site_df$site[i])$map_code)$label
)


pdf(file = paste0(p_output, "plots/jung_shaanxi_legend.pdf"), width = 7.5, height = 7.5)
plot.new()
plot(site_jung_l2_30[[i]], maxcell = 5000000,
     type = "classes",
     legend = "left",
     plg = list(cex = 1,
                title = "IUCN Habitat Types",
                                # text.width = 100,
                title.adj = 0#,
                # y.intersp	= 1.1
                # xjust = 0.5
                ),
     legend.only = TRUE,
     levels = jung_table %>%
       arrange(map_code) %>%
       filter(map_code %in% filter(site_jung_l2_30_freq,
                                     site == site_df$site[i])$map_code) %>%
       .$label,
     col = jung_table %>%
       arrange(map_code) %>%
       filter(map_code %in% filter(site_jung_l2_30_freq,
                                   site == site_df$site[i])$map_code) %>%
       .$cols
     )

dev.off()

plot(site_jung_l2_30[[i]], type = "classes")
```



```{r plot-elevation}
pdf(file = paste0(p_output, "plots/shaanxi_elevation.pdf"), width = 5, height = 4)
plot(elevation_map[[i]], main = "Elevation (m)")
dev.off()
```


# Assign Yin et al. 2020 Land Covers to IUCN Level 2 Habitat Types

In a previous version of the AOH function, we calculated the area in each land cover class (i.e., of the four land cover classes in the original Yin et al. 2020 land cover maps).
We created a crosswalk to translate our coarse land cover classes into the finer habitat types used by the IUCN and mapped by Jung et al. 2020 for the year 2015  
This crosswalk is captured in chunk `r iucn_crosswalk` in section above titled "Crosswalking..."

One complication is that this crosswalk involves "one to many" relationships (i.e., one land cover class, such as 2 [woody vegetation], could be multiple IUCN habitat types).
For example, `r iucn_crosswalk %>% filter(lc == 2)`.
But, we don't know what any given pixel in lc class 2 (woody vegetation) is, of the various IUCN habitat types.

We had previously used a proportional approach to downscale these coarse land cover classes (e.g., “woody vegetation [2]”) to the finer IUCN habitat classes (e.g., “Forest – Boreal ”), allocating pixels according to the proportion of the broad category each of the IUCN habitat types occupy at each of our sites.
This proportional approach is similar to what other researchers have used (e.g., [Folberth et al. 2020](https://www.nature.com/articles/s41893-020-0505-x)).
So, if a site has 20% temperate forest and 10% subtropical/tropical moist montane forest, for a total of 30% in some type of forest, we would allocate 2/3 of pixels in forest to temperate forest and 1/3 to moist montane forest. 
This was conducted for each year individually - so the area of each land cover class was calculated for each year, and these were then adjusted by the proportion of that land cover class occupied by each IUCN habitat type ("map_code") at each site.
This proportion was calculated for each species iteratively, because the number of habitat types that were suitable for a given species changed over time.

Ultimately, however, we used a different approach designed to directly assign habitat types to each pixel based on the land cover type.
Essentially, we assign each pixel in a land cover (e.g., "woody vegetation [2]") to the nearest analogous habitat type in the 2015 @Jung2020a habitat map.

This process follows seven steps:  

1. Reclassify the habitat map to extract only those habitat types that fall within the above land cover class (e.g., 2, woody vegetation).

2. Fill all NA values in this reclassified habitat map with the modal value of the surrounding 9 cell values, iteratively, using `terra::focal(fun = "modal")`.

3. Resample these focal habitat reclassifications to finer resolution 

4. Mask each resampled focal habitat map to locations of that given land cover class, in each year.

5. Construct a composite habitat map for each year by knitting together these four resampled habitat maps

6. Mask this composite to the area abandoned in each year, for each site.

7. Use this as the final habitat map for calculating area of habitat.

**NOTE**: the final input maps for Calculations 1a and 1b ("crop_abn_iucn" observed and potential) are created in the script "cluster/noncrop_precrop_mask.R".

```{r lcc-iucn-habitat-composite}
# this chunk produces the full site maps of iucn level 2 habitat types, for "Calculation 3" in final manuscript (aka "full_iucn", files ending in "_lcc_iucn_habitat.tif")

site_index <- 3
lc_class <- 2

lc_classes <- 1:4
# lc_classes <- c(2, 4)


plot(abn_lcc[[site_index]][["y2015"]])
plot(lcc[[site_index]][["y2015"]])


# loop through all 11 sites:

lapply(1:11, function(site_index) {
cat(fill = TRUE, 
    "Direct reclassification of land cover classes into IUCN habitat map codes:", 
    site_df$site[site_index])

# -------------------------------------------- # 
# 1. Reclassify the habitat map to extract only those habitat types that fall within the above land cover class (e.g., 2: woody vegetation).

# for multiple land cover classes at once:
cat(fill = TRUE, "Subset the Jung habitat map into maps corresponding to four land cover classes.")

iucn_sub <- lapply(seq_along(lc_classes), function(i) {
  lc_class <- lc_classes[i]
  
  classify(
    site_jung_l2[[site_index]],
    rcl = iucn_crosswalk %>% 
      filter(lc != lc_class) %>% select(is = map_code) %>% mutate(becomes = NA),
    names = paste0("lc", lc_class)
    )
  }) %>% rast()

# plot(iucn_sub)

# -------------------------------------------- # 
# 2. Fill all NA values in this reclassified habitat map with the modal value of the surrounding 9 cell values, using `terra::focal(fun = "modal")`.

# loop through each land cover layer until there are no more NA values.
cat(fill = TRUE, "Use focal() to fill all NA cells with modal value for each lc subset.")

tic()
iucn_focal <- lapply(seq_along(lc_classes), function(i) {
  x <- terra::focal(iucn_sub[[i]], w = 3, 
                    fun = "modal", na.rm = TRUE, na.policy = "only", expand = TRUE
                    )
  
  while(is.na(global(x, fun = "min"))) {
    x <- terra::focal(x, w = 3, fun = "modal", 
                      na.rm = TRUE, na.policy = "only", expand = TRUE)
  }
  
  x
  }) %>% rast()
toc()

names(iucn_focal) <- paste0(names(iucn_sub), "_iucn_focal")

# plot(iucn_focal)
# iucn_crosswalk %>% print(n = 50)


# save this composite layer:
writeRaster(iucn_focal,
            filename = paste0(p_derived, "lcc_iucn_habitat/", 
                              site_df$site[site_index], "_iucn_focal.tif"),
            names = names(iucn_focal),
            overwrite = TRUE)


# iucn_focal <- rast(paste0(p_derived, "lcc_iucn_habitat/", 
#                               site_df$site[site_index], "_iucn_focal.tif"))

# -------------------------------------------- # 
# 3. Resample each resampled habitat map to finer resolution.

cat(fill = TRUE, "Resample iucn_focal to site extent and resolution.")

iucn_focal_resampled <- 
  lapply(seq_along(lc_classes), function(i) {
  terra::resample(
    x = iucn_focal[[i]], y = lcc[[site_index]][[31]], 
    method = "near"
    )
  }) %>% rast()

# plot(iucn_focal_resampled)


# -------------------------------------------- # 
# 4. Mask directly, based on cell values, rather than with a intermediate step mask.
# This results in a list with a 31-layer spatraster for each land cover class, showing just the habitat map codes for the pixels in that land cover in that year:
cat(fill = TRUE, "Mask and save iucn_focal_msk.")

tic()
iucn_focal_msk <- lapply(seq_along(lc_classes), function(i) {
  terra::mask(
    iucn_focal_resampled[[i]], lcc[[site_index]],
    maskvalues = lc_classes[i], inverse = TRUE,
    names = names(lcc[[site_index]]),
    filename = paste0(p_derived, "lcc_iucn_habitat/", site_df$site[site_index],
                     "_iucn_focal_msk_lc", lc_classes[i], ".tif"),
    overwrite = TRUE
  )}
)
names(iucn_focal_msk) <- paste0("lc", lc_classes)
toc()

# plot(iucn_focal_msk[[1]][[28:31]])
# plot(iucn_focal_msk[[2]][[28:31]])
# plot(iucn_focal_msk[[3]][[28:31]])
# plot(iucn_focal_msk[[4]][[28:31]])
# plot(lcc[[site_index]][[28:31]], col = lc_plot_cols$color)


# -------------------------------------------- # 
# 5. Construct a composite habitat map for each year by knitting together these four resampled habitat maps

cat(fill = TRUE, "Use cover() to knit together four masked SpatRasters.")
tic()
lcc_iucn_habitat <- cover(iucn_focal_msk[[1]], iucn_focal_msk[[2]])
if (length(iucn_focal_msk) > 2) {
  lcc_iucn_habitat <- cover(lcc_iucn_habitat, iucn_focal_msk[[3]])
}

if (length(iucn_focal_msk) > 3) {
  lcc_iucn_habitat <- cover(lcc_iucn_habitat, iucn_focal_msk[[4]])
}
toc()

# plot(lcc_iucn_habitat[[28:31]])
# plot(site_jung_l2[[site_index]])


# save this composite layer:
writeRaster(lcc_iucn_habitat,
            filename = paste0(p_derived, "lcc_iucn_habitat/", 
                              site_df$site[site_index], "_lcc_iucn_habitat.tif"),
            names = names(lcc_iucn_habitat),
            overwrite = TRUE)

terra::tmpFiles(current=TRUE, orphan=TRUE, old=TRUE, remove=TRUE)

##### End of lapply() call #####
})
```


```{r mask-lcc-iucn-habitat-to-abn}
# -------------------------------------------- # 
# 7. Mask this composite to the area abandoned in each year, for each site.

# this chunk produces files ending in "_abn_lcc_iucn_habitat.tif" (aka "abn_iucn")

# Note: the pixels in "abn_lcc_iucn_habitat" are NA until they are abandoned... therefore, exclusively consist of non-cropland habitat.

# The "max_abn_lcc_iucn_habitat" includes values for all pixels that are abandoned at any point during the time series, and includes a habitat type for each year of the time series. So, it includes the habitat before and after abandonment. This is produced in the next chunk

# A third layer, "crop_to_abn_iucn_observed" (aka "crop_abn_iucn") contains IUCN habitats for the abandonment period as well as the immediately preceding period of cultivation (to allow for a proper before and after comparison). These are the final input maps for Calculations 1a and 1b ("crop_to_abn_iucn_observed" and "crop_to_abn_iucn_potential"). These maps are created in the script "cluster/noncrop_precrop_mask.R".

# The three calculations producing final results in the manuscript rely on 1) crop_abn_iucn ("_crop_to_abn_iucn_observed."), 2) max_abn_iucn ("_max_abn_lcc_iucn_habitat."), and 3) full_iucn ("_lcc_iucn_habitat.").

# reload
lcc_iucn_habitat <- lapply(1:11, function(i) {
  rast(paste0(p_derived, "lcc_iucn_habitat/",
              site_df$site[i], "_lcc_iucn_habitat.tif"))
  })
names(lcc_iucn_habitat) <- site_df$site

plot(lcc_iucn_habitat[[1]][[28:31]])

terra::tmpFiles(current=TRUE, orphan=TRUE, old=TRUE, remove=TRUE)



# ---------------------------------------------------------------- #
# [pre] calculate the new iucn habitat codes in pixels *after* they are abandoned
# ---------------------------------------------------------------- #
i <- 9

tic()
lapply(1:11, function(i) {
  # make sure to restrict lc to only 1987:2017 (Nebraska, Wisconsin)
  # i <- 9
  cat("Masking:", site_df$site[i], "...", fill = TRUE)
  tmp <- abn_mask[[i]] + lcc_iucn_habitat[[i]][[paste0("y", 1987:2017)]]
  
  cat("Writing SpatRaster to file:", site_df$site[i], "...", fill = TRUE)
  writeRaster(tmp, 
              filename = paste0(p_derived, "lcc_iucn_habitat/",
                        site_df$site[i], "_abn_lcc_iucn_habitat", run_label, ".tif"), 
              overwrite = TRUE,
              names = names(tmp))
  cat(site_df$site[i], "done!", fill = TRUE)

})
toc()

# plot(abn_lcc_iucn_habitat[[1]][[31]])

# reload
abn_lcc_iucn_habitat <- lapply(1:11, function(i) {
  rast(paste0(p_derived, "lcc_iucn_habitat/",
              site_df$site[i], "_abn_lcc_iucn_habitat", run_label, ".tif"))
  })
names(abn_lcc_iucn_habitat) <- site_df$site
```


```{r max-extent-of-abn-iucn-habitat}
# ---------------------------------------------------------------- #
# ***** Calculate iucn habitats for all pixels that were ever abandoned
# including habitats before *and* after abandonment, to show the net change
# as a result of abandonment. (Calculation 2 in final manuscript)
# ---------------------------------------------------------------- #

# compare to 
max_abn_lcc
max_age_mask

tic()
max_abn_lcc_iucn_habitat <- lapply(1:11, function(i) {
  # make sure to restrict lc to only 1987:2017 (Nebraska, Wisconsin)
  # i <- 9
  cat("Masking:", site_df$site[i], "...", fill = TRUE)
  tmp <- max_age_mask[[i]] + lcc_iucn_habitat[[i]][[paste0("y", 1987:2017)]]
  
  cat("Writing SpatRaster to file:", site_df$site[i], "...", fill = TRUE)
  writeRaster(tmp, 
              filename = paste0(p_derived, "lcc_iucn_habitat/",
                        site_df$site[i], "_max_abn_lcc_iucn_habitat", run_label, ".tif"), 
              overwrite = TRUE,
              names = paste0("y", 1987:2017))
  cat(site_df$site[i], "done!", fill = TRUE)

})
toc()


# reload

max_abn_lcc_iucn_habitat <- 
  lapply(1:11, function(i) {
  rast(paste0(p_derived, "lcc_iucn_habitat/",
              site_df$site[i], "_max_abn_lcc_iucn_habitat", run_label, ".tif"))
  })
names(max_abn_lcc_iucn_habitat) <- site_df$site


plot(max_abn_lcc_iucn_habitat$shaanxi[[28:31]])

```




### Potential abandonment: developing IUCN habitat maps for scenarios without recultivation

This follows from the scenario in which no recultivation occurred, developed for Crawford et al. 2022. 
The challenge involved determining the land cover (and subsequently, the IUCN habitat types) for the potential abandonment layer (which did not initially have land cover classes associated with it).

I produced a draft version of "potential_abn_lcc_iucn_habitat" by using terra::cover(), which sequentially layered years on top of each other, looking for NA pixels in each year, and updating those with corresponding values from the previous year. 
Therefore, anything that was recultivated (i.e., NA in that year) was filled with the value from the year before.
This means that recultivation is filled in with the land use from the previous year.
Unfortunately though, if a pixel is abandoned, recultivated (NA), then abandoned again (non-NA), this second wave of abandonment won't be replaced with the first abandonment, because the pixel isn't NA. 
So, the land cover might revert from forest back to grassland, a younger stage of regeneration.

The second issue is that, regardless, I need to produce a version of the potential_abn_lcc_iucn layer that includes the habitat before and after, to match the max_abn_lcc_iucn layer.

There are a few different approaches I could take:


```{r *create-potential-abn-iucn}
# site_index <- 3

tic()
lapply(1:11, function(site_index) {
  cat("Build potential habitat layer sequentially using terra::cover(), for",
      site_df$site[site_index], fill = TRUE)
  potential_tmp <- lapply(1:31, function(i) {abn_lcc_iucn_habitat[[site_index]][[i]]})
  
  # start in year 6 ("y1992"), which is the first year recultivation is possible (as a result of our five year abandonment threshold).
  for (i in 6:31) {
    tic(paste0("cover() on i = ", i))
    potential_tmp[[i]] <- cover(potential_tmp[[i]], potential_tmp[[i-1]])
    toc()
  }
  
  tic("Combine list layers with rast()")
  potential_tmp <- rast(potential_tmp)
  toc()

  cat("Writing potential_tmp SpatRaster to file:", site_df$site[site_index], "...", fill = TRUE)
  writeRaster(potential_tmp, 
              filename = paste0(p_derived, "lcc_iucn_habitat/",
                        site_df$site[site_index], "_potential_abn_lcc_iucn_habitat",
                        run_label, ".tif"), 
              overwrite = TRUE,
              names = names(potential_tmp))
  
  cat(site_df$site[site_index], "done!", fill = TRUE)
})
toc()

# load back in:
potential_abn_lcc_iucn_habitat <- lapply(1:11, function(i){
  rast(paste0(p_derived, "lcc_iucn_habitat/",
                    site_df$site[i], "_potential_abn_lcc_iucn_habitat",
                    run_label, ".tif"))
})
names(potential_abn_lcc_iucn_habitat) <- site_df$site
```

```{r *potential_max}
# Use cover() to combine the potential_abn_iucn layer with the land cover classes in max_abn_iucn layer


# -----------------------------------------------------------------
# Use cover() to combine potential_abn_lcc_iucn_habitat maps (created above)
# with the max extent abn_lcc_iucn maps, to allow for a before and after
# comparison of AOH in abandoned croplands, in a scenario without reculivation.
# -----------------------------------------------------------------

tic()
lapply(1:11, function(site_index) {
  cat("Build potential habitat layer for max extent using terra::cover(), for",
      site_df$site[site_index], fill = TRUE)
  max_potential_abn_lcc_iucn_habitat <- 
    cover(x = potential_abn_lcc_iucn_habitat[[site_index]], 
          y = max_abn_lcc_iucn_habitat[[site_index]],
          filename = paste0(p_derived, "lcc_iucn_habitat/",
                            site_df$site[site_index], "_max_potential_abn_lcc_iucn_habitat",
                            run_label, ".tif"), 
          overwrite = TRUE,
          names = names(potential_abn_lcc_iucn_habitat[[site_index]]))
  cat(site_df$site[site_index], "done!", fill = TRUE)
})
toc()

# load back in:
max_potential_abn_lcc_iucn_habitat <- lapply(1:11, function(i){
  rast(paste0(p_derived, "lcc_iucn_habitat/",
                    site_df$site[i], "_max_potential_abn_lcc_iucn_habitat",
                    run_label, ".tif"))
})
names(max_potential_abn_lcc_iucn_habitat) <- site_df$site

```

```{r *potential-lcc-full}
# Goal: merge the potential abn layer with the land cover maps for the full landscape, to allow for a full lcc potential AOH run.

# This works the same as for the max_abn potential creation - I'm just using this to fill NA cell values in the potential_abn_lcc_iucn_habitat layer (which has lcc_iucn codes for only abandonment periods).

# two sites were run directly on Della, see script: "cluster/potential_full_iucn.R"

# -----------------------------------------------------------------
# Use cover() to combine potential_abn_lcc_iucn_habitat maps (created above)
# with the max extent abn_lcc_iucn maps, to allow for a before and after
# comparison of AOH in abandoned croplands, in a scenario without reculivation.
# -----------------------------------------------------------------
site_index <- 9


tic()
lapply(1:11, function(site_index) {
  cat("Build potential habitat layer for full site extent using terra::cover(), for",
      site_df$site[site_index], fill = TRUE)
  lcc_iucn_habitat_potential <- 
    cover(x = potential_abn_lcc_iucn_habitat[[site_index]], 
          y = lcc_iucn_habitat[[site_index]][[paste0("y", 1987:2017)]], # selecting only 1987:2017 for Nebraska and Wisconsin.
          filename = paste0(p_derived, "lcc_iucn_habitat/",
                            site_df$site[site_index], 
                            "_lcc_iucn_habitat_potential",
                            run_label, ".tif"), 
          overwrite = TRUE,
          names = names(potential_abn_lcc_iucn_habitat[[site_index]]))
  cat(site_df$site[site_index], "done!", fill = TRUE)
})
toc()

plot(lcc_iucn_habitat_potential[[9]][[31]])
plot(lcc_iucn_habitat[[9]][[31]])

# load back in:
lcc_iucn_habitat_potential <- lapply(1:11, function(i){
  rast(paste0(p_derived, "lcc_iucn_habitat/",
                    site_df$site[i], "_lcc_iucn_habitat_potential",
                    run_label, ".tif"))
})
names(lcc_iucn_habitat_potential) <- site_df$site

```


```{r freq-abn_lcc}

# -------------------------- #
abn_lcc_iucn_habitat_freq <- lapply(1:11, function(i) {
  freq(abn_lcc_iucn_habitat[[i]][[6:31]]) %>% as_tibble() %>% 
    mutate(site = site_df$site[i],
           year = layer + 1991) %>%
  rename(map_code = value)
  }) %>% bind_rows()
write_csv(abn_lcc_iucn_habitat_freq, file = paste0(p_derived, "freq/abn_lcc_iucn_habitat_freq.csv"))
abn_lcc_iucn_habitat_freq <- read_csv(paste0(p_derived, "freq/abn_lcc_iucn_habitat_freq.csv"))

# -------------------------- #
potential_abn_lcc_iucn_habitat_freq <- lapply(1:11, function(i) {
  freq(potential_abn_lcc_iucn_habitat[[i]][[6:31]]) %>% as_tibble() %>% 
    mutate(site = site_df$site[i],
           year = layer + 1991) %>%
  rename(map_code = value)
  }) %>% bind_rows()
write_csv(potential_abn_lcc_iucn_habitat_freq, file = paste0(p_derived, "freq/potential_abn_lcc_iucn_habitat_freq.csv"))
potential_abn_lcc_iucn_habitat_freq <- read_csv(paste0(p_derived, "freq/potential_abn_lcc_iucn_habitat_freq.csv"))


# -------------------------- #
lcc_iucn_habitat_freq <- lapply(1:11, function(i) {
  freq(lcc_iucn_habitat[[i]][[1:31]]) %>% as_tibble() %>% 
    mutate(site = site_df$site[i],
           year = layer + 1986) %>%
  rename(map_code = value)
  }) %>% bind_rows()
write_csv(lcc_iucn_habitat_freq, file = paste0(p_derived, "freq/lcc_iucn_habitat_freq.csv"))


# -------------------------- #
abn_lcc_freq <- lapply(1:11, function(i) {
  freq(abn_lcc[[i]][[6:31]]) %>% as_tibble() %>% 
    mutate(site = site_df$site[i],
           year = layer + 1991) %>%
  rename(lc = value)
  }) %>% bind_rows()
write_csv(abn_lcc_freq, file = paste0(p_derived, "freq/abn_lcc_freq.csv"))
abn_lcc_freq <- read_csv(file = paste0(p_derived, "freq/abn_lcc_freq.csv"))

# -------------------------- #
max_abn_lcc_freq <- lapply(1:11, function(i) {
  freq(max_abn_lcc[[i]][[1:31]]) %>% as_tibble() %>% 
    mutate(site = site_df$site[i],
           year = layer + 1986) %>%
  rename(lc = value)
  }) %>% bind_rows()
write_csv(max_abn_lcc_freq, file = paste0(p_derived, "freq/max_abn_lcc_freq.csv"))
max_abn_lcc_freq <- read_csv(file = paste0(p_derived, "freq/max_abn_lcc_freq.csv"))

# -------------------------- #
max_abn_lcc_iucn_habitat_freq <- lapply(1:11, function(i) {
  
  freq(max_abn_lcc_iucn_habitat[[i]][[1:31]]) %>% as_tibble() %>% 
    mutate(site = site_df$site[i],
           year = layer + 1986) %>%
  rename(map_code = value)
  }) %>% bind_rows()

write_csv(max_abn_lcc_iucn_habitat_freq, 
          file = paste0(p_derived, "freq/max_abn_lcc_iucn_habitat_freq.csv"))
max_abn_lcc_iucn_habitat_freq <- read_csv(file = paste0(p_derived, "freq/max_abn_lcc_iucn_habitat_freq.csv"))


# -------------------------- #
max_potential_abn_lcc_iucn_habitat_freq <- lapply(1:11, function(i) {
  freq(max_potential_abn_lcc_iucn_habitat[[i]][[1:31]]) %>% as_tibble() %>% 
    mutate(site = site_df$site[i],
           year = layer + 1986) %>%
  rename(map_code = value)
  }) %>% bind_rows()

write_csv(max_potential_abn_lcc_iucn_habitat_freq, 
          file = paste0(p_derived, "freq/max_potential_abn_lcc_iucn_habitat_freq.csv"))
max_potential_abn_lcc_iucn_habitat_freq <- read_csv(file = paste0(p_derived, "freq/max_potential_abn_lcc_iucn_habitat_freq.csv"))


# -------------------------- #
max_potential_abn_lcc_iucn_habitat


# sort out

abn_lcc_iucn_habitat_freq %>% group_by(site) %>% summarise(my_codes = unique(map_code)) %>%
  .$my_codes %>% unique() %>% sort()

abn_lcc_iucn_habitat_freq %>%
  filter(site == "iraq") %>%
  select(site, map_code) %>% unique() %>%
  left_join(iucn_crosswalk)

iucn_crosswalk %>% 
  filter(map_code %in% (abn_lcc_iucn_habitat_freq %>% 
                          group_by(site) %>% 
                          summarise(my_codes = unique(map_code)) %>%
                          .$my_codes %>% unique() %>% sort())) %>%
  print()

potential_abn_lcc_iucn_habitat_freq %>% 
  group_by(year, site) %>% 
  summarise(sum = sum(count)) %>%
  arrange(site) %>% View()

max_abn_lcc_freq %>% 
  group_by(year, site) %>% 
  summarise(sum = sum(count)) %>%
  ungroup() %>% select(site, sum) %>% unique() %>%
  arrange(site) #%>% View()

max_abn_lcc_iucn_habitat_freq %>% 
  group_by(year, site) %>% 
  summarise(sum = sum(count)) %>%
  ungroup() %>% select(site, sum) %>% unique() %>%
  arrange(site)

lc_plot_cols$color
freq_cols <- lc_plot_cols$color #plot_cols[1:4]
names(freq_cols) <- 1:4

ggplot(data = 
         abn_lcc_iucn_habitat_freq
       # max_abn_lcc_freq #%>% filter(site == "belarus")
         ) +
  theme_classic() +
  # theme(axis.text.x = element_text(angle = 320, vjust = 1, hjust = 0)) +
  labs(y = "Count", 
       x = "Year", 
       color = NULL) + 
  geom_line(mapping = aes(x = year, y = count / (10^6), # convert to millions of ha
                          # group = as_factor(lc), color = as_factor(lc)
                          group = as_factor(map_code), color = as_factor(map_code)
                          ),
            size = 1.5) + 
  theme(#legend.position = c(0.9, 0.12),
        legend.title = element_text(size = 10)) +
  
  # scale_color_manual(
  #   values = lc_plot_cols$color,
  #   labels = lc_plot_cols$name
  #   # values = as.vector(plot_cols[2:4]),    #c("#276419" , "#E8C32E" , "#7FBC41"),
  #   # labels = names(plot_cols[2:4])   #, breaks = 2:4
  #                    ) +
  # guides(color = guide_legend(ncol = 1)) +
  facet_wrap(vars(site),
             labeller = as_labeller(fancy_labels),
             scales = "free")


```



```{r plot-max-abn-lcc-iucn}
site_index <- 3

tmp_classes <- max_abn_lcc_iucn_habitat[[site_index]][[31]] %>% 
  values() %>% unique() %>% na.omit() %>% 
  sort() %>% as.vector()

tmp_attributes <- 
  jung_table %>%
  arrange(map_code) %>%
  filter(map_code %in% tmp_classes)

site_jung_l2_freq %>% 
  filter(site == site_df$site[site_index])


plot(max_abn_lcc_iucn_habitat[[site_index]][[31]],
     maxcell = 5000000,
     # main = paste0("IUCN Habitat Types, Level 2: ", names(max_abn_lcc_iucn_habitat[2])),
     # mar = c(mval+0.5, mval, mval + 1.2, mval + 2), # bltr
     type = "classes", #legend = FALSE,
     col = tmp_attributes$cols,
     levels = tmp_attributes$label
)

freq(max_abn_lcc_iucn_habitat[[2]][[31]])

tmp_attributes %>% left_join(freq(max_abn_lcc_iucn_habitat[[2]][[31]]), by = c("map_code" = "value"))

plot(site_sf[site_index, ]$geometry, add = TRUE, border = "red")
plot(vert_sites %>% filter(binomial == "Trachypithecus francoisi") %>% st_geometry(), add = TRUE, border = "red")

site_sf[3, ]
```


```{r generic-compare-two-rasters}
# --------------------------------------------------------- #
#  BE CAREFUL with comparing two rasters
# --------
# two ways to compare rasters:
# 1. Do the same cells have values in each?
# 2. Are the values of the cells in each equal to each other?

t1 <- potential_abn_lcc_iucn_habitat$chongqing$y2017
t2 <- full_test

t1 <- tc[[28]]
t2 <- t28

plot(tc[[28]])
plot(t28)

# --------
# 1.
tic()
global(t1, fun = "isNA")
toc()

tic()
global(t2, fun = "isNA") # global(is.na(t2), fun = "sum")
toc()

# --------
# 2. Fill NAs with 0s, match
tic()
t1 <- classify(t1, rcl = tibble("is" = NA_real_, "becomes" = 0))
toc()

tic()
t2 <- classify(t2, rcl = tibble("is" = NA_real_, "becomes" = 0))
toc()

plot(t1)
plot(t2)
plot(t1 - t2)
global(t1 - t2, "sum")


```

## Extract abandonment signal starting from cultivation

In order to compare the effect of abandonment on habitat availability for individual species, we need to be able to compare the habitat before and after abandonment.
This means we have to include the period of cultivation in abandoned pixels *before* they were abandoned. 
It is not enough to just calculate the habitat provided by abandoned pixels after they are abandoned.

To do this, we developed the function "cc_extract_noncrop_precrop()" (see "_util_functions.R") implemented in the script "cluster/noncrop_precrop_mask.R"

## Habitat age profile

```{r habitat-age-profile}
persistence_dat <- 
  read_csv(file = paste0(p_derived2, "persistence_dat", run_label, ".csv")) %>%
  mutate(site = as.factor(site),
         bins = as.factor(bins),
         year_abn_bins = as.factor(year_abn_bins),
         cohort = as.factor(cohort))


ggplot(data = persistence_dat) + 
    theme_classic() +
    labs(y = expression("Area abandoned (10"^{3}*" ha)") , 
         x = "Year",
         fill = "Age (years)") +
    geom_col(mapping = aes(x = year, y = area_ha / 10^3, 
                           fill = fct_reorder(bins, age)),
             position = position_stack(reverse = FALSE)) +
    theme(legend.title = element_text(size = 10)) +
    scale_fill_brewer(palette = "Greens", direction = 1) +
      facet_wrap(vars(site), scales = "free_y")


age_profile_df <- 
  persistence_dat %>% 
  select(site, year, year_abn, age, area_ha) %>%
  arrange(desc(age)) %>%
  group_by(site, year) %>% 
  mutate(total_in_year = sum(area_ha),
         cumsum_in_year = cumsum(area_ha),
         p_hab = cumsum_in_year/total_in_year) %>% ungroup() %>%
  rbind(
    cbind(
      tibble(site = rep(site_df$site, each = 25)),
      lapply(1:1, function(i) {
        tibble(year = 2017:1993,
               year_abn = 1987,
               age = 31:7,
               area_ha = NA,
               total_in_year = NA,
               cumsum_in_year = NA,
               p_hab = 0)
        }) %>% bind_rows())) %>% 
  arrange(site, desc(year), desc(age))

age_profile_df <- age_profile_df %>%
  left_join(age_profile_df %>% 
              filter(year == 2017, age == 20) %>%
              select(site, p_20 = p_hab)) %>%
  mutate(age = as_integer(age))

age_profile_df %>% filter(!is.na(p_20))


gg_hab_age_profile <-
  age_profile_df %>%
  filter(year == 2017) %>%
  ggplot(mapping = aes(x = age, y = p_hab, 
                       col = fct_reorder(site, desc(p_20)))) +
  theme_classic() +
  geom_line(size = 1) + 
  scale_x_continuous(breaks = c(5, 10, 15, 20, 25, 30)) +
  scale_color_discrete(labels = fancy_labels) +
  labs(x = "Habitat age requirement (years)", 
       y = "Prop. abandonment that is suitable (as of 2017)",
       # caption = "Year: 2017",
       color = "Site") 

# save 
ggsave(gg_hab_age_profile,
       filename = paste0(p_plots, "habitat_age_profile_2017.pdf"), 
       width = 5.5, height = 4, units = "in"
)




# animation:
# library(gganimate)
# library(transformr)


gg_hab_age_profile_animate <-
  age_profile_df %>%
  # filter(year %in% seq(from = 1987, to = 2017, by = 5)) %>%
    # filter(year < 1995) %>%
  ggplot(mapping = aes(x = age, y = p_hab, 
                       # group = interaction(site, year), 
                       col = fct_reorder(site, desc(p_20)))) +
  theme_classic() +
  geom_line(size = 1) + 
  scale_x_continuous(breaks = c(5, 10, 15, 20, 25, 30)) +
  scale_color_discrete(labels = fancy_labels) +
  labs(x = "Habitat Age Requirement (years)", 
       y = "Proportion of Abandonment that is Suitable Habitat",
       color = "Site",
       subtitle = "Year: {round(frame_time, 0)}"
       ) + 
  transition_time(year)

anim_save(gg_hab_age_profile_animate,
       filename = paste0(p_plots, "habitat_age_profile_animated.gif"), 
       width = 550, height = 400, units = "px", 
)
```



# Fragmentation

Using the R package `landscapemetrics` (https://r-spatialecology.github.io/landscapemetrics/) to calculate various metrics related to landscape configuration, fragmentation, etc. Note that `landscapemetrics` uses calculates metrics from the popular FRAGSTATS program.

We seek to answer three primary questions:
1.	Are patches become more aggregated, connected? -- Clumpiness Index (Aggregation metric)
2.	Are patches getting larger? -- Mean Patch Area (area and edge metric)
3.	Are resulting habitats subject to less fragmentation? -- Perimeter-Area Ratio, mean (shape metric)

The below chunks include development of and analysis of data from "cluster/lsm_2024.R" and "cluster/lsm_two_2024.R"



```{r landscapemetrics-dev}

list_lsm(level = "class") %>% print(n = 55)

metrics_list <- c(
  "lsm_c_clumpy", # clumpiness index, class (aggregation metric)
  "lsm_c_area_mn", # patch area, mean, per class (area and edge metric)
  "lsm_c_para_mn" # perimeter-area ratio, mean (shape metric) # note, shape metrics take much more memory than others
)


# ------------------------------- set up test rasters --------------------------------------- #
site_df
input_r <- 
  #lcc[[6]][[31]]
  lcc[[9]]

plot(input_r)
ext(input_r)
test_ext <- draw(x="extent", col="red")
test_ext <- ext(c(111.187271305267, 111.256538167369, 38.8572368478675, 38.9201864595141))
test_r <- terra::crop(input_r, test_ext)
plot(test_r)

lcc_ext <- lapply(lcc, ext)

site_projections <- 
  lapply(lcc, function(x) as.vector(ext(x))) %>% 
  bind_rows() %>%
  bind_cols(site_df, .) %>%
  mutate(lon = round((xmin + xmax) / 2, 0),
         lat = round((ymin + ymax) / 2, 0),
         lat = case_when(
           site %in% c("goias", "mato_grosso") ~ 1,
           TRUE ~ lat
         ),
         proj = paste0("+proj=bonne +lon_0=", lon, " +lat_1=", lat)) %>%
  select(site, proj)

site_projections

```

```{r frag-trends}
# See "cluster/lsm_2024.R"
# See _util_files.R

frag_df %>%
  select(site, metric, layer) %>%
  unique() %>%
  pivot_wider(id_cols = c("site", "layer"), names_from = metric)


# Checking whether cluster script completed the landscapemetrics calculations
frag_df %>%
  select(site, metric, layer) %>%
  unique() %>%
  group_by(site, metric) %>%
  summarise(n = n()) %>%
  print(n = 40)



gg_frag_trends <-
  frag_df %>%
    filter(year > 1986, year < 2018, class > 1) %>%
    mutate(class = factor(class, levels = c(3, 4, 2)),
           metric = factor(metric, levels = c("clumpy", "area_mn", "para_mn"))) %>%
    ggplot(aes(x = year, y = value, col = class)) +
    geom_point() + 
    geom_smooth(method = "lm", se = 0.95) +
    geom_line() +
    theme_classic() + 
    scale_color_manual(labels = lc_plot_cols$name[c(3,4,2)],
                       values = lc_plot_cols$color[c(3,4,2)],
                       breaks = lc_plot_cols$breaks[c(3,4,2)]) +
    labs(y = "Value", x = "Year", col = "Land Cover"#, fill = "Mean Trend",
         ) + 
    facet_grid(cols = vars(site), rows = vars(metric), scales = "free_y",
               labeller = as_labeller(c(fancy_labels,
                                        "clumpy" = "Clumpiness Index\n(Aggregation)",
                                        "area_mn" = "Mean Patch Area",
                                        "para_mn" = "Perimeter-Area\nRatio"
                                        ))
               ) + 
    theme(
      legend.position = "bottom",
      axis.text.x = element_text(angle = 320, vjust = 1, hjust = 0),
      strip.text.x = element_text(size = 6)
      )

ggsave(gg_frag_trends,
       filename = paste0(p_output, "plots/", 
                           "frag_mod_trends", ".pdf"),
         width = 10, height = 5, units = "in"
       )


# -------------- by metric ------------- #

gg_frag_trends_clumpy <-
  frag_df %>%
    filter(year > 1986, year < 2018, class > 1, metric == "clumpy") %>%
    mutate(class = factor(class, levels = c(3, 4, 2)),
           metric = factor(metric, levels = c("clumpy", "area_mn", "para_mn"))) %>%
    ggplot(aes(x = year, y = value, col = class)) +
    geom_point() + 
    geom_smooth(method = "lm", se = 0.95) +
    geom_line() +
    theme_classic() + 
    scale_color_manual(labels = lc_plot_cols$name[c(3,4,2)],
                       values = lc_plot_cols$color[c(3,4,2)],
                       breaks = lc_plot_cols$breaks[c(3,4,2)]) +
    labs(y = "Clumpiness Index (Aggregation)", 
         x = "Year", col = "Land Cover") + 
    facet_wrap(vars(site), scales = "free_y",
               labeller = as_labeller(c(fancy_labels))) + 
  theme(legend.position = c(0.88, 0.13))

ggsave(gg_frag_trends_clumpy,
     filename = paste0(p_output, "plots/", 
                         "frag_mod_trends_clumpy", ".pdf"),
       width = 7, height = 5, units = "in"
     )
 

gg_frag_trends_area_mn <- frag_df %>%
  filter(year > 1986, year < 2018, class > 1, metric == "area_mn") %>%
  mutate(class = factor(class, levels = c(3, 4, 2)),
         metric = factor(metric, levels = c("clumpy", "area_mn", "para_mn"))) %>%
  ggplot(aes(x = year, y = value, col = class)) +
  geom_point() + 
  geom_smooth(method = "lm", se = 0.95) +
  geom_line() +
  theme_classic() + 
  scale_color_manual(labels = lc_plot_cols$name[c(3,4,2)],
                     values = lc_plot_cols$color[c(3,4,2)],
                     breaks = lc_plot_cols$breaks[c(3,4,2)]) +
  labs(y = "Mean Patch Area", 
       x = "Year", col = "Land Cover") + 
  facet_wrap(vars(site), scales = "free_y",
             labeller = as_labeller(c(fancy_labels))) + 
  theme(legend.position = c(0.88, 0.13))


 ggsave(gg_frag_trends_area_mn,
       filename = paste0(p_output, "plots/", 
                           "frag_mod_trends_area_mn", ".pdf"),
         width = 7, height = 5, units = "in"
       )
 
gg_frag_trends_para_mn <-
  frag_df %>%
  filter(year > 1986, year < 2018, class > 1, metric == "para_mn") %>%
  mutate(class = factor(class, levels = c(3, 4, 2)),
         metric = factor(metric, levels = c("clumpy", "area_mn", "para_mn"))) %>%
  ggplot(aes(x = year, y = value, col = class)) +
  geom_point() + 
  geom_smooth(method = "lm", se = 0.95) +
  geom_line() +
  theme_classic() + 
  scale_color_manual(labels = lc_plot_cols$name[c(3,4,2)],
                     values = lc_plot_cols$color[c(3,4,2)],
                     breaks = lc_plot_cols$breaks[c(3,4,2)]) +
  labs(y = "Perimeter-Area Ratio", 
       x = "Year", col = "Land Cover") + 
  facet_wrap(vars(site), scales = "free_y",
             labeller = as_labeller(c(fancy_labels))) + 
  theme(legend.position = c(0.88, 0.13))


ggsave(gg_frag_trends_para_mn,
       filename = paste0(p_output, "plots/", 
                         "frag_mod_trends_para_mn", ".pdf"),
       width = 7, height = 5, units = "in"
       )
```

```{r frag-lm}
frag_lm_test <- 
  frag_df %>%
  filter(year > 1986, year < 2018,
         class > 1,
         class == 2,
         site == "shaanxi",
         # metric == "area_mn"
         metric == "clumpy"
         # metric == "para_mn"
         ) %>%
  mutate(class = as_factor(class)) %>%
  lm(value ~ year, data = .)

tidy(frag_lm_test)


frag_nest <- 
  frag_df %>%
  filter(year > 1986, year < 2018,
         class > 1) %>%
  mutate(class = as_factor(class)) %>%
  group_by(site, metric, name, class) %>% nest()

frag_mod <- 
  frag_nest %>%
  mutate(model = map(data, function(df) {
    # lm(value ~ year, data = df)
    feols(value ~ year, data = df, vcov = vcov_NW(time = ~year)) # to account for temporal autocorrelation
    }),
         tidy = lapply(model, tidy, conf.int = TRUE),
         glance = lapply(model, glance))


# ------- plot heatmap -------- #

gg_frag_heatmap <- 
  frag_mod %>% 
  unnest(tidy) %>%
  filter(#site == "belarus", metric == "clumpy",
         term == "year"
  ) %>%
  select(class:site, term, estimate, p.value) %>%
  mutate(
    sig = p.value < 0.05,
    direction = estimate > 0,
    trend = case_when(
    estimate > 0 & p.value < 0.05 ~ "increase", # Statistically significant gain of AOH
    estimate < 0 & p.value < 0.05 ~ "decrease", # Statistically significant loss of AOH
    p.value >= 0.05 ~ "no trend" # no significant trend
    ),
    land_cover = case_when(
      class == 2 ~ "forest",
      class == 3 ~ "cropland",
      class == 4 ~ "grassland"
    ),
    land_cover = factor(land_cover, levels = c("cropland", "grassland", "forest")),
    metric = factor(metric, levels = c("clumpy", "area_mn", "para_mn"))) %>%
  
  # ggplot heatmap
  ggplot(aes(x = land_cover, y = fct_rev(site))) +
  geom_tile(aes(fill = trend)) +
  # geom_text(aes(label = round(AVGreturns, 3)))
  theme_classic() +
  scale_y_discrete(labels = fancy_labels) +
  scale_x_discrete(labels = c("cropland" = "Cropland",
                              "forest" = "Forest",
                              "grassland" = "Grassland")) +
  labs(x = "Land Cover", y = NULL, fill = NULL) +
  scale_fill_manual(name = "Linear Trend",
                  labels = frag_palette_labels,
                  values = frag_palette) +
  facet_wrap(vars(metric), 
             labeller = as_labeller(c(
               "clumpy" = "Clumpiness Index\n(Aggregation)",
               "area_mn" = "Mean Patch Area",
               "para_mn" = "Perimeter-Area\nRatio"
             ))) +
  theme(
    # legend.position = "bottom",
        axis.text.x = element_text(angle = 40, vjust = 1, hjust = 1)
)

ggsave(gg_frag_heatmap,
       filename = paste0(p_output, "plots/", 
                           "frag_mod_heatmap", ".pdf"),
         width = 6, height = 4.5, units = "in"
       )



# land cover colors: 
frag_mod %>% 
  unnest(tidy) %>%
  filter(#site == "belarus", metric == "clumpy",
         term == "year"
  ) %>%
  select(class:site, term, estimate, p.value) %>%
  mutate(
    sig = p.value < 0.05,
    direction = estimate > 0,
    trend = case_when(
    estimate > 0 & p.value < 0.05 ~ "increase", # Statistically significant gain of AOH
    estimate < 0 & p.value < 0.05 ~ "decrease", # Statistically significant loss of AOH
    p.value >= 0.05 ~ "no trend" # no significant trend
    ),
    land_cover = case_when(
      class == 2 ~ "forest",
      class == 3 ~ "cropland",
      class == 4 ~ "grassland"
    )) %>%
  # ggplot heatmap
  ggplot(aes(x = class, y = fct_rev(site))) +
  geom_tile(aes(alpha = sig, fill = class)) +
  geom_text(aes(label = round(estimate, 3))) +
  theme_classic() +
  scale_y_discrete(labels = fancy_labels) +
  labs(x = "Land Cover", y = NULL, fill = NULL) +
  scale_fill_manual(labels = lc_plot_cols$name,
                     values = lc_plot_cols$color, 
                     breaks = lc_plot_cols$breaks) +
  facet_wrap(vars(name))
  # facet_grid(cols = vars(site), rows = vars(metric), scales = "free_y",
                 # # labeller = as_labeller(fancy_labels)
                 # )
```


```{r hypo-2017}
# See "cluster/lsm_two_2024.R"

# For the year 2017, comparing the observed landscape with a hypothetical landscape
# in which all abandoned croplands remained in cultivation through 2017.
# This is in order to extract the impact of abandonment on fragmentation.
frag_hypo_df


# gg_frag_trends <-
  frag_hypo_df %>% mutate(id = "hypo") %>%
    bind_rows(frag_df %>% mutate(id = "obs")) %>%
    filter(class > 1, year == 2017) %>%
    mutate(class = factor(class, levels = c(3, 4, 2)),
           metric = factor(metric, levels = c("clumpy", "area_mn", "para_mn"))) %>%
    ggplot(aes(x = id, y = value, col = class, fill = class)) +
    geom_col(position = position_dodge(preserve = "single"),
             col = "black") + 
    theme_classic() + 
    scale_fill_manual(labels = lc_plot_cols$name[c(3,4,2)],
                       values = lc_plot_cols$color[c(3,4,2)],
                       breaks = lc_plot_cols$breaks[c(3,4,2)]) +
    labs(y = "Value", x = "Year", col = "Land Cover"#, fill = "Mean Trend",
         ) + 
    facet_grid(cols = vars(site), rows = vars(metric), scales = "free_y",
               labeller = as_labeller(c(fancy_labels,
                                        "clumpy" = "Clumpiness Index\n(Aggregation)",
                                        "area_mn" = "Mean Patch Area",
                                        "para_mn" = "Perimeter-Area\nRatio"
                                        ))
               ) + 
    theme(
      legend.position = "bottom",
      axis.text.x = element_text(angle = 320, vjust = 1, hjust = 0),
      strip.text.x = element_text(size = 6)
      )
  
  
  
  # just subtracting to two
frag_hypo_df %>% mutate(id = "hypo") %>%
    bind_rows(frag_df %>% mutate(id = "obs")) %>%
    filter(class > 1, year == 2017) %>%
    mutate(class = factor(class, levels = c(3, 4, 2)),
           metric = factor(metric, levels = c("clumpy", "area_mn", "para_mn"))) %>%
  select(id, class, metric, value, site, year) %>%
  pivot_wider(id_cols = c(class, metric, site, year),
              values_from = value, names_from = id) %>%
  mutate(diff = hypo - obs,
         trend = case_when(
    diff > 0 ~ "increase", # Statistically significant gain of AOH
    diff < 0 ~ "decrease" # Statistically significant loss of AOH
    ),
    land_cover = case_when(
      class == 2 ~ "forest",
      class == 3 ~ "cropland",
      class == 4 ~ "grassland"
    ),
    land_cover = factor(land_cover, levels = c("cropland", "grassland", "forest")),
    metric = factor(metric, levels = c("clumpy", "area_mn", "para_mn"))) %>%
  
  ggplot(aes(x = land_cover, y = fct_rev(site))) +
  geom_tile(aes(fill = trend)) +
  # geom_text(aes(label = round(AVGreturns, 3)))
  theme_classic() +
  scale_y_discrete(labels = fancy_labels) +
  scale_x_discrete(labels = c("cropland" = "Cropland",
                              "forest" = "Forest",
                              "grassland" = "Grassland")) +
  labs(x = "Land Cover", y = NULL, fill = NULL) +
  scale_fill_manual(name = "Linear Trend",
                  labels = frag_palette_labels,
                  values = frag_palette) +
  facet_wrap(vars(metric), 
             labeller = as_labeller(c(
               "clumpy" = "Clumpiness Index\n(Aggregation)",
               "area_mn" = "Mean Patch Area",
               "para_mn" = "Perimeter-Area\nRatio"
             ))) +
  theme(
    # legend.position = "bottom",
        axis.text.x = element_text(angle = 40, vjust = 1, hjust = 1)
)
```


# Ecoregions & Biomes

```{r ecoregions-2017}
# Ecoregion & Biome Data available from: https://ecoregions.appspot.com/
# Dinerstein, E. et al. An Ecoregion-Based Approach to Protecting Half the Terrestrial Realm. BioScience 67, 534–545 (2017).

tic()
ecoregions2017 <- st_read(paste0(p_dat, "Habitats/Ecoregions2017/Ecoregions2017.shp")) %>%
  st_make_valid()
toc() # 20 seconds about. (making the geometries valid is quick!)


# rename the column for WWF_MHTNAM to biome (this matches PREDICTS)
ecoregions <- ecoregions %>% mutate(biome = WWF_MHTNAM)
ecoregions %>% st_drop_geometry() %>% select(biome) %>% unlist(use.names = FALSE) %>% unique()



# simplify polygons:
ecoregions2017_simple <- st_simplify(ecoregions2017, dTolerance = 10000, preserveTopology = TRUE)
obj_size(ecoregions2017_simple)

# plot with Cook-Patton
plot(cook_patton_abg, col = brewer_pal(palette = "Greens")(9), colNA = "gray80")

# add just savannas in red:
ecoregions2017_simple %>% 
  select(ECO_NAME, BIOME_NAME) %>%
  filter(BIOME_NAME %in% grep("Savanna",
                         ecoregions2017_simple$BIOME_NAME,
                         value = TRUE, invert = FALSE)
         ) %>%
  st_geometry() %>% plot(border = "red", add = TRUE)

site_sf$geometry %>% plot(border = "orange", add= TRUE)


# crop to sites:
site_ecoregions2017 <- lapply(1:11, function(i) {
  temp <- st_crop(ecoregions2017, terra::ext(lc[[i]]))
  temp <- temp %>% mutate(site = site_df$site[i])
  temp
}) %>% bind_rows()

warnings()

plot(site_ecoregions2017$geometry)
obj_size(site_ecoregions2017)
site_ecoregions2017 %>% st_drop_geometry()
names(site_ecoregions2017)

site_ecoregions2017$ECO_NAME %>% unique()
site_ecoregions2017$BIOME_NAME %>% unique()



st_write(site_ecoregions2017, dsn = paste0(p_derived, "site_ecoregions2017.shp"))
site_ecoregions2017 <- st_read(paste0(p_derived, "site_ecoregions2017.shp"))

st_write(ecoregions2017_simple, dsn = paste0(p_derived, "ecoregions2017_simple.shp"))
ecoregions2017_simple <- st_read(paste0(p_derived, "ecoregions2017_simple.shp"))
```


```{r tnc-ecoregions}
# The Nature Conservancy's version of Ecoregions
# data available from: https://geospatial.tnc.org/datasets/b1636d640ede4d6ca8f5e369f2dc368b/about
# Note: this version was not used in the final analysis or publication. 
# Use this version only if you need to match to PREDICTS.
tic()
ecoregions <- st_read(paste0(p_dat, "Habitats/terr-ecoregions-TNC/tnc_terr_ecoregions.shp")) %>%
  st_make_valid()
toc() # 20 seconds about. (making the geometries valid is quick!)


# rename the column for WWF_MHTNAM to biome (this matches PREDICTS)
ecoregions <- ecoregions %>% mutate(biome = WWF_MHTNAM)
ecoregions %>% st_drop_geometry() %>% select(biome) %>% unlist(use.names = FALSE) %>% unique()

# union ecoregions within each biome
biome_names <- ecoregions %>% st_drop_geometry() %>% select(biome) %>% unlist(use.names = FALSE) %>% unique()
biome_l <- vector(mode = "list", length = 16L)
names(biome_l) <- biome_names

tic()
for(i in 1:16) {
  biome_l[[i]] <- ecoregions %>% 
    filter(biome == biome_names[i]) %>%
    st_union() %>%
    st_sf() %>%
    mutate(biome = biome_names[i])
}
toc() # took a bit of a while - maybe 60 seconds.

biomes <- bind_rows(biome_l)

# I tried aggregate, st_union, st_combine, merge, etc., and I couldn't find a simple way to dissolve an sf object based on an attribute, other than doing them all individually, then binding them back together. 


# save biomes sf file
st_write(biomes, dsn = paste0(p_dat, "Habitats/biomes.shp"))
save(biomes, file = paste0(p_dat, "Habitats/biomes.rds"))

biomes <- st_read(paste0(p_dat, "Habitats/biomes.shp"))

plot(st_geometry(biomes[4,]))


# Crop ecoregions to the sites:

site_ecoregions <- lapply(1:11, function(i) {
  temp <- st_crop(ecoregions, terra::ext(lc[[i]]))
  temp <- temp %>% mutate(site = site_df$site[i])
  temp
}) %>% bind_rows()

obj_size(site_ecoregions)
st_write(site_ecoregions, dsn = paste0(p_derived, "site_ecoregions.shp"))

site_ecoregions <- st_read(paste0(p_derived, "site_ecoregions.shp"))

```

```{r plot-ecoregions}

site_ecoregions %>% st_drop_geometry() %>%
  select(ECO_NAME, biome, site) %>%
  as_tibble() %>% print(n = 30)

site_ecoregions2017 %>% names()

site_ecoregions2017 %>% st_drop_geometry() %>%
  select(ECO_NAME, BIOME_NAME, site) %>%
  as_tibble() %>% print(n = 30)


# plot ecoregions by site:
  
i
gg_ecoregions_all <-
  ggplot(data = site_ecoregions %>%
           filter(site == site_df$site[i]), 
         aes(fill = str_wrap(ECO_NAME, 15))) +
  theme_classic() + 
  geom_sf() + 
  labs(fill = "Ecoregion") +
  theme(legend.position = "right"#,
        # legend.text = element_text(size = 7)
        ) #+ 
  # guides(fill = guide_legend(ncol = 2)) +
  # scale_fill_manual(values = biome_pal, labels = str_wrap(names(biome_pal), 24)
                    # ) + 
  # facet_wrap(vars(site), labeller = as_labeller(cap_update_labels))

gg_ecoregions_all_2017 <-
  ggplot(data = site_ecoregions2017 %>%
           filter(site == site_df$site[i]), 
         aes(fill = str_wrap(ECO_NAME, 15))) +
  theme_classic() + 
  geom_sf() + 
  labs(fill = "Ecoregion") +
  theme(legend.position = "right")
  
ecoregions_by_site <-
  lapply(1:11, function(i){
    ggplot(data = site_ecoregions %>% 
             filter(site == site_df$site[i]), 
           aes(fill = str_wrap(ECO_NAME, 15))) +
      theme_classic() + 
      geom_sf() + 
      labs(fill = NULL) +
      theme(legend.position = "right",
            axis.text.x = element_text(angle = 320, vjust = 1, hjust = 0)) + 
      guides(fill = guide_legend(ncol = 1)) + 
      # scale_fill_manual(labels = str_wrap(names(biome_pal), 24)) +
      # scale_fill_manual(values = biome_pal) + 
      facet_wrap(vars(site), labeller = as_labeller(cap_update_labels))
  })

gg_ecoregions_by_site_2017 <-
  lapply(1:11, function(i){
    ggplot(data = site_ecoregions2017 %>% 
             filter(site == site_df$site[i]), 
           aes(fill = str_wrap(ECO_NAME, 15))) +
      theme_classic() + 
      geom_sf() + 
      labs(fill = NULL) +
      theme(legend.position = "right",
            axis.text.x = element_text(angle = 320, vjust = 1, hjust = 0)) + 
      guides(fill = guide_legend(ncol = 1)) + 
      # scale_fill_manual(labels = str_wrap(names(biome_pal), 24)) +
      # scale_fill_manual(values = biome_pal) + 
      facet_wrap(vars(site), labeller = as_labeller(cap_update_labels))
  })


ggsave(plot = 
         # plot_grid(
           plot_grid(
             plotlist = ecoregions_by_site, 
             ncol = 4, nrow = 3),
           # as_ggplot(biome_legend),
           # nrow = 2, rel_heights = c(2, 0.2)),
       filename = paste0(p_plots, "ecoregions_by_site_wide.pdf"), 
    width = 15, height = 9, units = "in"
)

ggsave(plot = 
         # plot_grid(
           plot_grid(
             plotlist = gg_ecoregions_by_site_2017, 
             ncol = 4, nrow = 3),
           # as_ggplot(biome_legend),
           # nrow = 2, rel_heights = c(2, 0.2)),
       filename = paste0(p_plots, "ecoregions2017_by_site_wide.pdf"), 
    width = 15, height = 9, units = "in"
)


```

```{r plot-biomes}
# load biomes - see "tnc-ecoregions" chunk above
biomes <- st_read(paste0(p_dat, "Habitats/biomes.shp"))


ggplot() + theme_classic() + 
  geom_sf(data = biomes, aes(fill = biome))

# "Biomes ... are defined by The Nature Conservancy's terrestrial ecoregions of the world dataset"

# make a list of cropped biomes cropped to each site:
site_biomes <- lapply(1:11, function(i) {
  temp <- st_crop(biomes, ext(lc[[i]]))
  temp <- temp %>% mutate(site = site_df$site[i])
  temp
}) %>% bind_rows()

st_write(site_biomes, dsn = paste0(p_derived, "site_biomes.shp"))


site_biome_names <- site_biomes %>% 
  st_drop_geometry() %>% select(biome) %>% 
  arrange(biome) %>% unique() %>% .$biome

# all site - but facet_wrap doesn't work with geom_sf with free scales
ggplot() + theme_classic() + 
  geom_sf(data = site_biomes, aes(fill = biome)) + 
  # theme(axis.text.x = element_text(angle = 320, vjust = 1, hjust = 0)) +
  facet_wrap(vars(site))


biome_pal <- gg_color_hue(9)
names(biome_pal) <- site_biome_names

site_df
site_biomes %>% st_drop_geometry() %>% select(biome, site) %>%
  


str_wrap(names(biome_pal), 20)

site_biomes %>% 
  st_drop_geometry() %>% select(biome, site)
  
gg_biomes_all <-
  ggplot(data = site_biomes, aes(fill = biome)) +
  theme_classic() + 
  geom_sf() + 
  labs(fill = NULL) +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 7)) + 
  guides(fill = guide_legend(ncol = 2)) +
  scale_fill_manual(values = biome_pal, labels = str_wrap(names(biome_pal), 24)
                    ) + 
  facet_wrap(vars(site), labeller = as_labeller(cap_update_labels))

  
biomes_by_site <-
  lapply(1:11, function(i){
    ggplot(data = site_biomes %>% filter(site == site_df$site[i]), aes(fill = biome)) +
      theme_classic() + 
      geom_sf() + 
      labs(fill = NULL) +
      theme(legend.position = "none",
            axis.text.x = element_text(angle = 320, vjust = 1, hjust = 0)) + 
      guides(fill = guide_legend(ncol = 1)) + 
      scale_fill_manual(values = biome_pal) + 
      facet_wrap(vars(site), labeller = as_labeller(cap_update_labels))
  })

biome_legend <- ggpubr::get_legend(gg_biomes_all + 
                                     guides(fill = guide_legend(nrow = 2)) +
                                     theme(legend.position = "bottom"))

ggsave(plot = 
         plot_grid(
           plot_grid(plotlist = biomes_by_site, ncol = 4, nrow = 3),
           as_ggplot(biome_legend),
           nrow = 2, rel_heights = c(2, 0.2)),
       filename = paste0(p_plots, "biomes_by_site.pdf"), 
    width = 7.5, height = 6.75, units = "in"
)


# ------------------------------------------------------------ #
# Ecoregions 2017 - biomes
# ------------------------------------------------------------ #

biome2017_pal <- gg_color_hue(9)
names(biome2017_pal) <- site_ecoregions2017 %>% 
  st_drop_geometry() %>% select(BIOME_NAME) %>% 
  arrange(BIOME_NAME) %>% unique() %>% .$BIOME_NAME


gg_biomes2017_by_site <-
  lapply(1:11, function(i){
    ggplot(data = site_ecoregions2017 %>% 
             filter(site == site_df$site[i]), 
           aes(fill = BIOME_NAME)) +
      theme_classic() + 
      geom_sf() + 
      labs(fill = NULL) +
      theme(legend.position = "none",
            axis.text.x = element_text(angle = 320, vjust = 1, hjust = 0)) + 
      guides(fill = guide_legend(ncol = 1)) + 
      scale_fill_manual(values = biome2017_pal) + 
      facet_wrap(vars(site), labeller = as_labeller(cap_update_labels))
  })

gg_biomes2017_all <-
  ggplot(data = site_ecoregions2017, aes(fill = BIOME_NAME)) +
  theme_classic() + 
  geom_sf() + 
  labs(fill = NULL) +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 7)) + 
  guides(fill = guide_legend(ncol = 2)) +
  scale_fill_manual(values = biome2017_pal, 
                    labels = str_wrap(names(biome2017_pal), 24)
                    ) + 
  facet_wrap(vars(site), labeller = as_labeller(cap_update_labels))

biome2017_legend <- ggpubr::get_legend(gg_biomes2017_all + 
                                     guides(fill = guide_legend(nrow = 2)) +
                                     theme(legend.position = "bottom"))

ggsave(plot = 
         plot_grid(
           plot_grid(plotlist = gg_biomes2017_by_site, ncol = 4, nrow = 3),
           as_ggplot(biome2017_legend),
           nrow = 2, rel_heights = c(2, 0.2)),
       filename = paste0(p_plots, "biomes2017_by_site.pdf"), 
    width = 7.5, height = 6.75, units = "in"
)


```
