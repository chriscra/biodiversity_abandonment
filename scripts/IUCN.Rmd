---
title: "IUCN data prep"
author: "Christopher L. Crawford"
output: html_document
editor_options: 
  chunk_output_type: console
---

This script is part of the **Effects of cropland abandonment on biodiversity** project, developed by Christopher L. Crawford (chris.L.crawford@gmail.com) at Princeton University beginning in Fall 2021.
See https://github.com/chriscra/biodiversity_abandonment.

This document contains code used in the prep and development of IUCN data used in the calculation of AOH, including both tabular assessment data (.csvs) and spatial range map data (sf objects).

Components include:

1. IUCN Basics, loading IUCN status and IUCN / Yin et al. Land Cover crosswalk, which are relevant for later code. 
2. Exploring and prepping the [IUCN](https://www.iucnredlist.org/resources/spatial-data-download) / [BirdLife International](https://datazone.birdlife.org/home) range maps after their processing on the cluster
3. Loading IUCN Red List Assessment data, including habitat and elevational preferences.
4. Determining species' habitat age requirements, in order to filter out any species that require habitats older than 30 years (our study length), which we consider to be "mature-forest obligate species."
5. Miscellaneous development code retained in case it's useful for future Chris. 


Relevant cluster scripts include:
- **crop_sp_ranges_array.R** loads, filters, validates, crops, and saves species range maps. Because bird range maps have so many verticies (many shorelines), they required more specialized code to handle (below), but if you have the computing power and time, this script can be run in place of the follow scripts.
- **crop_mammal_ranges.R** [optional, development] does the same as "crop_sp_ranges_array.R," but only for mammal species (if birds are done separately, so too can mammals).
- **save_bird_ranges_as_blocks.R** calculates the number of vertices in each range, then saves small blocks of bird ranges based on the number of vertices in each range.
- **validate_bird_ranges_array.R** sequentially loads and validates the bird range chunks produced in the previous script.
- **merge_crop_bird_ranges.R** loads, merges, and crops all individual bird ranges to site locations.
- **calc_range_area.R** with validated range maps for both brids and mammals, this script loads the validated ranges, calculates the area of each range polygon, and crops to sites again. 

s
```{r initialize}
source("/Users/christophercrawford/work/projects/biodiversity_abn/scripts/0_start.R")
```

```{r load-files}
source("/Users/christophercrawford/work/projects/biodiversity_abn/scripts/_util/_util_files.R")
```

```{r clean-up}
os <- get_sizes(ls())

os %>% 
  summarise(total_env_size = sum(size)) %>% 
  mutate(gb = total_env_size / 1024^3)

os
os %>% print(n = 30)

rm(list = os$object[c(1:6)])
# rm(list = os$object[c(3:18)])
get(os$object[c(30)])

# terra and raster temp files
terra::tmpFiles(current=TRUE, orphan=TRUE, old=TRUE, remove=FALSE)
terra::tmpFiles(current=TRUE, orphan=TRUE, old=TRUE, remove=TRUE)

raster::rasterTmpFile()
raster::showTmpFiles()
raster::removeTmpFiles()

warnings()
```

# 1. IUCN Basics

These data are needed for the range map scripts below.

```{r IUCN-status}
iucn_status <- lapply(c("LC", "nonLC"), function(i) {
  read_csv(
    file = paste0(p_dat, "bd/IUCN/redlist_2022_01_04_animalia_", i,
                  "/simple_summary.csv")#, n_max = 10
  )
}) %>% 
  bind_rows() %>%
  select(className, 
         binomial = scientificName,
         redlistCategory) %>%
  filter(className %in% c("AMPHIBIA", "AVES", "MAMMALIA", "REPTILIA")) %>%
  arrange(className, binomial)

write_csv(iucn_status, file = paste0(p_derived, "iucn_status.csv"))

iucn_status

iucn_status %>% filter(binomial %in% species_ranges$binomial)
select(habitat_details, binomial, redlistCategory)
```


```{r load-IUCN-crosswalk}
# ---------------------------------------------- #
# Jung IUCN habitat types map crosswalk
# ---------------------------------------------- #

# *** see "_util_files.R" to load the final version of this ***


# development
# iucnHabitatTranslator <- read_csv(paste0(p_proj, "/resources/IUCNhabitatMap_translator.csv"))
# 
# iucn_crosswalk <- read_csv(paste0(p_derived, "iucn_lc_crosswalk.csv")) %>%
#   left_join(iucnHabitatTranslator, by = "map_code") %>% 
#   arrange(map_code)
# 
# iucn_crosswalk %>% write_csv(paste0(p_derived, "iucn_lc_crosswalk.csv"))

# *** see "_util_files.R" to load the final version of this ***

iucn_crosswalk

iucn_crosswalk %>% 
  print(n = 50)

nrow(iucn_crosswalk)
iucn_crosswalk$code %>% unique %>% length()
```

# 2. IUCN Range Map Data

The first step is to crop vertebrate species range maps to my eleven sites.
This ends up being more complicated than you'd expect!
In order to crop vertebrate species ranges maps to site extents, however, they must first be "validated" - a time consuming process, especially for large range maps with many vertices (which end up being very computationally taxing).
I wrote scripts to process these range maps using Princeton's Research Computing resources (the "della" cluster).

The script */cluster/crop_sp_ranges_array.R* is designed to:
- load the range maps for a specific class (i.e., mammals, birds, etc.), as determined by the array index supplied in the sbatch call. 
- filter based on IUCN information on "presence", "origin", "seasonal", and (where applicable) IUCN "category", and "marine".
- validate polygons via `sf::st_make_valid()`
- crop to site extents
- save validated and cropped range maps to:
  + paste0(p_derived, vert, "_sites.csv")
  + paste0(p_derived, vert, "_sites.shp")
  + paste0(p_derived, vert, "_sites.RData")
  + paste0(p_range, vert, "_sf_validated.RData")

Bird ranges present a trickier problem than mammals or amphibians, given the size of many bird ranges.
This required three steps:  
- */cluster/save_bird_ranges_as_blocks.R*: calculate the number of vertices in each range, then save small blocks of bird ranges based on the number of vertices in each range. `r c("_1_70", "_70_80", "_80_90", paste0("_", 90:98, "_", 90:98 + 1), paste0("_", 990:998, "_", 990:998 + 1), paste0("_", 9990:9999, "_", 9990:9999 + 1))`
- */cluster/validate_bird_ranges_array.R*: sequentially load and validate the bird range chunks produced in the previous script. 
- */cluster/merge_crop_bird_ranges.R*: load, merge, and crop all individual bird ranges to site locations, yielding the following:
  + paste0(p_range, "bird_sf_validated", ".RData") - "bird_sf_validated," or all ranges validated, with the number of vertices listed as a column.
  + paste0(p_derived, "bird_sites.csv") - just the attribute table of the cropped ranges below.
  + paste0(p_derived, "bird_sites.RData") - bird ranges cropped to 11 sites.

A final step included:
- */cluster/calc_range_area.R*: loading the validated ranges, calculating area of each range polygon, and cropping to sites again. 

Together, these cleaning steps yielded prepped range map files:

```{r cluster-files}
# _sf_validated.RData and _sf_validated.csv
paste0(p_dat, "bd/IUCN/ranges_2022_01_04") %>% list.files()

# _sites.Rdata and _sites.csv
paste0(p_derived, "species_ranges") %>% list.files()
```


```{r validated-range-maps}
# optional: if you want to load and explore the validated species ranges (caution, these files are large!)

# load(paste0(p_dat, "bd/IUCN/ranges_2022_01_04/mam_sf_validated.RData"), verbose = TRUE)
load(paste0(p_dat, "bd/IUCN/ranges_2022_01_04/mam_sf_validated_2022_03_23.RData"), verbose = TRUE)
load(paste0(p_dat, "bd/IUCN/ranges_2022_01_04/bird_sf_validated_2022_03_23.RData"), verbose = TRUE)


mam_sf_validated %>%
  st_drop_geometry() %>% as_tibble() %>%
  select(class, marine) %>% unique()

rm(mam_sf_validated)
```

```{r load-and-bind-cropped-ranges}
# load vertebrate species range maps that have been prepped on the cluster and bind them together into one single file: "vert_sites.RData"

vert_list <- c("amp", "bird", "mam", "gard")

paste0(p_derived, "species_ranges") %>% list.files()

species_files <- list.files(paste0(p_derived, "species_ranges"), full.names = TRUE)

# load(paste0(p_derived, "species_ranges/amp_sites.RData"), verbose = T)
# a0 <- range_sites
load(paste0(p_derived, "species_ranges/amp_sites.RData"), verbose = T)
# a1 <- amp_sites
# identical(a0 %>% st_drop_geometry() %>% as_tibble(),
          # a1 %>% select(any_of(names(a0))) %>% st_drop_geometry() %>% as_tibble())
# confirmed that they match the old cropped ranges
amp_sites <- amp_sites %>% 
  mutate(vert_class = "amp")

# load(paste0(p_derived, "species_ranges/bird_sites.RData"), verbose = T)
load(paste0(p_derived, "species_ranges/bird_sites.RData"), verbose = T)
bird_sites <- bird_sites %>% 
  mutate(vert_class = "bird")

# load(paste0(p_derived, "species_ranges/mam_sites.RData"), verbose = T)
load(paste0(p_derived, "species_ranges/mam_sites.RData"), verbose = T)
mam_sites <- mam_sites %>% 
  mutate(vert_class = "mam")

load(paste0(p_derived, "species_ranges/gard_sites.RData"), verbose = T)
gard_sites <- range_sites %>% 
  mutate(vert_class = "gard")
rm(range_sites)



# ------------------------------------------------------------------------ #
# Select and rename columns to facilitate join:
# ------------------------------------------------------------------------ #
names(amp_sites)
names(mam_sites)
names(bird_sites)
names(gard_sites)

# birds and gard need to be updated:
# note, mam and amp columns match perfectly
names(mam_sites) == names(amp_sites) 

amp_mam_col_selection <- c(
  "id_no", "site", "vert_class", "binomial", 
  "category", "presence", "origin", "seasonal", 
  "marine", "terrestrial" = "terrestial", "freshwater",
  "class", "order_", "family", "genus", "subspecies", 
  "yrcompiled",
  "legend", "is_valid" = "pre_valid_reasons",
  "area_km2", "total_range_area", "n_polygons", 
  "range_rank", "n_species", "range_size_quantile"
  )

bird_col_selection <- c(
  "id_no", "site", "vert_class", "binomial" = "sci_name", 
  "presence", "origin", "seasonal", 
  "yrcompiled", "yrmodified", "version",
  "is_valid", "vertices", "block",
  # "geometry" = "Shape",
  "area_km2", "total_range_area", "n_polygons", 
  "range_rank", "n_species", "range_size_quantile"
)

gard_col_selection <- c(
  "key", "site", "vert_class", "binomial", 
  "category" = "redlistCategory",
  "group" = "Group",
  "is_valid" = "pre_fix_reasons",
  "area_km2", "range_size_quantile"
)

# -------------- bind rows: ---------------- #

vert_sites <- bind_rows(
  amp_sites %>% select(amp_mam_col_selection),
  bird_sites %>% select(bird_col_selection),
  mam_sites %>% select(amp_mam_col_selection),
  gard_sites %>% select(gard_col_selection)
  )


# add iucn status to range maps:
vert_sites <- 
  vert_sites %>% 
  # st_drop_geometry() %>% as_tibble() %>%
  left_join(iucn_status, by = "binomial") %>%
  mutate(category = redlistCategory) %>% 
  select(-c(redlistCategory, class)) 

save(vert_sites, file = paste0(p_derived, "species_ranges/vert_sites.RData"))

```

```{r load-vert_sites}
# cropped range maps
load(file = paste0(p_derived, "species_ranges/vert_sites.RData"), verbose = TRUE)
```

```{r species-ranges}
# filter vert_sites to a subset called "species_ranges", for use in AOH code.


# filter species by attributes: presence, origin, seasonal, marine, and category (redlistCategory)
# see: https://nc.iucnredlist.org/redlist/resources/files/1539614211-Mapping_attribute_codes_v1.16_2018.pdf

# presence == 1 # (extant species only). 
# --- Other unused codes are: 2. Probably Extant (discontinued, ambiguous), 3. Possibly Extant 4. Possibly Extinct, 5. Extinct, 6. Presence Uncertain.

# origin %in% c(1, 2) # (native and reintroduced species respectively). 
# --- Other unused codes are: 3. Introduced, 4. Vagrant, 5. Origin Uncertain, 6. Assisted Colonisation.

# seasonal %in% c(1, 2, 3, 4) # including passage areas
# --- Codes are: "Resident" (1), "Breeding" (2), "Non-breeding Season" (3), Passage (4), and Seasonal Occurrence Uncertain (5).

# marine: != true # all species but marine species
# only required for amphibians and mammals (birds and reptiles do not have this column)

# !category %in% c("Extinct", "Extinct in the Wild") # 
# filter out Extinct or Extinct in the Wild species ("EX", "EW")


# number of species in each seasonal type
vert_sites %>% 
  st_drop_geometry() %>% as_tibble() %>%
  group_by(seasonal, className) %>% summarise(n_sp = n()) %>% arrange(className)

vert_sites$marine %>% unique()

# --------------------------------------------------- #
# create species_ranges, a subset of vert_sites
# --------------------------------------------------- #

species_ranges <-
  vert_sites %>% 
  # st_drop_geometry() %>% as_tibble() %>%  # for testing only
  filter(vert_class != "gard") %>%
  
  # filter based on presence, origin, seasonal, marine, category
  filter(presence == 1,
         origin %in% c(1, 2), 
         seasonal %in% c(1, 2, 3, 4), # now including passage areas too
         !category %in% c("Extinct", "Extinct in the Wild"),
         marine %in% c("false", NA))

save(species_ranges, file = paste0(p_derived, "species_ranges/species_ranges.RData"))

load(file = paste0(p_derived, "species_ranges/species_ranges.RData"), verbose = TRUE)

species_ranges %>% 
  st_drop_geometry() %>% as_tibble() %>% 
  select(site:seasonal) #%>% filter(!is.na(synonym))


species_list$binomial %>% unique() %>% length() # 2188 species
species_list %>% nrow() # 3979 unique runs
species_ranges$binomial %>% unique %>% length # 2230 # no species were removed


plot(site_sf %>% filter(site == "shaanxi") %>% st_geometry())
species_ranges %>% filter(binomial == "Panthera pardus") %>%
  st_geometry() %>% plot(border = "red", add = T)


plot(site_sf %>% filter(site == "shaanxi") %>% st_geometry())
species_ranges %>% filter(binomial == "Panthera pardus") %>%
  st_geometry() %>% plot(border = "red", add = T)

species_ranges %>% filter(binomial == "Pteronura brasiliensis") %>% st_drop_geometry()
aoh_trends %>% filter(binomial == "Pteronura brasiliensis")

plot(site_sf %>% filter(site == "mato_grosso") %>% st_geometry())
species_ranges %>% filter(binomial == "Pteronura brasiliensis") %>%
  st_geometry() %>% plot(border = "red", add = T)

```


# 3. Load IUCN Assessment Data

```{r habitat_prefs}
# make sure this loads with the most recent species_ranges (i.e., with fixed synonyms)
habitat_prefs <- lapply(c("LC", "nonLC"), function(i) {
  read_csv(
    file = paste0(p_dat, 
                  "bd/IUCN/redlist_2022_01_04_animalia_",
                  i, "/habitats.csv")#, n_max = 10
  ) %>% 
    select(binomial = scientificName, code, name:suitability, assessmentId, internalTaxonId)
}) %>% 
  bind_rows() %>% 
  filter(binomial %in% unique(species_ranges$binomial)) %>%
  
  # update: add map_code to habitat_prefs for more exact filtering and joining.
  left_join(iucn_crosswalk, by = "code") %>%
  
  # update season_code:
  # --- Codes are: "Resident" (1), "Breeding" (2), "Non-breeding Season" (3), Passage (4), and Seasonal Occurrence Uncertain (5).
  mutate(season_code = case_when(
    grepl("resident", season, ignore.case = TRUE) ~ 1,
    season %in% c("breeding", "Breeding Season") ~ 2,
    season %in% c("non-breeding", "Non-Breeding Season") ~ 3,
    grepl("passage", season, ignore.case = TRUE) ~ 4,
    grepl("unknown", season, ignore.case = TRUE) ~ 5
    )) %>%
  
  # update prefers for Glaucidium brodiei (collared owlet) and Mustela sibirica (siberian weasel)
  mutate(season_code = ifelse(is.na(season_code) & 
                                !is.na(map_code) &
                                suitability == "Suitable" &
                                binomial %in% c("Glaucidium brodiei", "Mustela sibirica"),
                              1, season_code))


# habitat_prefs %>% select(season_code,season) %>% arrange(season_code) %>% unique()


# "code" is now listed as character, so don't have any issue matching:
habitat_prefs %>% 
  filter(code %in% c("5.1", "5.10")) %>% 
  select(map_code, code, name) %>% unique()

habitat_prefs %>% select(map_code, code, name) %>% unique() %>% arrange(map_code) %>%
  print(n = 105)

iucn_crosswalk %>% select(map_code, code) %>% unique() # unique()


# habitat_details

habitat_details <- lapply(c("LC", "nonLC"), function(i) {
  read_csv(
    file = paste0(p_dat, "bd/IUCN/redlist_2022_01_04_animalia_", i, "/assessments.csv")#, n_max = 10
  ) %>% 
    select(binomial = scientificName, redlistCategory, rationale, habitat, threats, population)
}) %>% 
  bind_rows() %>% 
  filter(binomial %in% unique(species_ranges$binomial))

# ----------------
# save updated file
# ----------------
write_csv(habitat_prefs, file = paste0(p_derived, "iucn_habitat_prefs_subset.csv"))
write_csv(habitat_details, file = paste0(p_derived, "iucn_habitat_details_subset.csv"))
```

```{r elevation_prefs}
# ---------------------------------------------------------- #
### Loading elevation data ####

elevation_prefs <- lapply(c("LC", "nonLC"), function(i) {
  read_csv(
    file = paste0(p_dat, "bd/IUCN/redlist_2022_01_04_animalia_", i, "/all_other_fields.csv")#, n_max = 10
    ) %>%
    select(binomial = scientificName, 
           elevation_lower = ElevationLower.limit,
           elevation_upper = ElevationUpper.limit)
}) %>% 
  bind_rows() %>%
  
  # extract records for only those species of interest 
  filter(binomial %in% unique(species_ranges$binomial)) %>%
  
  # update elevation to account for NA
  mutate(elevation_lower = ifelse(is.na(elevation_lower), 0, elevation_lower),
         elevation_upper = ifelse(is.na(elevation_upper), 9999, elevation_upper)
         )

#
elevation_prefs %>%
  filter(elevation_upper == 0)

# Rana temporaria has its upper and lower elevations mixed up.
# Fix.
elevation_prefs <- elevation_prefs %>%
  mutate(elevation_lower = ifelse(binomial == "Rana temporaria",
                                  0, elevation_lower),
         elevation_upper = ifelse(binomial == "Rana temporaria",
                                  2700, elevation_upper)
  ) #%>% filter(binomial == "Rana temporaria")



elevation_prefs %>% 
  mutate(check = elevation_upper - elevation_lower) %>%
  filter(check < 0)


# ----------------
# save updated file
# ----------------

write_csv(elevation_prefs, file = paste0(p_derived, "iucn_elevation_prefs_subset.csv"))
```



```{r species_list}
# --------------------------------------------------- #
# create species_list, a list of unique species-site combinations at my sites,
# which can then be used to specify which species to run through the aoh scripts on the HPC.
# --------------------------------------------------- #

# ------------------------------------------------------------- #
# Step. 1
# extract species list from species_ranges (which has already been filtered)
# ------------------------------------------------------------- #

species_list <- species_ranges %>%
  st_drop_geometry() %>% as_tibble() %>%
  select(site, vert_class, binomial, category) %>%
  arrange(site, vert_class, binomial, category) %>% 
  unique() 

# at this stage:
# number of unique runs:
species_list %>% nrow() # 4310 (old: 4038)

# number of unique species (pre filtering by habitat, elevation)
species_list$binomial %>% unique() %>% length # 2312 (old: 2230)

# number of species in each class at each site
species_list %>% 
  group_by(site, vert_class) %>% 
  summarise(num_sp = n()) 

# update based on habitat suitability

# ----------------
# fix and filter based on habitat suitability and presence (must load habitat_prefs - see below)
# ----------------
species_list$binomial %>% unique() %>% length # 2312 (old: 2230)
habitat_prefs$binomial %>% unique() %>% length() # 2312 (old: 2229)


suitable_sp <- habitat_prefs %>%  # having loaded habitat_prefs for all 2229 species
  filter(binomial %in% species_ranges$binomial,  # note, this is uncessary, if habitat_prefs has already been subset by species_list
         suitability == "Suitable") %>%
  .$binomial %>% unique()

habitat_prefs %>% filter(is.na(suitability)) %>% .$binomial %>% unique()

length(suitable_sp) # 2309 (old:2226)

tmp_sp <- species_list %>%
  filter(!binomial %in% suitable_sp) %>% 
  .$binomial %>% unique()

tmp_sp
# Exclude all species to be conservative.
# Two of these three excluded species have unknown suitabilities.
# The third, has NA suitability - it simply wasn't noted in the assessment.
habitat_prefs %>% filter(binomial %in% tmp_sp)
# "Promops nasutus" # brown mastiff bat, unknown suitability, data deficient. https://www.iucnredlist.org/species/18341/22035986
# "Bufotes variabilis" # varying toad, not enough known about habitat and natural history: https://www.iucnredlist.org/species/153571/74506381
# "Myospalax aspalax" # false zokor, seems to have simply been left out of assessment (NA) https://www.iucnredlist.org/species/14116/115120685
iucn_status %>% filter(binomial %in% tmp_sp)



habitat_prefs %>% filter(binomial %in% suitable_sp) # extract the habitat classifications for the species in question
habitat_prefs$suitability %>% unique()


# filter to just those species with a) suitable habitat that b) occurs at one of the sites.
# this excludes 36 species
species_w_habitat <- 
  habitat_prefs %>% 
  filter(suitability == "Suitable",
         code %in% jung_hab_type_area_df$code)

suitable_sp %>%  unique() %>% length() # 2309
species_w_habitat %>% .$binomial %>% unique() %>% length() # 2273 (old: 2188 including all habitat_prefs)

# which species get removed?
species_without_habitat <- species_list %>% 
  filter(!binomial %in% unique(species_w_habitat$binomial)) 

species_without_habitat %>% .$binomial %>% unique() %>% sort()

# ------------------------------------------------------------- #
# Step. 2
# Further filter species_list to exclude those site-species combinations where that species does not have any habitat
# ------------------------------------------------------------- #

# this initial version leaves species at sites that don't have habitat, as long as some other site has habitat for that species
# species_list <- species_list %>%
#   # filter(binomial %in% species_w_habitat$binomial) # also works
#   filter(binomial %in% 
#            unique(filter(habitat_prefs, 
#                          suitability == "Suitable",
#                          code %in% jung_hab_type_area_df$code)$binomial))

# Sequentially figure out which species have habitat at each specific site, and filter to those
# i <- 5
species_to_remove <- lapply(1:11, function(i){
  site_habitats_tmp <- sort(filter(jung_hab_type_area_df, site == site_df$site[i])$habitat_type)
  site_species <- sort(filter(species_list, site == site_df$site[i])$binomial)
  
  # a list of species at a given site, with habitat at that site
  species_with_habitat_at_site <- habitat_prefs %>% 
    filter(binomial %in% site_species,
           suitability == "Suitable",
           map_code %in% site_habitats_tmp) %>% 
    .$binomial %>% unique()
  
  species_list %>% st_drop_geometry() %>%
  filter(site == site_df$site[[i]],
         !binomial %in% species_with_habitat_at_site)
}) %>% bind_rows()




# ------ update species_list again -------- #
species_list <- lapply(1:11, function(i){
  site_habitats_tmp <- sort(filter(jung_hab_type_area_df, site == site_df$site[i])$code)
  site_species <- sort(filter(species_list, site == site_df$site[i])$binomial)
  
  # a list of species at a given site, with habitat at that site
  species_with_habitat_at_site <- 
    habitat_prefs %>%
    filter(binomial %in% site_species,
           suitability == "Suitable",
           code %in% site_habitats_tmp) %>% 
    .$binomial %>% unique()
  
  species_list %>% 
  filter(site == site_df$site[[i]],
         binomial %in% species_with_habitat_at_site)
}) %>% bind_rows()

# 4310 rows before filtering
# 4079 rows after filtering

# ------------------------------------------------------------- #
# Step. 3
# Further filter species_list to exclude those species appropriate elevations at each site
# ------------------------------------------------------------- #

site_elevation_range <- tibble(
  site = site_df$site,
  min = sapply(1:11, function(i) {minmax(elevation_map[[i]])[, 1]})[1,],
  max = sapply(1:11, function(i) {minmax(elevation_map[[i]])[, 1]})[2,],
  )

# manually check to make sure the elevation filtering works right:
for (i in 1:11) {
  cat("species outside the elevational limit at:", site_df$site[i], fill = TRUE)
  print(site_elevation_range[i, ])
  print(
    elevation_prefs %>% 
      
      # filter to those species present at a given site:
      filter(binomial %in% filter(species_list, site == site_df$site[i])$binomial,
             # species whose lower limit is greater than the site max elevation
             # or less than the minimum elevation
             (elevation_lower > site_elevation_range[i,]$max |
                elevation_upper < site_elevation_range[i,]$min)))
  }


# ---------------------- filter species_list --------------------- #
species_list <- lapply(1:11, function(i) {
  sp_within_elevational_range <- 
    elevation_prefs %>% 
      filter(binomial %in% filter(species_list, site == site_df$site[i])$binomial,
             # species whose lower limit is NOT greater than the site max elevation
             # NOR less than the minimum elevation
             !(elevation_lower > site_elevation_range[i,]$max |
                elevation_upper < site_elevation_range[i,]$min))
  
  species_list %>% 
    filter(site == site_df$site[[i]],
           binomial %in% sp_within_elevational_range$binomial
           )
}) %>% bind_rows()


species_ranges$binomial %>% unique %>% length # 2312 species

# final counts
species_list$binomial %>% unique %>% length # 2187 species
species_list %>% nrow() # 4001 unique runs

# number of species in each class at each site
species_list %>% 
  group_by(site, vert_class) %>% 
  summarise(num_sp = n()) 
```

```{r parallelize-aoh-for-hpc}

# ------------------------------------------------------------- #
# Step. 4
# Parallelize species_list, with core index assignments
# ------------------------------------------------------------- #

species_list

# examine test results from the cluster:
aoh_dt_11_test
aoh_31_df %>% select(site, binomial, time) %>% unique()

aoh_dt_11_test %>% 
  select(site, binomial, time) %>% unique() %>% print(n = 200)


comparing_times <- lapply(c("aoh_lc_df", "aoh_abn"), function(i) {
  get(i) %>%
    select(site, binomial, time) %>% unique() %>%
    group_by(site) %>%
    summarise(max_time = max(time),
              mean_time = mean(time)) %>% 
    mutate(type = i,
           time_rel_max_mx = max_time / max(max_time),
           time_rel_max_mn = mean_time / max(mean_time),
           ncell = sapply(1:11, function(i) {ncell(lcc[[i]])}),
           ncell_rel_max = ncell / max(ncell),
           factor_mx = pmax(time_rel_max_mx, ncell_rel_max),
           record_multiplier_mx = max(factor_mx)/factor_mx,
           record_multiplier_mn = max(time_rel_max_mn)/time_rel_max_mn,
           )
  }) %>% bind_rows()


# time scales linearly with the number of cells
# so, I can run about X times as many records at smaller sites.

comparing_times$type %>% unique()

comparing_times %>% 
  filter(
    type == "aoh_lc_df"
    # type == "aoh_abn"
    ) %>%
  select(site, max_time, mean_time, ncell, time_rel_max_mx, ncell_rel_max, factor_mx, record_multiplier_mn)


vert_sites %>%
  st_drop_geometry() %>%
  filter(vert_class != "gard") %>%
  select(site, vert_class, binomial) %>%
  unique() %>% as_tibble() %>% nrow()

# 4340 unique site-vert records, before filtering

species_list %>% nrow() # 4001 unique runs, after filtering

records_by_site <- species_list %>%
  group_by(site) %>% summarise(runs = length(unique(binomial)))


# calculate the number of cores, across a range of batch sizes
core_tests <-
  lapply(80:190, function(i) {
  tmp <- 
    comparing_times %>%
    select(site, type, max_time, mean_time, 
           # it takes x times longer for a species run in a given site, 
           # relative to the largest site
           record_multiplier = record_multiplier_mn) %>%
    left_join(records_by_site, by = "site") %>%
    mutate(block_size = i,
           sp_per_core = i * record_multiplier, # how many species can be run at a given sites core
           cores_needed = runs/sp_per_core,
           cores_rounded = ceiling(cores_needed),
           runs_per_core = ceiling(runs/cores_rounded),
           hr_if_max = runs_per_core * max_time / 60 / 60,
           hr_if_mean = runs_per_core * mean_time / 60 / 60,         
           diff = cores_rounded - cores_needed)   
  
  tmp <- tmp %>% 
    group_by(type) %>% 
    summarise(block_size = unique(block_size),
              num_cores = sum(cores_rounded),
              diff = sum(diff),
              mean_time_needed_mn = mean(hr_if_mean),
              mean_time_needed_mx = mean(hr_if_max))
  
  tmp
  }) %>% bind_rows

core_tests %>% arrange(diff) %>% print(n = 40)
core_tests %>% filter(block_size == 186)
core_tests_lc %>% arrange(diff) %>% print(n = 20)

# best mix of size and time, minimizing "unused" cores, and minimizing cores:
# full lc: 105 runs per core, 22 cores
# abn only: 114 runs per core, 30 cores

block_sizes <- tibble(type = c("abn", "lc"), 
                      block = c(114, 105))

i <- "abn"
calc_cores <-
  lapply(c("abn", "lc"), function(i) {
    comparing_times %>% 
      filter(grepl(i, type)) %>%
      select(site, max_time, mean_time, record_multiplier = record_multiplier_mn) %>%
      left_join(records_by_site, by = "site") %>%
      mutate(type = i,
             sp_per_core = filter(block_sizes, type == "lc")$block * record_multiplier,
             cores_needed = runs/sp_per_core,
             cores_rounded = ceiling(cores_needed),
             runs_per_core = ceiling(runs/cores_rounded),
             hr_if_max = runs_per_core * max_time / 60 / 60,
             hr_if_mean = runs_per_core * mean_time / 60 / 60,
             diff = cores_rounded - cores_needed)
  }) %>% bind_rows()
  

calc_cores %>% 
  # left_join(records_by_site, by = "site") %>% 
  print(n = 22)

calc_cores %>% 
  group_by(type) %>% 
  summarise(total_cores = sum(cores_rounded))

# construct a vector of index numbers based on the number of cores, the species per core, etc.

i <- 9
calc_cores %>% filter(type == "lc") %>%
  select(cores_rounded) %>% sum()

della_index <- lapply(1:11, function(i) {
  calc_cores_tmp <- calc_cores %>% filter(type == "lc")
  tmp <- calc_cores_tmp %>% filter(site == site_df$site[i])
  index <- rep(1:tmp$cores_rounded, each = tmp$runs_per_core)
  index <- index[1:tmp$runs]
  
  if(i>1) {index <- index + sum(calc_cores_tmp$cores_rounded[1:(i-1)])}
  
  index
}) %>% unlist()

della_index[1:1000 + 2*1000]
tail(della_index, n = 500)

length(della_index)
nrow(species_list)

# ----------
# *add index to the species_list*
# species_list <- species_list %>% select(-index)
species_list <- species_list %>%
  mutate(core_index = della_index)



unique(species_list$core_index)

species_list %>% filter(site %in% c("shaanxi", "chongqing")) %>% .$core_index %>% unique()

species_list %>%
  select(site, core_index) %>%
  unique() %>%
  print(n = 25)

calc_cores
```

```{r write-filtered-species-list}
# ------------------------------------------------------------- #
# Step. 5
# Write out the filtered species_list
# ------------------------------------------------------------- #
write_csv(species_list, file = paste0(p_derived, "species_list.csv"))

# see also "AOH.Rmd" chunk {r generate-final-species-list}, which produces the final list of bird and mammal species included in our analysis, along with the overall response to cropland abandonment (overall_trend), the sites where that species had AOH affected by cropland abandonment (sites), the IUCN Red List Category, the obligate_type (i.e., whether a species is a mature forest obligate, or not), the the range size quantile (ranking species by global geographic range size), and common names. Note that mature forest obligates were excluded from our final results.
```


```{r common-names}
# no longer necessary, but could be useful to future chris

common_names <- lapply(c("LC", "nonLC"), function(i) {
  read_csv(
    file = paste0(p_dat, "bd/IUCN/redlist_2022_01_04_animalia_", i, "/common_names.csv")#, n_max = 10
  ) %>% 
    select(binomial = scientificName, common_name = name 
           # , redlistCategory, rationale, habitat, threats, population
           )
}) %>% 
  bind_rows() %>% 
  filter(binomial %in% unique(species_ranges$binomial))

unique(species_ranges$binomial) %>% length()
unique(common_names$binomial) %>% length()

species_list %>%
  filter(!binomial %in% unique(common_names$binomial))

write_csv(common_names, file = paste0(p_derived, "iucn_common_names_subset.csv"))


common_names %>%
  group_by(binomial) %>%
  summarise(common_names = str_c(common_name, collapse = "; "))
  
common_names %>% filter(str_detect(common_name, "[:alpha:]"))
common_names %>% filter(str_detect(common_name, "[:punct:]")) %>% .$common_name


species_list %>%
  group_by(binomial, vert_class) %>%
  summarise(site_presence = str_c(site, collapse = "; ")) %>% ungroup()


common_names$binomial %>% unique %>% length
species_ranges$binomial %>% unique %>% length
species_list$binomial %>% unique %>% length

```


```{r IUCN-synonyms}
# if necessary, resolve species synonyms:

habitat_prefs$binomial %>% unique() %>% length() # these two match now: 2312
species_ranges$binomial %>% unique() %>% length()


# list of unique species-site combinations at my sites
non_match <-
  vert_sites %>%
  # species_ranges %>%
  st_drop_geometry() %>% as_tibble() %>%
  filter(vert_class != "gard") %>%
  select(site, vert_class, binomial, category, presence, origin, seasonal, marine) %>% 
  unique() %>% 
  filter(!binomial %in% unique(habitat_prefs$binomial))

# these species were filtered out in the preliminary stages, due to "presence"
# when I use species_ranges, everything matches

vert_sites %>%
  filter(vert_class != "gard",
         !binomial %in% unique(species_ranges$binomial)) %>% 
  st_drop_geometry() %>%
  select(site, vert_class, binomial, category, presence, origin, seasonal, marine)


non_match$binomial %>% unique() # 25 species in vert_sites are without a match.


# no longer necessary

species_synonyms <- lapply(c("LC", "nonLC"), function(i) {
  read_csv(
    file = paste0(p_dat, "bd/IUCN/redlist_2022_01_04_animalia_", i, "/synonyms.csv")#, n_max = 10
  ) %>% 
    select(binomial = scientificName, genusName, speciesName) %>%
    mutate(synonym = paste0(genusName, " ", speciesName))
}) %>% 
  bind_rows() 

species_synonyms_sub <- species_synonyms %>% 
  filter(synonym %in% unique(species_list$binomial) | binomial %in% unique(species_list$binomial) |
           synonym %in% unique(old_species_list$binomial) | binomial %in% unique(old_species_list$binomial)
           )

# write to file:
write_csv(species_synonyms, file = paste0(p_derived, "iucn_species_synonyms_subset.csv"))



# 25 species with names that do not match:
vert_sites %>% st_drop_geometry() %>% 
  filter(vert_class != "gard") %>% 
  select(binomial) %>% unique() %>% nrow() # 2322 unique species before filtering (old: 2230)




# play with synonyms:
species_synonyms

species_synonyms %>% filter(synonym %in% unique(non_match$binomial)) %>% arrange(synonym) %>% print(n = 30) # only 24 species have synonyms...

species_w_syn <- 
  species_synonyms %>% 
  filter(synonym %in% unique(non_match$binomial)) %>% 
  arrange(synonym)# %>% .$synonym

# what species does not have a synonym?
non_match %>% filter(!binomial %in% species_w_syn$synonym) %>% .$binomial %>% unique

habitat_prefs %>% filter(binomial == "Naemorhedus griseus")
habitat_prefs_all %>% filter(binomial == "Naemorhedus griseus")
elevation_prefs %>% filter(binomial == "Naemorhedus griseus")
grep("Naemorhedus", habitat_prefs$binomial)

# all species in the genus
habitat_prefs_all[grep("Naemorhedus", habitat_prefs_all$binomial), c(1:3, 6)]


filter(species_synonyms, synonym %in% unique(species_list$binomial))

species_list %>% filter(binomial == "Capricornis sumatraensis")
vert_sites %>% filter(binomial == "Capricornis sumatraensis")
vert_sites %>% filter(binomial == "Capricornis milneedwardsii") %>% st_geometry() %>% plot()

```


# 4. Species' Habitat Age Requirements

```{r prep-habitat-details}

# -----------
# extract a list of all suitable habitats for each species
# -----------
suitable_habitats_extract <- 
  habitat_prefs %>%
  filter(suitability == "Suitable") %>%
  mutate(combined = paste(code, name)) %>%
  arrange(binomial, code) %>% 
  select(binomial:name, combined) %>%
  unique() %>%
  group_by(binomial) %>%
  summarise(suitable_codes = str_c(code, collapse = "; "),
            suitable_habitats = str_c(combined, collapse = "; "))

# -----------
# extract a list of all habitats of Major Importance each species
# -----------
majorImportance_extract <- 
  habitat_prefs %>%
  filter(suitability == "Suitable",
         majorImportance == "Yes") %>%
  mutate(combined = paste(code, name)) %>%
  arrange(binomial, code) %>% 
  select(binomial:name, combined) %>%
  unique() %>%
  group_by(binomial) %>%
  summarise(major_codes = str_c(code, collapse = "; "),
            major_habitats = str_c(combined, collapse = "; "))


# -----------
# make a data.frame of each species with their habitat_description
# -----------

habitat_age_req <-
  species_list %>% # first add the species binomial, class, and site presence
  group_by(binomial, vert_class) %>%
  summarise(site_presence = str_c(site, collapse = "; ")) %>% 
  ungroup() %>%
  
  # then add the common names:
  left_join(common_names %>% group_by(binomial) %>%
              summarise(common_names = str_c(common_name, collapse = "; ")),
            by = "binomial") %>%
  
  # now, add the habitat codes and names for both suitable habitats and major importance habitats
  left_join(suitable_habitats_extract, by = "binomial") %>%
  left_join(majorImportance_extract, by = "binomial") %>% 

  left_join(select(habitat_details, binomial, redlistCategory, habitat), by = "binomial")

# those species without specific habitat descriptions can be treated in two ways:
# 1. conservatively - habitats are not suitable
# 2. all habitats that are said to be suitable can be assumed to be suitable at any age 

# clean up the html tags

text_to_remove <- c('<strong>', '</strong>', '<em>', '</em>', '<p>', '</p>', 
                    '<span style=\"font-weight: bold;\">', 
                    '<span style="FONT-WEIGHT: bold">',
                    '<span style=\"font-style: italic;\">', 
                    '<span style="FONT-STYLE: italic">',
                    '</span>', 
                    '<B>', '</B>', 
                    '<a name=\"OLE_LINK4\">',
                    '<span lang=\"EN-US\">', 
                    '<span lang=\"en-US\">',
                    '<span lang=\"en\">', 
                    '<span lang=\"EN-GB\">',
                    '<br>', '<br/>', 
                    '<sup>', '</sup>',
                    '<span class=\"quotename\">',
                    '<span class=\"msoIns\">', 
                    '<span style=\"font-style: italic; \">', 
                    '<span class=\"hps\">')

habitat_age_req <- 
  habitat_age_req %>%
  mutate(habitat = gsub(paste(text_to_remove, collapse = "|"), "", habitat),
         
         # remove white space:
         habitat = str_squish(habitat), 
         habitat = str_trim(habitat)
         )


# lots of species do not have specific habitat descriptions - arrange by this
habitat_age_req <- 
  habitat_age_req %>%
  mutate(has_desc = ifelse(is.na(habitat), 1, 0))


# add columns for classification, reorder columns, and arrange
habitat_age_req <- 
  habitat_age_req %>%
  mutate(age_req = NA,
         specialty = NA) %>%
  arrange(#has_desc, 
          vert_class, binomial) %>% 
  select(vert_class, binomial, common_names, 
         suitable_habitats, habitat, age_req, specialty, 
         site_presence,
         everything())

```

```{r separating-habitat-specialties}

# see _util_files.R
site_habitats %>% print(n = 34)

# ------------------------- species habitat specialty --------------------------- # 
habitat_age_req <- habitat_age_req %>%
  mutate(forest_occ =     str_detect(suitable_habitats, regex("forest|plantations", ignore_case = TRUE)),
         grass_occ =      str_detect(suitable_habitats, regex("grassland|savanna|shrubland|pasture", ignore_case = TRUE)),
         wetlands_occ =   str_detect(suitable_habitats, regex("wet", ignore_case = TRUE)),
         # note, that pasture shows up twice, in both grass_occ, and farmland_occ. Therefore, grass_occ and farmland_occ will overlap in some cases
         farmland_occ =   str_detect(suitable_habitats, regex("arable|pasture|garden", ignore_case = TRUE)),
         urban_occ =      str_detect(suitable_habitats, regex("urban", ignore_case = TRUE)),
         rocky_occ =      str_detect(suitable_habitats, regex("rocky", ignore_case = TRUE)),
         desert_occ =     str_detect(suitable_habitats, regex("desert", ignore_case = TRUE)),
         
         n_spec = rowSums(across(contains("occ"))),
         specialty = case_when(
           n_spec == 1 & forest_occ ~ "forest",
           n_spec == 1 & grass_occ ~ "grass",
           n_spec == 1 & wetlands_occ ~ "wetlands",
           n_spec == 1 & farmland_occ ~ "farmland",
           n_spec == 1 & urban_occ ~ "urban",
           n_spec == 1 & rocky_occ ~ "rocky",
           n_spec == 1 & desert_occ ~ "desert",
           n_spec == 2 & forest_occ & grass_occ ~ "for_grass",
           n_spec >= 5 ~ "generalist",
           TRUE ~ "NA"),
         ) #%>%
# testing
  # select(binomial, forest_occ:n_spec, specialty) %>%
  # filter(n_specialty >= 0) %>%
  # arrange(desc(n_spec)) %>% print(n = 50)


```


```{r save-intermediate-versions}
# -----------
# write to file
# -----------
# careful to not overwrite, until ready.
write_csv(habitat_age_req, file = paste0(p_derived, "iucn_habitat_age_req.csv"))
```


```{r load-intermediate-versions}
# reload
habitat_age_req <- read_csv(paste0(p_derived, "iucn_habitat_age_req.csv"))


# Alex's coded version
habitat_age_req_AW <- read_csv(paste0(p_derived, "/habitat_age_req/iucn_habitat_age_req_AW_121421.csv")) %>%
  mutate(coder = case_when(!is.na(mature_forest_obl) ~ "AW"))



# 2022_04_02: in progress:
habitat_age_req_2022_04_02_CC <- read_csv(
  paste0(p_derived, "habitat_age_req/", "habitat_age_req_partial_2022_04_02_CC.csv")) %>%
  mutate(coder = case_when(
    binomial %in% filter(habitat_age_req_AW, !is.na(mature_forest_obl))$binomial ~ "AW",
    # is.na(coder) & 
      !is.na(mature_forest_obl) ~ "CLC", # since this is evaluated sequentially, it already excludes those previously marked as "AW"
    is.na(mature_forest_obl) ~ NA_character_
  ))

habitat_age_req_2022_04_04_CC <- read_csv(
  paste0(p_derived, "habitat_age_req/", "habitat_age_req_partial_2022_04_04_CC.csv")) %>%
  mutate(coder = case_when(
    is.na(coder) & !is.na(mature_forest_obl) ~ "CLC", # if it doesn't already have a coder associated with it, and it has a code recorded for "mature_forest_obl", code it as "CLC",
    TRUE ~ coder # otherwise, keep it the same. 
    ))

# 04/05
habitat_age_req_2022_04_05_CC <- read_csv(
  paste0(p_derived, "habitat_age_req/", "habitat_age_req_partial_2022_04_05_CC.csv")) %>%
  mutate(coder = case_when(
    is.na(coder) & !is.na(mature_forest_obl) ~ "CLC", # if it doesn't already have a coder associated with it, and it has a code recorded for "mature_forest_obl", code it as "CLC",
    TRUE ~ coder # otherwise, keep it the same. 
    ))

# update species that AW coded as "N/A"
# habitat_age_req_2022_04_05_CC <- habitat_age_req_2022_04_05_CC %>%
#   filter(mature_forest_obl == "N/A") %>%
#   mutate(
#     mature_forest_obl = case_when(
#       binomial == "Abroscopus albogularis" ~ 0, # "Undergrowth of evergreen forest, especially bamboos, in mountain foothills; also bamboo thickets and secondary scrub in relatively open country. Chiefly between 600 m and 1200 m, but has been reported as low as 300 m and up to 1800 m."
#       binomial == "Accipiter brevipes" ~ 0,
#       binomial == "Accipiter gularis" ~ 0,
#       binomial == "Accipiter nisus" ~ 0),
#     water_obl = case_when(
#       binomial == "Abroscopus albogularis" ~ 0,
#       binomial == "Accipiter brevipes" ~ 0,
#       binomial == "Accipiter gularis" ~ 0,
#       binomial == "Accipiter nisus" ~ 0)
#     )

habitat_age_req_2022_04_05_CC %>%
  filter(mature_forest_obl == "N/A") %>%
  select(binomial:habitat)

habitat_age_req_2022_04_05_CC %>% filter(coder == "CLC") %>% tail()
habitat_age_req_2022_04_05_CC %>% filter(coder == "AW") %>% tail()
habitat_age_req_AW %>% filter(coder == "AW") #%>% tail()
filter(habitat_age_req_AW, !is.na(mature_forest_obl))


# -------------------------------------------------------- #
# Adding Mammals:
habitat_age_req_2022_06_17_CC <- read_csv(
  paste0(p_derived, "habitat_age_req/", "habitat_age_req_partial_2022_06_17_CC.csv")) %>%
  mutate(coder = case_when(
    is.na(coder) & !is.na(mature_forest_obl) ~ "CLC", # if it doesn't already have a coder associated with it, and it has a code recorded for "mature_forest_obl", code it as "CLC",
    TRUE ~ coder # otherwise, keep it the same. 
    ))

habitat_age_req_2022_06_17_CC %>% filter(is.na(coder))

# -------------------------------------------------------- #
# After completing Mammals:
habitat_age_req_2022_12_06 <- read_csv(
  paste0(p_derived, "habitat_age_req/", "habitat_age_req_partial_2022_12_06.csv")) %>%
  mutate(coder = case_when(
    is.na(coder) & !is.na(mature_forest_obl) ~ "CLC", # if it doesn't already have a coder associated with it, and it has a code recorded for "mature_forest_obl", code it as "CLC",
    TRUE ~ coder # otherwise, keep it the same. 
    ))

```

```{r save-habitat-reqs-in-progress}
# merge species list with Alex's coded records, plus however many records I've added

# create new partially filled out list to work on:

habitat_age_req_partial <- 
  habitat_age_req %>% 
  select(vert_class, binomial, common_names, habitat, 
         site_presence, suitable_habitats, major_habitats) %>%
  left_join(
    habitat_age_req_2022_04_05_CC %>% 
      select(binomial, mature_forest_obl, water_obl, coder, Chris_notes),
    by = "binomial") %>% 
  filter(vert_class != "amp") %>%
  arrange(vert_class, coder, mature_forest_obl, binomial) %>%
  select(vert_class:common_names, mature_forest_obl, water_obl, everything())


# save
write_csv(habitat_age_req_partial, file = paste0(p_derived, "habitat_age_req/", "habitat_age_req_partial", format(Sys.time(), "_%Y_%m_%d"), ".csv"))

# ---------------------------------------------------------------------------------------- #
```

```{r add-final-codes-to-habitat-req}

habitat_age_req_coded <- 
  habitat_age_req %>% 
  select(vert_class, binomial, common_names, habitat, 
         site_presence, suitable_habitats, major_habitats) %>%
  left_join(
    habitat_age_req_2022_04_05_CC %>% 
      select(binomial, mature_forest_obl, water_obl, coder, Chris_notes),
    by = "binomial") %>% 
  filter(vert_class != "amp") %>%
  arrange(vert_class, coder, mature_forest_obl, binomial) %>%
  select(vert_class:common_names, mature_forest_obl, water_obl, everything())



# save the most recent version with mammals classified as mature forest obligates
habitat_age_req_2022_12_06 %>%
  write_csv(file = paste0(p_derived, "habitat_age_req/", "habitat_age_req_coded.csv"))

# habitat_age_req_coded <- habitat_age_req_coded %>%
# # update Alces alces to make plotting for dissertation easier:
#   mutate(mature_forest_obl = ifelse(binomial == "Alces alces", NA, mature_forest_obl))

```

# 5. Development code

```{r range-maps-in-qgis}
# One option, other than validating via sf::st_make_valid(), which takes a long time, is to load into QGIS or ArcMap, and clip directly. QGIS allows for filtering for valid geometries, which can be turned off in settings, so the clip takes place even for invalid geometries (which is what I want).
# paste0(p_derived, "sf/bird_clip_qgis.shp") # is the final result here

# additions 3.11.22
bird_valid <- bird_valid %>%
  mutate(vertices = mapview::npts(., by_feature = TRUE))


st_layers(dsn = paste0(p_range,"BOTW/BOTW.gdb"))

# bird_sf <- st_read(dsn = paste0(p_range,"BOTW/BOTW.gdb"), layer = "All_Species")

test_clip <- st_read(dsn = paste0(p_derived, "sf/qgis_clip_test2.shp"))
test_clip %>% st_drop_geometry() %>% as_tibble() %>%
  arrange(sci_name) %>% print(n = 50)

test_clip %>% filter(grepl("Accipiter", sci_name)) %>% st_geometry() %>% plot
accipiter <- st_read(dsn = paste0(p_derived, "sf/accipiter.shp"))
accipiter_qgis <- st_read(dsn = paste0(p_derived, "sf/accipiter_crop.shp"))

plot(accipiter["seasonal"])

accipiter_crop_sf <- 
  accipiter %>%
  # test_sites <- test_sf %>%
  st_intersection(., site_sf)

accipiter_crop_sf2 <- 
  accipiter_qgis %>%
  # test_sites <- test_sf %>%
  st_intersection(., site_sf)

accipiter_crop_sf2 %>%
  st_geometry() %>%
  plot()

accipiter_crop_sf %>%
  st_geometry() %>%
  plot()

dev.off()
plot.new()
plot(site_sf$geometry)
plot(cars)

test_clip_crop <- 
  test_clip %>% st_intersection(., site_sf)

bird_selection <- st_read(dsn = paste0(p_derived, "sf/bird_selection.shp"))
bird_selection <- 
  bird_selection %>%
  mutate(pre_valid_reasons = st_is_valid(., reason = TRUE)) %>%
  st_make_valid() %>%
  mutate(post_valid_reasons = st_is_valid(., reason = TRUE))

bird_selection %>% st_drop_geometry()
bird_selection_crop <- bird_selection %>% st_intersection(., site_sf)
# maybe the right approach would be to crop in qgis, then re-do the st_intersection in R

test_clip_crop %>% st_drop_geometry() %>% as_tibble() %>%
  arrange(sci_name, presence, origin, seasonal)
bird_selection_crop %>% st_drop_geometry() %>% as_tibble() %>%
  arrange(sci_name, presence, origin, seasonal)

bird_qgis <- st_read(dsn = paste0(p_derived, "sf/bird_clip_qgis.shp"))

names(bird_qgis)

bird_prep


paste0(p_derived, "species_ranges") %>% list.files() 
load(paste0(p_derived, "species_ranges/", "bird_sites.RData"), verbose = T)
bird_sites <- range_sites %>%  # or assign("bird_sites", range_sites)
  mutate(vert_class = "bird")

rm(range_sites)

bird_sites %>%
  st_drop_geometry() %>%
  as_tibble() %>%
  select(binomial, site) %>% arrange(binomial) %>% unique()

bird_sites %>% filter(binomial == "Cyanecula svecica")
names(bird_sites)

bird_sites %>%
  st_drop_geometry() %>%
  as_tibble() %>%
  head()

summary(bird_sites %>% select(presence, origin, seasonal))

bird_sites %>% st_drop_geometry() %>% select(contains("valid")) %>% unique()

bird_sites %>%
  st_drop_geometry() %>% 
  # filter(marine == "false") %>%
  group_by(site) %>%
  select(site, binomial) %>%
  summarise(num_sp = length(unique(binomial)))
```


```{r plot-warblers}
warblers <- species_ranges %>%
  filter(str_detect(binomial, "Setophaga")) %>% 
  #select("seasonal") %>% plot
  st_cast() %>%
  fasterize(.,
                raster::raster(resolution = terra::res(elevation_map[[11]])*100,
                               ext = raster::extent(site_sf %>% filter(site %in% c("nebraska", "wisconsin")))),
            fun = "count"
                # field = "seasonal" # so that cell values correspond to seasonality code
      ) %>% 
      rast()

plot(warblers)
# Passage only. 
# Setophaga caerulescens	Black-throated Blue Warbler
# Setophaga castanea	Bay-breasted Warbler
# Setophaga striata	Blackpoll Warbler

```

```{r seasonality-of-ranges}
# 1a. filter to presence, defaults to code 1 (extant species only). Other unused codes are:
# ------ 2. Probably Extant (discontinued, ambiguous), 3. Possibly Extant,
# ------ 4. Possibly Extinct, 5. Extinct, 6. Presence Uncertain.
# 1b. filter to origin, defaults to codes 1 & 2 (native and reintroduced species respectively).
# ------ Other unused codes are: 3. Introduced, 4. Vagrant, 5. Origin Uncertain, 6. Assisted Colonisation.
# 1c. filter by marine, defaults to "FALSE" (all species but marine ones)
# 1d. filter species with range seasonality. Defaults to c(1,2,3).
# ------ Codes are: "Resident" (1), "Breeding" (2), "Non-breeding Season" (3),
# ------ Passage (4), and Seasonal Occurrence Uncertain (5).
# 1e. filter out Extinct or Extinct in the Wild species ("EX", "EW")
species_ranges %>%
  st_drop_geometry() %>% as_tibble() %>%
  select(site:seasonal, -id_no)

species_ranges %>% 
  st_drop_geometry() %>% as_tibble() %>%
  # nrow()
  # .$binomial %>% unique() %>% length() # 2230

  filter(presence == 1) %>%   # only records with Code 1 (Extant)
  filter(origin %in% c(1, 2)) %>%     # only native species (Code 1) and reintroduced (Code 2)
  filter(seasonal %in% c(1, 2, 3 #,4
                         )) %>%   # selecting "Resident" (1), "Breeding" (2), and "Non-breeding Season" (3) ranges. Other categories include: Passage (4) and Seasonal Occurrence Uncertain (5).

  filter(!category %in% c("EW", "EX")) %>% # remove Extinct or Extinct in the Wild species ("EW", "EX")
  # .$binomial %>% unique() %>% length()
  nrow()



species_ranges %>% 
  st_drop_geometry() %>% as_tibble() %>%
  filter(vert_class == "bird") %>%
    select(site:seasonal, -id_no, marine) %>%
  select(binomial, seasonal) %>% unique() # %>% group_by(seasonal) %>%
  summarise(species = unique(binomial))# %>% n())

species_ranges %>% 
  st_drop_geometry() %>% as_tibble() %>%
  # filter(vert_class == "bird") %>%
    select(site:seasonal, -id_no, marine) %>%
  select(binomial, seasonal
         ) %>% unique()

species_list$binomial %>% unique() %>% length()
species_ranges$binomial %>% unique() %>% length()

# try fasterizing range maps to allow for seasonality to be included here:
birds_w_seasonality <- species_ranges %>% 
      st_drop_geometry() %>% as_tibble() %>%
      select(site:category, seasonal) %>% unique() %>%
      filter(vert_class == "bird",
             site == site_df$site[site_index]) %>%
      group_by(binomial) %>% summarise(n_sp = n()) %>% filter(n_sp > 1) %>% .$binomial

species_ranges %>%
  filter(site == site_df$site[site_index],
         binomial %in% birds_w_seasonality[1]) %>%
    select(site:seasonal, -id_no) %>%
  st_cast() %>%
  select(seasonal) %>%
  plot()

species_ranges %>% st_drop_geometry() %>% 
  filter(vert_class == "bird",
         site == site_df$site[site_index],
         binomial %in% birds_w_seasonality) %>% 
  arrange(binomial, seasonal) %>% as_tibble()

species_ranges %>% filter(binomial == "Alauda arvensis")

range_t <-
  species_ranges %>%
  filter(site == site_df$site[site_index],
         binomial %in% birds_w_seasonality[1]) %>%
    select(site:seasonal, -id_no) %>%
  st_cast() %>%
  # select(seasonal) %>%
    # plot()
      fasterize(.,
                raster::raster(resolution = terra::res(elevation_map[[site_index]]),
                               ext = raster::extent(terra::ext(elevation_map[[site_index]])[1:4])),
                field = "seasonal"
      ) %>% terra::rast(.)

# cool!
plot(range_t)
```

```{r species-specific-explorations}
# remove double record for Swainson's thrush:
# Catharus swainsoni should stay in
# Catharus ustulatus should be removed. 

species_ranges %>% filter(str_detect(binomial, "Catharus swainsoni|Catharus ustulatus"))
species_ranges %>% filter(str_detect(binomial, "Catharus swainsoni"), site == "wisconsin") %>% select(seasonal) %>% plot()

species_ranges %>% filter(str_detect(binomial, "Microhierax melanoleucos"))
species_ranges %>% filter(str_detect(binomial, "Myiomela leucura"))

# "Grus americana" - whooping crane, where abandoned agricultural land is almost certainly not going to add meaningful habitat? Passage areas are not included in final analysis.
habitat_age_req_coded %>% filter(binomial == "Grus americana") #%>% select(Chris_notes)


# How about birds which require mature forest for breeding, but not during passage?
# Examples include smew (Mergellus albellus), common merganser (Mergus merganser), scaly-sided merganser (Mergus squamatus) etc. I have marked these as mature_forest_obl given their need for mature trees for nest cavities.
# 

# Tree cavities for nesting?
species_ranges %>% filter(str_detect(binomial, "Otus sunia")) # oriental scops-owl
species_ranges %>% filter(str_detect(binomial, "Otus semitorques")) # Japanese scops-owl
species_ranges %>% filter(str_detect(binomial, "Melanerpes erythrocephalus")) # # Red-headed woodpecker:

# p
species_ranges %>% filter(str_detect(binomial, "Fringilla coelebs")) # common chaffinch

species_ranges %>% filter(str_detect(binomial, "Muscicapa striata")) # spotted flycatcher

species_ranges %>% filter(str_detect(binomial, "Pardaliparus venustulus")) # yellow-bellied tit - non-breeding found in any sizeable patch of trees, but description as follows: "Broadleaf subtropical and evergreen forests, including mixed conifer and deciduous forest with bamboo, larches (Larix), willow (Salix) groves and other scattered trees at edges of cultivation; in non-breeding season more widely dispersed and may be found in almost any sizeable patch of trees."


species_ranges %>% filter(str_detect(binomial, "Phoenicurus frontalis")) # blur-fronted redstart

species_ranges %>% filter(str_detect(binomial, "Phylloscopus inornatus")) %>% # Phylloscopus warblers, like this one: Yellow-browed warbler (passage)
  st_geometry() %>% plot()

species_ranges %>% filter(str_detect(binomial, "Phylloscopus nitidus")) # green warbler
species_ranges %>% filter(str_detect(binomial, "Phylloscopus proregulus")) # Pallas's leaf warbler

species_ranges %>% filter(str_detect(binomial, "Phylloscopus subaffinis"))

species_ranges %>% filter(str_detect(binomial, "Picus viridis")) # 

species_ranges %>% filter(str_detect(binomial, "Pitta nympha")) # fairy pitta.
# It breeds in subtropical forest, where its localised distribution suggests that it has specialised habitat requirements. Peak breeding season in Taiwan is in May and June. In Japan, it breeds primarily in broadleaved evergreen forest near the coast (mostly below 500 m), although breeding has been recorded from plantations and the species appears to be adaptable to modified forest habitats. In South Korea, it breeds in dense moist forest and broadleaved forest near the coast, up to 1,200 m. The nest is usually built in crevices or foliage 1-5 m above the ground. It forages amongst leaf-litter for invertebrates, also occasionally taking snakes, lizards and small rodents (Wild at Heart Legal Defence Association undated).


species_ranges %>% filter(str_detect(binomial, "Pnoepyga pusilla")) # pygmy cupwing
# "Floor and understorey of broadleaf evergreen forest, densely vegetated forest ravines, mossy boulders, fallen logs, dense fern growth, luxuriant moss. Similar habitat on Flores, described as montane forest, Eupatrium scrub and occasionally roadside regrowth and tall secondary forest; on Timor occurs around large rocky outcrops."

species_ranges %>% filter(str_detect(binomial, "Poecile lugubris")) # Sombre tit - cavity nesting? But largely open forests. 

species_ranges %>% filter(str_detect(binomial, "Poecile palustris")) # marsh tit - primarily mature forest, but occasionally seen in orchards, gardens, etc. 
species_ranges %>% filter(str_detect(binomial, "Pteruthius aeralatus"))  # white-browed shrike-babbler
species_ranges %>% filter(str_detect(binomial, "Pucrasia macrolopha")) # koklass pheasant


species_ranges %>% filter(str_detect(binomial, "Regulus ignicapilla")) # common firecrest &
species_ranges %>% filter(str_detect(binomial, "Regulus regulus")) # goldcrest

species_ranges %>% st_drop_geometry() %>% filter(str_detect(binomial, "Setophaga ")) %>% select(site:seasonal)
```



